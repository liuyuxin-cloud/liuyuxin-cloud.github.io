<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RecyclerView源码解析 | liuyuxin'blog</title><meta name="keywords" content="Android"><meta name="author" content="liuyuxin"><meta name="copyright" content="liuyuxin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RecyclerView源码解析RecyclerView 可以让您轻松高效地显示大量数据。您提供数据并定义每个列表项的外观，而 RecyclerView 库会根据需要动态创建元素。 顾名思义，RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView源码解析">
<meta property="og:url" content="http://liuyuxin-cloud.github.io/2021/12/09/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="liuyuxin&#39;blog">
<meta property="og:description" content="RecyclerView源码解析RecyclerView 可以让您轻松高效地显示大量数据。您提供数据并定义每个列表项的外观，而 RecyclerView 库会根据需要动态创建元素。 顾名思义，RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2021/12/10/oIT8Q1.jpg">
<meta property="article:published_time" content="2021-12-09T08:45:06.000Z">
<meta property="article:modified_time" content="2022-03-27T02:15:09.539Z">
<meta property="article:author" content="liuyuxin">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2021/12/10/oIT8Q1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://liuyuxin-cloud.github.io/2021/12/09/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RecyclerView源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-27 10:15:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Index</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="http://liuyuxin-cloud.github.io"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Tags</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/tags/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Categories</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/categories/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Archives</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/archives/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> About</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/about/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Contact</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/contact/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Friends</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/friends"><span> url</span></a></li><li><a class="site-page child" href="/fa-address-book"><span> icon</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2021/12/10/oIT8Q1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">liuyuxin'blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Index</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="http://liuyuxin-cloud.github.io"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Tags</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/tags/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Categories</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/categories/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Archives</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/archives/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> About</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/about/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Contact</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://liuyuxin-cloud.github.io/contact/"><span> url</span></a></li><li><a class="site-page child" href="/fas%20fa-cloud"><span> icon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Friends</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/friends"><span> url</span></a></li><li><a class="site-page child" href="/fa-address-book"><span> icon</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RecyclerView源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-09T08:45:06.000Z" title="发表于 2021-12-09 16:45:06">2021-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-27T02:15:09.539Z" title="更新于 2022-03-27 10:15:09">2022-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RecyclerView源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h1><p>RecyclerView 可以让您轻松高效地显示大量数据。您提供数据并定义每个列表项的外观，而 RecyclerView 库会根据需要动态创建元素。</p>
<p>顾名思义，RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改善应用响应能力并降低功耗。</p>
<p>详细使用方法请参照<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui/layout/recyclerview">开发者文档</a><span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>   </p>
<h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">ScrollingView</span>,</span></span><br><span class="line"><span class="class">        <span class="title">NestedScrollingChild2</span>, <span class="title">NestedScrollingChild3</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出<code>RecyclerView</code>继承于<code>ViewGroup</code>，本身也是一个自定义View，实现了<code>ScrollingView</code>等接口。</p>
<h2 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h2><p>本质上是自定义View，则有onMeasure、onLayout、onDraw三步绘制过程。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>自定义View的onMeausre 的具体逻辑，在这里，依然可以做个参考：</p>
<ol>
<li>super.onMeasure 会先计算自定义 view 的大小；</li>
<li>调用 measureChild 对子 View 进行测量；</li>
<li>自定义 view 设置的宽高参数不是 MeasureSpec.EXACTLY 的话，对于子 View 是 match_parent 需要额外处理，同时也需要对 MeasureSpec.AT_MOST 情况进行额外处理。</li>
<li> 当自定义View 的大小确定后，在对子 View 是 match_parent 重新测量；</li>
</ol>
<p>在RecyclerView的onMeasure中有三种情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 情况1</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mLayout.mAutoMeasure) {</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 情况3</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><code>mLayout==null</code>  <code>mLayout </code>即 <code>LayoutManager </code>的对象。我们知道，当 <code>RecyclerView </code>的 <code>LayoutManager </code>为空时，<code>RecyclerView </code>不能显示任何的数据，在这里我们找到答案。</li>
<li><code>LayoutManager </code>开启了自动测量时，这是一种情况。在这种情况下，有可能会测量两次。</li>
<li>第三种情况就是没有开启自动测量的情况，这种情况比较少，因为 <code>RecyclerView </code>为了支持 <code>warp_content </code>属性，系统提供的 <code>LayoutManager </code>都开启自动测量的，不过还是要分析的。</li>
</ol>
<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) {</span><br><span class="line">    defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里调用了<code>defaultOnMeasure</code>方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An implementation of {<span class="doctag">@link</span> View#onMeasure(int, int)} to fall back to in various scenarios</span></span><br><span class="line"><span class="comment"> * where this RecyclerView is otherwise lacking better information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultOnMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>{</span><br><span class="line">    <span class="comment">// calling LayoutManager here is not pretty but that API is already public and it is better</span></span><br><span class="line">    <span class="comment">// than creating another method since this is internal.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = LayoutManager.chooseSize(widthSpec,</span><br><span class="line">            getPaddingLeft() + getPaddingRight(),</span><br><span class="line">            ViewCompat.getMinimumWidth(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = LayoutManager.chooseSize(heightSpec,</span><br><span class="line">            getPaddingTop() + getPaddingBottom(),</span><br><span class="line">            ViewCompat.getMinimumHeight(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法中通过<code>LayoutManager.choose()</code>方法来计算宽高值，然后<strong>调用setMeasuredDimension()设置宽高</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chooses a size from the given specs and parameters that is closest to the desired size</span></span><br><span class="line"><span class="comment"> * and also complies with the spec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spec The measureSpec</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desired The preferred measurement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min The minimum value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A size that fits to the given specs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chooseSize</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> desired, <span class="keyword">int</span> min)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mode = View.MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = View.MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="keyword">switch</span> (mode) {</span><br><span class="line">        <span class="keyword">case</span> View.MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        <span class="keyword">case</span> View.MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">return</span> Math.min(size, Math.max(desired, min));</span><br><span class="line">        <span class="keyword">case</span> View.MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> Math.max(desired, min);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>chooseSize方法就是通过RecyclerView的不同测量模式来选取不同的值。这里没有测量子 view 的大小，这也是白屏的原因。因为 RecyclerView 的绘制其实是委托给 LayoutManager 来管理，LayoutManager = null 的情况下测量子 view 没有任何的意义。</p>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) {</span><br><span class="line">    <span class="comment">//先获取测量模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用LayoutManager.onMeasure方法测量</span></span><br><span class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">	<span class="comment">//判断是否可以跳过测量或者adapter为null，直接返回。</span></span><br><span class="line">    <span class="comment">/*自定义 view 设置的宽高参数不是 MeasureSpec.EXACTLY 的话，对于子 View 是 match_parent 需要额外处理。*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly =</span><br><span class="line">            widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">    <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//开始测量</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) {</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span></span><br><span class="line">    <span class="comment">// consistency</span></span><br><span class="line">    mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">    dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">    mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">    <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">    <span class="comment">//第二次</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) {</span><br><span class="line">        mLayout.setMeasureSpecs(</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">        <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种情况下，首先调用<code>LayoutManager.onMeasure</code>方法测量，但是Android官方的三种LayoutManager(LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutManager)都没有复写此方法，此方法源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(Recycler recycler, State state, <span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>{</span><br><span class="line">    mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是自定义View的onMeasure步骤中的测量自己本身的大小。</p>
<p>接下来判断<code>mState.mLayoutStep</code>这个变量，即当前绘制状态，如果为<code>State.STEP_START</code>，那么便会执行<code>dispatchLayoutStep1</code>方法，随后又调用了<code>dispatchLayoutStep2</code>方法，最后如果需要二次测量的话，那么会再调用一次<code>dispatchLayoutStep2</code>方法。</p>
<p>我们先来分别看一下<code>mState.mLayoutStep</code>变量的含义和<code>dispatchLayoutStepX</code>系列方法的作用。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o4M6D1"><img src="https://s1.ax1x.com/2021/12/09/o4M6D1.jpg" alt="o4M6D1.jpg" style="zoom: 50%;"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o4MIvd"><img src="https://s1.ax1x.com/2021/12/09/o4MIvd.jpg" alt="o4MIvd.jpg" style="zoom: 50%;"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//这里还用到了断言</span></span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    fillRemainingScrollValues(mState);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    <span class="comment">//处理adapter更新</span></span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否要运行动画</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) {</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="comment">// 找出所有未移除的ItemView，进行预布局</span></span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) {</span><br><span class="line">        <span class="comment">// Step 1: run prelayout: This will use the old positions of items. The layout manager</span></span><br><span class="line">        <span class="comment">// is expected to layout everything, even removed items (though not to add removed</span></span><br><span class="line">        <span class="comment">// items back to the container). This gives the pre-layout position of APPEARING views</span></span><br><span class="line">        <span class="comment">// which come into existence as part of the real layout.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save old positions so that LayoutManager can run its mapping logic.</span></span><br><span class="line">        <span class="comment">//保存旧状态进行预布局。</span></span><br><span class="line">        ......</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    }</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//改变状态</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到<code>dispatchLayoutStep1</code>方法主要是根据<code>mState.mRunPredictiveAnimations</code>和<code>mState.mRunPredictiveAnimations</code>两个值做出相应的逻辑处理。而在<code>processAdapterUpdatesAndSetAnimationFlags</code>方法中，计算了这两个值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAdapterUpdatesAndSetAnimationFlags</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    mState.mRunSimpleAnimations = mFirstLayoutComplete</span><br><span class="line">        &amp;&amp; mItemAnimator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (mDataSetHasChangedAfterLayout</span><br><span class="line">            || animationTypeSupported</span><br><span class="line">            || mLayout.mRequestedSimpleAnimations)</span><br><span class="line">        &amp;&amp; (!mDataSetHasChangedAfterLayout</span><br><span class="line">            || mAdapter.hasStableIds());</span><br><span class="line">    mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations</span><br><span class="line">        &amp;&amp; animationTypeSupported</span><br><span class="line">        &amp;&amp; !mDataSetHasChangedAfterLayout</span><br><span class="line">        &amp;&amp; predictiveItemAnimationsEnabled();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里我们关注一下<code>mFirstLayoutComplete</code>变量，我们发现<code>mRunSimpleAnimations</code>的值与<code>mFirstLayoutComplete</code>有关，<code>mRunPredictiveAnimations</code>同时跟<code>mRunSimpleAnimations</code>有关。第一次绘制流程还未完成，<code>mFirstLayoutComplete==false</code>所以<code>mRunSimpleAnimations = mRunPredictiveAnimations == false</code>，当RecyclerView第一次加载数据时，是不会执行动画的。每个ItemView还没有layout完毕，是不会进行动画的。</p>
<p>接下来，我们看dispatchLayoutStep2方法，其中，对RecyclerView的子View进行了Layout：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>{</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//改变状态</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>1、2处可以看到，对children进行了测量和布局。</p>
<p><code>LayoutManager</code>的<code>onLayoutChildren</code>方法是一个空方法，所以需要<code>LayoutManager</code>的子类自己实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> </span>{</span><br><span class="line">    Log.e(TAG, <span class="string">"You must override onLayoutChildren(Recycler recycler, State state) "</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="onLayoutChildren"><a href="#onLayoutChildren" class="headerlink" title="onLayoutChildren"></a>onLayoutChildren</h5><p>RecyclerView将View的绘制交给了LayoutManager。将RecyclerView内部持有的<code>Recycler</code>和<code>state</code>传给了<code>LayoutManager</code>的<code>onLayoutChildren</code>方法。这里我们分析<code>LinearLayoutManager</code>。</p>
<p>大概流程：</p>
<ul>
<li>确定锚点信息，包括：1.<code>Children</code>的布局方向，有start和end两个方向。2.<code>mPosition</code>和<code>mCoordinate</code>，分别表示<code>Children</code>开始填充的position和坐标。</li>
<li>调用<code>detachAndScrapAttachedViews</code>方法，<code>detach</code>掉或者<code>remove</code>掉<code>RecyclerView</code>的<code>Children</code>。（与缓存机制相关）</li>
<li>根据锚点信息，调用<code>fill</code>方法进行<code>Children</code>的填充。根据锚点信息的不同，可能会调用两次<code>fill</code>方法。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>{</span><br><span class="line">    <span class="comment">// 第一步找寻锚点</span></span><br><span class="line">    <span class="comment">// 两个方向填充，从锚点往上和锚点往下</span></span><br><span class="line">    <span class="comment">// 判断绘制方向，给mShouldReverseLayout赋值，默认是正向绘制，则mShouldReverseLayout是False</span></span><br><span class="line">    	...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// resolve layout direction</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">    <span class="comment">// mValid 的默认值是false，一次测量之后设为true，onLayout 完成后会回调执行reset方法，又变为false</span></span><br><span class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">            || mPendingSavedState != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// mStackFromEnd默认是false，除非手动调用setStackFromEnd方法，两个都会false，异或为false</span></span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">        <span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">        <span class="comment">// 计算锚点位置和偏移量。</span></span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                    &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">            || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">            &lt;= mOrientationHelper.getStartAfterPadding())) {</span><br><span class="line">        </span><br><span class="line">        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//第二步</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    mLayoutState.mInfinite = resolveIsInfinite();</span><br><span class="line">    mLayoutState.mIsPreLayout = state.isPreLayout();</span><br><span class="line">    </span><br><span class="line">   		...</span><br><span class="line">    <span class="comment">//mLayoutFromEnd为false    </span></span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) {</span><br><span class="line">        <span class="comment">// 第三步</span></span><br><span class="line">        <span class="comment">// 倒着绘制的话，先往上绘制，再往下绘制</span></span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        <span class="comment">// 从锚点到往上</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        ...</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        <span class="comment">// 从锚点到往下</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//调两遍fill方法    </span></span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">		...</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">			...</span><br><span class="line">            updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">			...</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        <span class="comment">// 正常绘制流程的话，先往下绘制，再往上绘制</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">		...</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">		...</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// start could not consume all it should. add more items towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">			...</span><br><span class="line">    		fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">    <span class="comment">//完成后重置参数</span></span><br><span class="line">    <span class="keyword">if</span> (!state.isPreLayout()) {</span><br><span class="line">        mOrientationHelper.onLayoutComplete();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">    }</span><br><span class="line">    mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="确定锚点信息"><a href="#确定锚点信息" class="headerlink" title="确定锚点信息"></a>确定锚点信息</h6><p>首先执行<code>resolveShouldLayoutReverse</code>方法判断是否需要倒着绘制：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolveShouldLayoutReverse</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// A == B is the same result, but we rather keep it readable</span></span><br><span class="line">    <span class="comment">//默认情况下，`mReverseLayout`为false，是不会倒着绘制的。手动调用`setReverseLayout`方法可以改变`mRverseLayout`的值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL || !isLayoutRTL()) {</span><br><span class="line">        mShouldReverseLayout = mReverseLayout;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mShouldReverseLayout = !mReverseLayout;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下通过<code>updateAnchorInfoForLayout</code>方法来计算锚点信息。</p>
<p>锚点：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnchorInfo</span> </span>{</span><br><span class="line">    OrientationHelper mOrientationHelper;</span><br><span class="line">    <span class="keyword">int</span> mPosition;	<span class="comment">//position</span></span><br><span class="line">    <span class="keyword">int</span> mCoordinate;  <span class="comment">//坐标</span></span><br><span class="line">    <span class="keyword">boolean</span> mLayoutFromEnd;	<span class="comment">//mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd</span></span><br><span class="line">    <span class="keyword">boolean</span> mValid;  <span class="comment">//默认false，一次测量后设为true，onLayout后回调reset，重置为false</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAnchorInfoForLayout</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnchorInfo anchorInfo)</span> </span>{</span><br><span class="line">    <span class="comment">//第一种计算方法</span></span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromPendingData(state, anchorInfo)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//第二种计算方法</span></span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromChildren(recycler, state, anchorInfo)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//第三种计算方法</span></span><br><span class="line">    anchorInfo.assignCoordinateFromPadding();</span><br><span class="line">    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>第一种：1.RecyclerView被重建，期间调用了<code>onSaveInstanceState</code>方法，目的是为了恢复上次的布局。2.RecyclerView调用了<code>scrollToPosition</code>之类的方法，目的是让RecyclerView滚到准确的位置上去。</li>
<li>第二种：根据子View来更新锚点信息，如果一个子View有焦点，则根据其来计算锚点信息；如果没有焦点，则根据布局方向选取可见的第一个ItemView或最后一个ItemView</li>
<li>第三种：前两种都未采用。</li>
</ul>
<h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (mHasFixedSize<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>{</span><br><span class="line">        <span class="comment">// layout algorithm:</span></span><br><span class="line">        <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></span><br><span class="line">        <span class="comment">//  item position.</span></span><br><span class="line">        <span class="comment">// 2) fill towards start, stacking from bottom</span></span><br><span class="line">        <span class="comment">// 3) fill towards end, stacking from top</span></span><br><span class="line">        <span class="comment">// 4) scroll to fulfill requirements like stack from bottom.</span></span><br><span class="line">        <span class="comment">// create layout state</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) {</span><br><span class="line">            Log.d(TAG, <span class="string">"is pre layout:"</span> + state.isPreLayout());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> || mPendingScrollPosition != RecyclerView.NO_POSITION) {</span><br><span class="line">            <span class="keyword">if</span> (state.getItemCount() == <span class="number">0</span>) {</span><br><span class="line">                removeAndRecycleAllViews(recycler);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> &amp;&amp; mPendingSavedState.hasValidAnchor()) {</span><br><span class="line">            mPendingScrollPosition = mPendingSavedState.mAnchorPosition;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ensureLayoutState();</span><br><span class="line">        mLayoutState.mRecycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// resolve layout direction</span></span><br><span class="line">        resolveShouldLayoutReverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">        <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">                || mPendingSavedState != <span class="keyword">null</span>) {</span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">            <span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">            mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                        &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">                &lt;= mOrientationHelper.getStartAfterPadding())) {</span><br><span class="line">            <span class="comment">// This case relates to when the anchor child is the focused view and due to layout</span></span><br><span class="line">            <span class="comment">// shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows</span></span><br><span class="line">            <span class="comment">// up after tapping an EditText which shrinks RV causing the focused view (The tapped</span></span><br><span class="line">            <span class="comment">// EditText which is the anchor child) to get kicked out of the screen. Will update the</span></span><br><span class="line">            <span class="comment">// anchor coordinate in order to make sure that the focused view is laid out. Otherwise,</span></span><br><span class="line">            <span class="comment">// the available space in layoutState will be calculated as negative preventing the</span></span><br><span class="line">            <span class="comment">// focused view from being laid out in fill.</span></span><br><span class="line">            <span class="comment">// Note that we won't update the anchor position between layout passes (refer to</span></span><br><span class="line">            <span class="comment">// TestResizingRelayoutWithAutoMeasure), which happens if we were to call</span></span><br><span class="line">            <span class="comment">// updateAnchorInfoForLayout for an anchor that's not the focused view (e.g. a reference</span></span><br><span class="line">            <span class="comment">// child which can change between layout passes).</span></span><br><span class="line">            mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) {</span><br><span class="line">            Log.d(TAG, <span class="string">"Anchor info:"</span> + mAnchorInfo);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LLM may decide to layout items for "extra" pixels to account for scrolling target,</span></span><br><span class="line">        <span class="comment">// caching or predictive animations.</span></span><br><span class="line"></span><br><span class="line">        mLayoutState.mLayoutDirection = mLayoutState.mLastScrollDelta &gt;= <span class="number">0</span></span><br><span class="line">                ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">        mReusableIntPair[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        mReusableIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        calculateExtraLayoutSpace(state, mReusableIntPair);</span><br><span class="line">        <span class="keyword">int</span> extraForStart = Math.max(<span class="number">0</span>, mReusableIntPair[<span class="number">0</span>])</span><br><span class="line">                + mOrientationHelper.getStartAfterPadding();</span><br><span class="line">        <span class="keyword">int</span> extraForEnd = Math.max(<span class="number">0</span>, mReusableIntPair[<span class="number">1</span>])</span><br><span class="line">                + mOrientationHelper.getEndPadding();</span><br><span class="line">        <span class="keyword">if</span> (state.isPreLayout() &amp;&amp; mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">                &amp;&amp; mPendingScrollPositionOffset != INVALID_OFFSET) {</span><br><span class="line">            <span class="comment">// if the child is visible and we are going to move it around, we should layout</span></span><br><span class="line">            <span class="comment">// extra items in the opposite direction to make sure new items animate nicely</span></span><br><span class="line">            <span class="comment">// instead of just fading in</span></span><br><span class="line">            <span class="keyword">final</span> View existing = findViewByPosition(mPendingScrollPosition);</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> current;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> upcomingOffset;</span><br><span class="line">                <span class="keyword">if</span> (mShouldReverseLayout) {</span><br><span class="line">                    current = mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                            - mOrientationHelper.getDecoratedEnd(existing);</span><br><span class="line">                    upcomingOffset = current - mPendingScrollPositionOffset;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    current = mOrientationHelper.getDecoratedStart(existing)</span><br><span class="line">                            - mOrientationHelper.getStartAfterPadding();</span><br><span class="line">                    upcomingOffset = mPendingScrollPositionOffset - current;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (upcomingOffset &gt; <span class="number">0</span>) {</span><br><span class="line">                    extraForStart += upcomingOffset;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    extraForEnd -= upcomingOffset;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> startOffset;</span><br><span class="line">        <span class="keyword">int</span> endOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstLayoutDirection;</span><br><span class="line">        <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) {</span><br><span class="line">            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL</span><br><span class="line">                    : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">                    : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">        detachAndScrapAttachedViews(recycler);</span><br><span class="line">        mLayoutState.mInfinite = resolveIsInfinite();</span><br><span class="line">        mLayoutState.mIsPreLayout = state.isPreLayout();</span><br><span class="line">        <span class="comment">// noRecycleSpace not needed: recycling doesn't happen in below's fill</span></span><br><span class="line">        <span class="comment">// invocations because mScrollingOffset is set to SCROLLING_OFFSET_NaN</span></span><br><span class="line">        mLayoutState.mNoRecycleSpace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) {</span><br><span class="line">            <span class="comment">// fill towards start</span></span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> firstElement = mLayoutState.mCurrentPosition;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                extraForEnd += mLayoutState.mAvailable;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// fill towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForEnd;</span><br><span class="line">            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">                extraForStart = mLayoutState.mAvailable;</span><br><span class="line">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">                mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset = mLayoutState.mOffset;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// fill towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForEnd;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                extraForStart += mLayoutState.mAvailable;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// fill towards start</span></span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                extraForEnd = mLayoutState.mAvailable;</span><br><span class="line">                <span class="comment">// start could not consume all it should. add more items towards end</span></span><br><span class="line">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">                mLayoutState.mExtraFillSpace = extraForEnd;</span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">                endOffset = mLayoutState.mOffset;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// changes may cause gaps on the UI, try to fix them.</span></span><br><span class="line">        <span class="comment">// TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have</span></span><br><span class="line">        <span class="comment">// changed</span></span><br><span class="line">        <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// because layout from end may be changed by scroll to position</span></span><br><span class="line">            <span class="comment">// we re-calculate it.</span></span><br><span class="line">            <span class="comment">// find which side we should check for gaps.</span></span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout ^ mStackFromEnd) {</span><br><span class="line">                <span class="keyword">int</span> fixOffset = fixLayoutEndGap(endOffset, recycler, state, <span class="keyword">true</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">                fixOffset = fixLayoutStartGap(startOffset, recycler, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">int</span> fixOffset = fixLayoutStartGap(startOffset, recycler, state, <span class="keyword">true</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">                fixOffset = fixLayoutEndGap(endOffset, recycler, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">        <span class="keyword">if</span> (!state.isPreLayout()) {</span><br><span class="line">            mOrientationHelper.onLayoutComplete();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">        }</span><br><span class="line">        mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) {</span><br><span class="line">            validateChildOrder();</span><br><span class="line">        }</span><br><span class="line">    }) {</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// custom onMeasure</span></span><br><span class="line">    <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) {</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mState.mRunPredictiveAnimations) {</span><br><span class="line">            mState.mInPreLayout = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// consume remaining updates to provide a consistent state with the layout pass.</span></span><br><span class="line">            mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">            mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        mAdapterUpdateDuringMeasure = <span class="keyword">false</span>;</span><br><span class="line">        stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mState.mRunPredictiveAnimations) {</span><br><span class="line">        <span class="comment">// If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span></span><br><span class="line">        <span class="comment">// this means there is already an onMeasure() call performed to handle the pending</span></span><br><span class="line">        <span class="comment">// adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span></span><br><span class="line">        <span class="comment">// with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span></span><br><span class="line">        <span class="comment">// because getViewForPosition() will crash when LM uses a child to measure.</span></span><br><span class="line">        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) {</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mState.mItemCount = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>; <span class="comment">// clear</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要做了两件事，最终都会调用<code>LayoutManager</code>的<code>onMeasure</code>方法进行测量。</p>
<ul>
<li>如果<code>mHasFixedSize</code>为true（也就是调用了<code>setHasFixedSize</code>方法），将直接调用<code>LayoutManager</code>的<code>onMeasure</code>方法进行测量。</li>
<li>如果为false，同时此时如果有数据更新，则先处理数据更新的事务，然后调用<code>LayoutManager</code>的<code>onMeasure</code>方法进行测量。</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();<span class="comment">// 进行layout操作</span></span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;<span class="comment">//赋值为true，即已经layout一次了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们看一下<code>dispatchLayout</code>方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) {</span><br><span class="line">        Log.e(TAG, <span class="string">"No adapter attached; skipping layout"</span>);</span><br><span class="line">        <span class="comment">// leave the state in START</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) {</span><br><span class="line">        Log.e(TAG, <span class="string">"No layout manager attached; skipping layout"</span>);</span><br><span class="line">        <span class="comment">// leave the state in START</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) {</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">            || mLayout.getHeight() != getHeight()) {</span><br><span class="line">        <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">        <span class="comment">// changed size.</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法里，分别判断了<code>mAdapter</code>和<code>mLayout</code>，只要其中一个为null，则直接返回。注意到当<code>mLayout</code>为null时，即RecyclerView没有设置<code>LayoutManager</code>时，<code>dispatchLayout</code>方法直接返回了，因此不会处理layout过程，RecyclerView不会加载数据。</p>
<p>这个方法中保证了RecyclerView必须经历的三个过程，即<code>dispatchLayoutStep1</code>、<code>dispatchLayoutStep2</code>、<code>dispatchLayoutStep3</code>。</p>
<p>前两个已经介绍过，我们来看<code>dispatchLayoutStep3</code>方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它将<code>mState.mLayoutStep</code>重置为了<code>State.STEP_START</code>。就是说下一次重新开始<code>dispatchLayout</code>时，也会经历3个方法。</p>
<p>方法的其他部分主要是做Item的动画，我们不再关注。</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>{</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>RecyclerView的draw流程分为三步：</p>
<ul>
<li>调用<code>super.draw</code>方法。这里主要做两件事：1.将<code>children</code>的绘制分发给<code>ViewGroup</code>。2.将分割线的绘制分发给<code>ItemDecoration</code>。</li>
<li>如果需要的话，调用<code>ItemDecoration</code>的<code>onDrawOver</code>方法。通过这个方法，我们在每个Item上自定义一些装饰。</li>
<li>如果RecyclerView调用了<code>setClipToPadding</code>，会实现一种特殊的滑动效果——每个ItemView可以滑动到padding区域。</li>
</ul>
<h2 id="复用及缓存机制"><a href="#复用及缓存机制" class="headerlink" title="复用及缓存机制"></a>复用及缓存机制</h2><p>RecyclerView在大量数据时依然可以丝滑般顺畅的滑动，这得益于它优秀的缓存机制。</p>
<p>我们知道，RecyclerView本身是一个ViewGroup，因此在滑动时就避免不了添加或移除子View(子View通过RecyclerView#Adapter中的onCreateViewHolder创建)，如果每次使用子View都要去重新创建，肯定会影响滑动的流畅性，所以RecyclerView通过Recycler来缓存的是ViewHolder(内部包含子View)，这样在滑动时可以复用子View，某些条件下还可以复用子View绑定的数据。所以本质上来说，RecyclerView之所以能够实现顺畅的滑动效果，是因为缓存机制，因为缓存减少了重复绘制View和绑定数据的时间，从而提高了滑动时的性能。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="四级缓存"><a href="#四级缓存" class="headerlink" title="四级缓存"></a>四级缓存</h4><p>Recycler缓存ViewHolder对象有4个等级，优先级从高到底依次为：</p>
<ul>
<li>mAttachedScrap：缓存屏幕中可见范围的ViewHolder；</li>
<li>mCachedViews：缓存滑动时即将与RecyclerView分离的ViewHolder，默认最大2个；</li>
<li>ViewCacheExtension：自定义实现的缓存；</li>
<li>RecycledViewPool ：ViewHolder缓存池，可以支持不同的ViewType；</li>
</ul>
<h5 id="1-1-mAttachedScrap"><a href="#1-1-mAttachedScrap" class="headerlink" title="1.1 mAttachedScrap"></a>1.1 mAttachedScrap</h5><p>mAttachedScrap存储的是当前屏幕中的ViewHolder，mAttachedScrap的对应数据结构是ArrayList，在调用LayoutManager#onLayoutChildren方法时对views进行布局，此时会将RecyclerView上的Views全部暂存到该集合中，该缓存中的ViewHolder的特性是，如果和RV上的position或者itemId匹配上了那么可以直接拿来使用的，无需调用onBindViewHolder方法。</p>
<h5 id="1-2-mChangedScrap"><a href="#1-2-mChangedScrap" class="headerlink" title="1.2 mChangedScrap"></a>1.2 mChangedScrap</h5><p>mChangedScrap和mAttachedScrap属于同一级别的缓存，不过mChangedScrap的调用场景是notifyItemChanged和notifyItemRangeChanged，只有发生变化的ViewHolder才会放入到mChangedScrap中。mChangedScrap缓存中的ViewHolder是需要调用onBindViewHolder方法重新绑定数据的。</p>
<h5 id="2-mCachedViews"><a href="#2-mCachedViews" class="headerlink" title="2.mCachedViews"></a>2.mCachedViews</h5><p>mCachedViews缓存滑动时即将与RecyclerView分离的ViewHolder，按子View的position或id缓存，默认最多存放2个。mCachedViews对应的数据结构是ArrayList，但是该缓存对集合的大小是有限制的。</p>
<p>该缓存中ViewHolder的特性和mAttachedScrap中的特性是一样的，只要position或者itemId对应就无需重新绑定数据。开发者可以调用setItemViewCacheSize(size)方法来改变缓存的大小，该层级缓存触发的一个常见的场景是滑动RecyclerView。当然调用notify()也会触发该缓存。</p>
<h5 id="3-ViewCacheExtension"><a href="#3-ViewCacheExtension" class="headerlink" title="3.ViewCacheExtension"></a>3.ViewCacheExtension</h5><p>ViewCacheExtension是需要开发者自己实现的缓存，基本上页面上的所有数据都可以通过它进行实现。</p>
<h5 id="4-RecyclerViewPool"><a href="#4-RecyclerViewPool" class="headerlink" title="4. RecyclerViewPool"></a>4. RecyclerViewPool</h5><p>ViewHolder缓存池，本质上是一个SparseArray，其中key是ViewType(int类型)，value存放的是 ArrayList&lt; ViewHolder&gt;，默认每个ArrayList中最多存放5个ViewHolder。</p>
<h5 id="四级缓存对比"><a href="#四级缓存对比" class="headerlink" title="四级缓存对比"></a>四级缓存对比</h5><p><img src="https://s3.bmp.ovh/imgs/2022/03/236dfef4f726bf48.png"></p>
<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>RecyclerView滑动时会触发onTouchEvent#onMove，回收及复用ViewHolder在这里就会开始。我们知道设置RecyclerView时需要设置LayoutManager,LayoutManager负责RecyclerView的布局，包含对ItemView的获取与复用。以LinearLayoutManager为例，当RecyclerView重新布局时会依次执行下面几个方法：</p>
<ul>
<li>onLayoutChildren()：对RecyclerView进行布局的入口方法</li>
<li>fill(): 负责对剩余空间不断地填充，调用的方法是layoutChunk()</li>
<li>layoutChunk()：负责填充View,该View最终是通过在缓存类Recycler中找到合适的View的</li>
</ul>
<p>上述的整个调用链：onLayoutChildren()-&gt;fill()-&gt;layoutChunk()-&gt;next()-&gt;getViewForPosition()。getViewForPosition()即是是从RecyclerView的回收机制实现类Recycler中获取合适的View。</p>
<h3 id="复用过程"><a href="#复用过程" class="headerlink" title="复用过程"></a>复用过程</h3><p>RecyclerView对ViewHolder的复用是从LayoutState的next()方法开始的。LayoutManager在布局itemView时，需要获取一个ViewHolder对象，如下所示。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>{</span><br><span class="line">     <span class="keyword">if</span> (mScrapList != <span class="keyword">null</span>) {</span><br><span class="line">         <span class="keyword">return</span> nextViewFromScrapList();</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">            mCurrentPosition += mItemDirection;</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>

<p>next方法调用RecyclerView的getViewForPosition方法来获取一个View，而getViewForPosition方法最终会调用到RecyclerView的tryGetViewHolderForPositionByDeadline方法，而RecyclerView真正复用的核心就在这里。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>{</span><br><span class="line">        ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 0) 如果它是改变的废弃的ViewHolder，在scrap的mChangedScrap找</span></span><br><span class="line">        <span class="keyword">if</span> (mState.isPreLayout()) {</span><br><span class="line">            holder = getChangedScrapViewForPosition(position);</span><br><span class="line">            fromScrapOrHiddenOrCache = holder != <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1)根据position分别在scrap的mAttachedScrap、mChildHelper、mCachedViews中查找</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) {</span><br><span class="line">            holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">            <span class="comment">// 2)根据id在scrap的mAttachedScrap、mCachedViews中查找</span></span><br><span class="line">            <span class="keyword">if</span> (mAdapter.hasStableIds()) {</span><br><span class="line">                holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">//3)在ViewCacheExtension中查找，一般不用到，所以没有缓存</span></span><br><span class="line">                <span class="keyword">final</span> View view = mViewCacheExtension</span><br><span class="line">                        .getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">                    holder = getChildViewHolder(view);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//4)在RecycledViewPool中查找</span></span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) {</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) {</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//5)到最后如果还没有找到复用的ViewHolder，则新建一个</span></span><br><span class="line">        holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，tryGetViewHolderForPositionByDeadline()方法分别去scrap、CacheView、ViewCacheExtension、RecycledViewPool中获取ViewHolder，如果没有则创建一个新的ViewHolder。</p>
<h4 id="1-getChangedScrapViewForPosition"><a href="#1-getChangedScrapViewForPosition" class="headerlink" title="1.getChangedScrapViewForPosition"></a>1.getChangedScrapViewForPosition</h4><p>一般情况下，当我们调用adapter的notifyItemChanged()方法，数据发生变化时，item缓存在mChangedScrap中，后续拿到的ViewHolder需要重新绑定数据。此时查找ViewHolder就会通过position和id分别在scrap的mChangedScrap中查找。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">getChangedScrapViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{</span><br><span class="line">     <span class="comment">//通过position</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; changedScrapSize; i++) {</span><br><span class="line">         <span class="keyword">final</span> ViewHolder holder = mChangedScrap.get(i);</span><br><span class="line">         <span class="keyword">return</span> holder;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 通过id</span></span><br><span class="line">     <span class="keyword">if</span> (mAdapter.hasStableIds()) {</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> id = mAdapter.getItemId(offsetPosition);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; changedScrapSize; i++) {</span><br><span class="line">             <span class="keyword">final</span> ViewHolder holder = mChangedScrap.get(i);</span><br><span class="line">             <span class="keyword">return</span> holder;</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-getScrapOrHiddenOrCachedHolderForPosition"><a href="#2-getScrapOrHiddenOrCachedHolderForPosition" class="headerlink" title="2.getScrapOrHiddenOrCachedHolderForPosition"></a>2.getScrapOrHiddenOrCachedHolderForPosition</h4><p>如果没有找到视图，根据position分别在scrap的mAttachedScrap、mChildHelper、mCachedViews中查找，涉及的方法如下。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">getScrapOrHiddenOrCachedHolderForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrapCount = mAttachedScrap.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先从mAttachedScrap中查找，精准匹配有效的ViewHolder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scrapCount; i++) {</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//接着在mChildHelper中mHiddenViews查找隐藏的ViewHolder</span></span><br><span class="line">        <span class="keyword">if</span> (!dryRun) {</span><br><span class="line">            View view = mChildHelper.findHiddenNonRemovedView(position);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> ViewHolder vh = getChildViewHolderInt(view);</span><br><span class="line">                scrapView(view);</span><br><span class="line">                <span class="keyword">return</span> vh;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//最后从我们的一级缓存中mCachedViews查找。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = mCachedViews.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheSize; i++) {</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = mCachedViews.get(i);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，getScrapOrHiddenOrCachedHolderForPosition查找ViewHolder的顺序如下：</p>
<ul>
<li>首先，从mAttachedScrap中查找，精准匹配有效的ViewHolder；</li>
<li>接着，在mChildHelper中mHiddenViews查找隐藏的ViewHolder；</li>
<li>最后，从一级缓存中mCachedViews查找。</li>
</ul>
<h4 id="3-getScrapOrCachedViewForId"><a href="#3-getScrapOrCachedViewForId" class="headerlink" title="3.getScrapOrCachedViewForId"></a>3.getScrapOrCachedViewForId</h4><p>通过id在scrap的mAttachedScrap、mCachedViews中查找。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">getScrapOrCachedViewForId</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">int</span> type, <span class="keyword">boolean</span> dryRun)</span> </span>{</span><br><span class="line">        <span class="comment">//在Scrap的mAttachedScrap中查找</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = mAttachedScrap.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在一级缓存mCachedViews中查找</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = mCachedViews.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cacheSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = mCachedViews.get(i);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        }</span><br><span class="line">    }        </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>getScrapOrCachedViewForId()方法查找的顺序如下：</p>
<ul>
<li>首先， 从mAttachedScrap中查找，精准匹配有效的ViewHolder；</li>
<li>接着， 从一级缓存中mCachedViews查找；</li>
</ul>
<h4 id="4-mViewCacheExtension"><a href="#4-mViewCacheExtension" class="headerlink" title="4.mViewCacheExtension"></a>4.mViewCacheExtension</h4><p>mViewCacheExtension是由开发者定义的一层缓存策略，Recycler并没有将任何view缓存到这里。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">            holder = getChildViewHolder(view);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>如果这里没有自定义缓存策略，那么就找不到对应的view。</p>
<h4 id="5-RecycledViewPool"><a href="#5-RecycledViewPool" class="headerlink" title="5.RecycledViewPool"></a>5.RecycledViewPool</h4><p>它是通过itemType把ViewHolder的List缓存到SparseArray中的，在getRecycledViewPool().getRecycledView(type)根据itemType从SparseArray获取ScrapData ，然后再从里面获取ArrayList&lt;ViewHolder&gt;，从而获取到ViewHolder。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">getRecycledView</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> ScrapData scrapData = mScrap.get(viewType);<span class="comment">//根据viewType获取对应的ScrapData </span></span><br><span class="line">        <span class="keyword">if</span> (scrapData != <span class="keyword">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) {</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = scrapHeap.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">                <span class="keyword">if</span> (!scrapHeap.get(i).isAttachedToTransitionOverlay()) {</span><br><span class="line">                    <span class="keyword">return</span> scrapHeap.remove(i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-创建新的ViewHolder"><a href="#6-创建新的ViewHolder" class="headerlink" title="6.创建新的ViewHolder"></a>6.创建新的ViewHolder</h4><p>如果还没有获取到ViewHolder，则通过mAdapter.createViewHolder()创建一个新的ViewHolder返回。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果还没有找到复用的ViewHolder，则新建一个</span></span><br><span class="line">holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br></pre></td></tr></tbody></table></figure>

<p>下面是寻找ViewHolder的一个完整的流程图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/f34b1ba8245ac7af.png"></p>
<h3 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h3><p>RecyclerView回收的入口有很多， 但是不管怎么样操作，RecyclerView 的回收或者复用必然涉及到add View 和 remove View 操作， 所以我们从onLayout的流程入手分析回收和复用的机制。</p>
<p>首先，在LinearLayoutManager中，我们来到itemView布局入口的方法onLayoutChildren()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> || mPendingScrollPosition != RecyclerView.NO_POSITION) {</span><br><span class="line">        <span class="keyword">if</span> (state.getItemCount() == <span class="number">0</span>) {</span><br><span class="line">            removeAndRecycleAllViews(recycler);<span class="comment">//移除所有子View</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ensureLayoutState();</span><br><span class="line">    mLayoutState.mRecycle = <span class="keyword">false</span>;<span class="comment">//禁止回收</span></span><br><span class="line">    <span class="comment">//颠倒绘制布局</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line">    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂时分离已经附加的view，即将所有child detach并通过Scrap回收</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在onLayoutChildren()布局的时候，先根据实际情况是否需要removeAndRecycleAllViews()移除所有的子View，哪些ViewHolder不可用；然后通过detachAndScrapAttachedViews()暂时分离已经附加的ItemView，并缓存到List中。</p>
<p>detachAndScrapAttachedViews()的作用就是把当前屏幕所有的item与屏幕分离，将他们从RecyclerView的布局中拿下来，保存到list中，在重新布局时，再将ViewHolder重新一个个放到新的位置上去。</p>
<p>将屏幕上的ViewHolder从RecyclerView的布局中拿下来后，存放在Scrap中，Scrap包括mAttachedScrap和mChangedScrap，它们是一个list，用来保存从RecyclerView布局中拿下来ViewHolder列表，detachAndScrapAttachedViews()只会在onLayoutChildren()中调用，只有在布局的时候，才会把ViewHolder detach掉，然后再add进来重新布局，但是大家需要注意，Scrap只是保存从RecyclerView布局中当前屏幕显示的item的ViewHolder，不参与回收复用，单纯是为了现从RecyclerView中拿下来再重新布局上去。对于没有保存到的item，会放到mCachedViews或者RecycledViewPool缓存中参与回收复用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachAndScrapAttachedViews</span><span class="params">(<span class="meta">@NonNull</span> Recycler recycler)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">final</span> View v = getChildAt(i);</span><br><span class="line">        scrapOrRecycleView(recycler, i, v);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>遍历所有view，分离所有已经添加到RecyclerView的itemView。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scrapOrRecycleView</span><span class="params">(Recycler recycler, <span class="keyword">int</span> index, View view)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(view);</span><br><span class="line">    <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">        &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {</span><br><span class="line">        removeViewAt(index);<span class="comment">//移除VIew</span></span><br><span class="line">        recycler.recycleViewHolderInternal(viewHolder);<span class="comment">//缓存到CacheView或者RecycledViewPool中</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        detachViewAt(index);<span class="comment">//分离View</span></span><br><span class="line">        recycler.scrapView(view);<span class="comment">//scrap缓存</span></span><br><span class="line">        mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>detachViewAt()方法分离视图，再通过scrapView()缓存到scrap中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scrapView</span><span class="params">(View view)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(view);</span><br><span class="line">    <span class="keyword">if</span> (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">        || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {</span><br><span class="line">        holder.setScrapContainer(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        mAttachedScrap.add(holder);<span class="comment">//保存到mAttachedScrap中</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mChangedScrap == <span class="keyword">null</span>) {</span><br><span class="line">            mChangedScrap = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">        }</span><br><span class="line">        holder.setScrapContainer(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        mChangedScrap.add(holder);<span class="comment">//保存到mChangedScrap中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>回到scrapOrRecycleView()方法中，进入if()分支。如果viewHolder是无效、未被移除、未被标记的则放到recycleViewHolderInternal()缓存起来，同时removeViewAt()移除了viewHolder。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> </span>{</span><br><span class="line">    ·····</span><br><span class="line">        <span class="keyword">if</span> (forceRecycle || holder.isRecyclable()) {</span><br><span class="line">            <span class="keyword">if</span> (mViewCacheMax &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">                                            | ViewHolder.FLAG_REMOVED</span><br><span class="line">                                            | ViewHolder.FLAG_UPDATE</span><br><span class="line">                                            | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> cachedViewSize = mCachedViews.size();</span><br><span class="line">                <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) {<span class="comment">//如果超出容量限制，把第一个移除</span></span><br><span class="line">                    recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                    cachedViewSize--;</span><br><span class="line">                }</span><br><span class="line">                ·····</span><br><span class="line">                    mCachedViews.add(targetCacheIndex, holder);<span class="comment">//mCachedViews回收</span></span><br><span class="line">                cached = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!cached) {</span><br><span class="line">                addViewHolderToRecycledViewPool(holder, <span class="keyword">true</span>);<span class="comment">//放到RecycledViewPool回收</span></span><br><span class="line">                recycled = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如果符合条件，会优先缓存到mCachedViews中时，如果超出了mCachedViews的最大限制，通过recycleCachedViewAt()将CacheView缓存的第一个数据添加到终极回收池RecycledViewPool后再移除掉，最后才会add()新的ViewHolder添加到mCachedViews中。</p>
<p>剩下不符合条件的则通过addViewHolderToRecycledViewPool()缓存到RecycledViewPool中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addViewHolderToRecycledViewPool</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="keyword">boolean</span> dispatchRecycled)</span> </span>{</span><br><span class="line">    clearNestedRecyclerViewIfNotNested(holder);</span><br><span class="line">    View itemView = holder.itemView;</span><br><span class="line">    ······</span><br><span class="line">        holder.mOwnerRecyclerView = <span class="keyword">null</span>;</span><br><span class="line">    getRecycledViewPool().putRecycledView(holder);<span class="comment">//将holder添加到RecycledViewPool中</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在填充布局调用fill()方法的时候，它会回收移出屏幕的view到mCachedViews或者RecycledViewPool中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="function"><span class="params">         RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {</span><br><span class="line">        recycleByLayoutState(recycler, layoutState);<span class="comment">//回收移出屏幕的view</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>而recycleByLayoutState()方法就是用来回收移出屏幕的view。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/7ada7b2f7e079a2c.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">liuyuxin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://liuyuxin-cloud.github.io/2021/12/09/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://liuyuxin-cloud.github.io/2021/12/09/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liuyuxin-cloud.github.io" target="_blank">liuyuxin'blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2021/12/10/oIT8Q1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/17/jetpack-Room%E7%9A%84%E4%BD%BF%E7%94%A8/"><img class="prev-cover" src="https://ftp.bmp.ovh/imgs/2021/07/89a02846d44ac7a7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jetpack Room的使用</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/25/java%E6%B3%9B%E5%9E%8B/"><img class="next-cover" src="https://i.bmp.ovh/imgs/2021/11/4e1dce1eaf4d030f.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java泛型</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">RecyclerView源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">关键类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">类定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">绘制过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#onMeasure"><span class="toc-number">1.3.1.</span> <span class="toc-text">onMeasure</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">情况一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">情况二</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#onLayoutChildren"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">onLayoutChildren</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E9%94%9A%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.1.2.1.1.</span> <span class="toc-text">确定锚点信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">情况三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onLayout"><span class="toc-number">1.3.2.</span> <span class="toc-text">onLayout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onDraw"><span class="toc-number">1.3.3.</span> <span class="toc-text">onDraw</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">复用及缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">四级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-mAttachedScrap"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">1.1 mAttachedScrap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-mChangedScrap"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">1.2 mChangedScrap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-mCachedViews"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">2.mCachedViews</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ViewCacheExtension"><span class="toc-number">1.4.1.1.4.</span> <span class="toc-text">3.ViewCacheExtension</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-RecyclerViewPool"><span class="toc-number">1.4.1.1.5.</span> <span class="toc-text">4. RecyclerViewPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.1.1.6.</span> <span class="toc-text">四级缓存对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">调用过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">复用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-getChangedScrapViewForPosition"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1.getChangedScrapViewForPosition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-getScrapOrHiddenOrCachedHolderForPosition"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2.getScrapOrHiddenOrCachedHolderForPosition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-getScrapOrCachedViewForId"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.getScrapOrCachedViewForId</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-mViewCacheExtension"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.mViewCacheExtension</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-RecycledViewPool"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">5.RecycledViewPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84ViewHolder"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">6.创建新的ViewHolder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">回收流程</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/index.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By liuyuxin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>