<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RecyclerView源码解析</title>
      <link href="/2021/12/09/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/12/09/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h1><p>RecyclerView 可以让您轻松高效地显示大量数据。您提供数据并定义每个列表项的外观，而 RecyclerView 库会根据需要动态创建元素。</p><p>顾名思义，RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改善应用响应能力并降低功耗。</p><p>详细使用方法请参照<a href="https://developer.android.com/guide/topics/ui/layout/recyclerview">开发者文档</a><span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>   </p><h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">ScrollingView</span>,</span></span><br><span class="line"><span class="class">        <span class="title">NestedScrollingChild2</span>, <span class="title">NestedScrollingChild3</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>可以看出<code>RecyclerView</code>继承于<code>ViewGroup</code>，本身也是一个自定义View，实现了<code>ScrollingView</code>等接口。</p><h2 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h2><p>本质上是自定义View，则有onMeasure、onLayout、onDraw三步绘制过程。</p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>自定义View的onMeausre 的具体逻辑，在这里，依然可以做个参考：</p><ol><li>super.onMeasure 会先计算自定义 view 的大小；</li><li>调用 measureChild 对子 View 进行测量；</li><li>自定义 view 设置的宽高参数不是 MeasureSpec.EXACTLY 的话，对于子 View 是 match_parent 需要额外处理，同时也需要对 MeasureSpec.AT_MOST 情况进行额外处理。</li><li> 当自定义View 的大小确定后，在对子 View 是 match_parent 重新测量；</li></ol><p>在RecyclerView的onMeasure中有三种情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 情况1</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mLayout.mAutoMeasure) {</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 情况3</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ol><li><code>mLayout==null</code>  <code>mLayout </code>即 <code>LayoutManager </code>的对象。我们知道，当 <code>RecyclerView </code>的 <code>LayoutManager </code>为空时，<code>RecyclerView </code>不能显示任何的数据，在这里我们找到答案。</li><li><code>LayoutManager </code>开启了自动测量时，这是一种情况。在这种情况下，有可能会测量两次。</li><li>第三种情况就是没有开启自动测量的情况，这种情况比较少，因为 <code>RecyclerView </code>为了支持 <code>warp_content </code>属性，系统提供的 <code>LayoutManager </code>都开启自动测量的，不过还是要分析的。</li></ol><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) {</span><br><span class="line">    defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里调用了<code>defaultOnMeasure</code>方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An implementation of {<span class="doctag">@link</span> View#onMeasure(int, int)} to fall back to in various scenarios</span></span><br><span class="line"><span class="comment"> * where this RecyclerView is otherwise lacking better information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultOnMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>{</span><br><span class="line">    <span class="comment">// calling LayoutManager here is not pretty but that API is already public and it is better</span></span><br><span class="line">    <span class="comment">// than creating another method since this is internal.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = LayoutManager.chooseSize(widthSpec,</span><br><span class="line">            getPaddingLeft() + getPaddingRight(),</span><br><span class="line">            ViewCompat.getMinimumWidth(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = LayoutManager.chooseSize(heightSpec,</span><br><span class="line">            getPaddingTop() + getPaddingBottom(),</span><br><span class="line">            ViewCompat.getMinimumHeight(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该方法中通过<code>LayoutManager.choose()</code>方法来计算宽高值，然后<strong>调用setMeasuredDimension()设置宽高</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chooses a size from the given specs and parameters that is closest to the desired size</span></span><br><span class="line"><span class="comment"> * and also complies with the spec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spec The measureSpec</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desired The preferred measurement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min The minimum value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A size that fits to the given specs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chooseSize</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> desired, <span class="keyword">int</span> min)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mode = View.MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = View.MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="keyword">switch</span> (mode) {</span><br><span class="line">        <span class="keyword">case</span> View.MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        <span class="keyword">case</span> View.MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">return</span> Math.min(size, Math.max(desired, min));</span><br><span class="line">        <span class="keyword">case</span> View.MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> Math.max(desired, min);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>chooseSize方法就是通过RecyclerView的不同测量模式来选取不同的值。这里没有测量子 view 的大小，这也是白屏的原因。因为 RecyclerView 的绘制其实是委托给 LayoutManager 来管理，LayoutManager = null 的情况下测量子 view 没有任何的意义。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) {</span><br><span class="line">    <span class="comment">//先获取测量模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用LayoutManager.onMeasure方法测量</span></span><br><span class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line"><span class="comment">//判断是否可以跳过测量或者adapter为null，直接返回。</span></span><br><span class="line">    <span class="comment">/*自定义 view 设置的宽高参数不是 MeasureSpec.EXACTLY 的话，对于子 View 是 match_parent 需要额外处理。*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly =</span><br><span class="line">            widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">    <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//开始测量</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) {</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span></span><br><span class="line">    <span class="comment">// consistency</span></span><br><span class="line">    mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">    dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">    mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">    <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">    <span class="comment">//第二次</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) {</span><br><span class="line">        mLayout.setMeasureSpecs(</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">        <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况下，首先调用<code>LayoutManager.onMeasure</code>方法测量，但是Android官方的三种LayoutManager(LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutManager)都没有复写此方法，此方法源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(Recycler recycler, State state, <span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>{</span><br><span class="line">    mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是自定义View的onMeasure步骤中的测量自己本身的大小。</p><p>接下来判断<code>mState.mLayoutStep</code>这个变量，即当前绘制状态，如果为<code>State.STEP_START</code>，那么便会执行<code>dispatchLayoutStep1</code>方法，随后又调用了<code>dispatchLayoutStep2</code>方法，最后如果需要二次测量的话，那么会再调用一次<code>dispatchLayoutStep2</code>方法。</p><p>我们先来分别看一下<code>mState.mLayoutStep</code>变量的含义和<code>dispatchLayoutStepX</code>系列方法的作用。</p><p><a href="https://imgtu.com/i/o4M6D1"><img src="https://s1.ax1x.com/2021/12/09/o4M6D1.jpg" alt="o4M6D1.jpg" style="zoom: 50%;"></a></p><p><a href="https://imgtu.com/i/o4MIvd"><img src="https://s1.ax1x.com/2021/12/09/o4MIvd.jpg" alt="o4MIvd.jpg" style="zoom: 50%;"></a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//这里还用到了断言</span></span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    fillRemainingScrollValues(mState);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    <span class="comment">//处理adapter更新</span></span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否要运行动画</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) {</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="comment">// 找出所有未移除的ItemView，进行预布局</span></span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) {</span><br><span class="line">        <span class="comment">// Step 1: run prelayout: This will use the old positions of items. The layout manager</span></span><br><span class="line">        <span class="comment">// is expected to layout everything, even removed items (though not to add removed</span></span><br><span class="line">        <span class="comment">// items back to the container). This gives the pre-layout position of APPEARING views</span></span><br><span class="line">        <span class="comment">// which come into existence as part of the real layout.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save old positions so that LayoutManager can run its mapping logic.</span></span><br><span class="line">        <span class="comment">//保存旧状态进行预布局。</span></span><br><span class="line">        ......</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    }</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//改变状态</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到<code>dispatchLayoutStep1</code>方法主要是根据<code>mState.mRunPredictiveAnimations</code>和<code>mState.mRunPredictiveAnimations</code>两个值做出相应的逻辑处理。而在<code>processAdapterUpdatesAndSetAnimationFlags</code>方法中，计算了这两个值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAdapterUpdatesAndSetAnimationFlags</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    mState.mRunSimpleAnimations = mFirstLayoutComplete</span><br><span class="line">        &amp;&amp; mItemAnimator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (mDataSetHasChangedAfterLayout</span><br><span class="line">            || animationTypeSupported</span><br><span class="line">            || mLayout.mRequestedSimpleAnimations)</span><br><span class="line">        &amp;&amp; (!mDataSetHasChangedAfterLayout</span><br><span class="line">            || mAdapter.hasStableIds());</span><br><span class="line">    mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations</span><br><span class="line">        &amp;&amp; animationTypeSupported</span><br><span class="line">        &amp;&amp; !mDataSetHasChangedAfterLayout</span><br><span class="line">        &amp;&amp; predictiveItemAnimationsEnabled();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们关注一下<code>mFirstLayoutComplete</code>变量，我们发现<code>mRunSimpleAnimations</code>的值与<code>mFirstLayoutComplete</code>有关，<code>mRunPredictiveAnimations</code>同时跟<code>mRunSimpleAnimations</code>有关。第一次绘制流程还未完成，<code>mFirstLayoutComplete==false</code>所以<code>mRunSimpleAnimations = mRunPredictiveAnimations == false</code>，当RecyclerView第一次加载数据时，是不会执行动画的。每个ItemView还没有layout完毕，是不会进行动画的。</p><p>接下来，我们看dispatchLayoutStep2方法，其中，对RecyclerView的子View进行了Layout：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>{</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//改变状态</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1、2处可以看到，对children进行了测量和布局。</p><p><code>LayoutManager</code>的<code>onLayoutChildren</code>方法是一个空方法，所以需要<code>LayoutManager</code>的子类自己实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> </span>{</span><br><span class="line">    Log.e(TAG, <span class="string">"You must override onLayoutChildren(Recycler recycler, State state) "</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="onLayoutChildren"><a href="#onLayoutChildren" class="headerlink" title="onLayoutChildren"></a>onLayoutChildren</h5><p>RecyclerView将View的绘制交给了LayoutManager。将RecyclerView内部持有的<code>Recycler</code>和<code>state</code>传给了<code>LayoutManager</code>的<code>onLayoutChildren</code>方法。这里我们分析<code>LinearLayoutManager</code>。</p><p>大概流程：</p><ul><li>确定锚点信息，包括：1.<code>Children</code>的布局方向，有start和end两个方向。2.<code>mPosition</code>和<code>mCoordinate</code>，分别表示<code>Children</code>开始填充的position和坐标。</li><li>调用<code>detachAndScrapAttachedViews</code>方法，<code>detach</code>掉或者<code>remove</code>掉<code>RecyclerView</code>的<code>Children</code>。（与缓存机制相关）</li><li>根据锚点信息，调用<code>fill</code>方法进行<code>Children</code>的填充。根据锚点信息的不同，可能会调用两次<code>fill</code>方法。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>{</span><br><span class="line">    <span class="comment">// 第一步找寻锚点</span></span><br><span class="line">    <span class="comment">// 两个方向填充，从锚点往上和锚点往下</span></span><br><span class="line">    <span class="comment">// 判断绘制方向，给mShouldReverseLayout赋值，默认是正向绘制，则mShouldReverseLayout是False</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// resolve layout direction</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">    <span class="comment">// mValid 的默认值是false，一次测量之后设为true，onLayout 完成后会回调执行reset方法，又变为false</span></span><br><span class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">            || mPendingSavedState != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// mStackFromEnd默认是false，除非手动调用setStackFromEnd方法，两个都会false，异或为false</span></span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">        <span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">        <span class="comment">// 计算锚点位置和偏移量。</span></span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                    &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">            || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">            &lt;= mOrientationHelper.getStartAfterPadding())) {</span><br><span class="line">        </span><br><span class="line">        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//第二步</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    mLayoutState.mInfinite = resolveIsInfinite();</span><br><span class="line">    mLayoutState.mIsPreLayout = state.isPreLayout();</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//mLayoutFromEnd为false    </span></span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) {</span><br><span class="line">        <span class="comment">// 第三步</span></span><br><span class="line">        <span class="comment">// 倒着绘制的话，先往上绘制，再往下绘制</span></span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        <span class="comment">// 从锚点到往上</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        ...</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        <span class="comment">// 从锚点到往下</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//调两遍fill方法    </span></span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">...</span><br><span class="line">            updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        <span class="comment">// 正常绘制流程的话，先往下绘制，再往上绘制</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">...</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// start could not consume all it should. add more items towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">...</span><br><span class="line">    fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">    <span class="comment">//完成后重置参数</span></span><br><span class="line">    <span class="keyword">if</span> (!state.isPreLayout()) {</span><br><span class="line">        mOrientationHelper.onLayoutComplete();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">    }</span><br><span class="line">    mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="确定锚点信息"><a href="#确定锚点信息" class="headerlink" title="确定锚点信息"></a>确定锚点信息</h6><p>首先执行<code>resolveShouldLayoutReverse</code>方法判断是否需要倒着绘制：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolveShouldLayoutReverse</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// A == B is the same result, but we rather keep it readable</span></span><br><span class="line">    <span class="comment">//默认情况下，`mReverseLayout`为false，是不会倒着绘制的。手动调用`setReverseLayout`方法可以改变`mRverseLayout`的值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL || !isLayoutRTL()) {</span><br><span class="line">        mShouldReverseLayout = mReverseLayout;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mShouldReverseLayout = !mReverseLayout;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下通过<code>updateAnchorInfoForLayout</code>方法来计算锚点信息。</p><p>锚点：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnchorInfo</span> </span>{</span><br><span class="line">    OrientationHelper mOrientationHelper;</span><br><span class="line">    <span class="keyword">int</span> mPosition;<span class="comment">//position</span></span><br><span class="line">    <span class="keyword">int</span> mCoordinate;  <span class="comment">//坐标</span></span><br><span class="line">    <span class="keyword">boolean</span> mLayoutFromEnd;<span class="comment">//mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd</span></span><br><span class="line">    <span class="keyword">boolean</span> mValid;  <span class="comment">//默认false，一次测量后设为true，onLayout后回调reset，重置为false</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAnchorInfoForLayout</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnchorInfo anchorInfo)</span> </span>{</span><br><span class="line">    <span class="comment">//第一种计算方法</span></span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromPendingData(state, anchorInfo)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//第二种计算方法</span></span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromChildren(recycler, state, anchorInfo)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//第三种计算方法</span></span><br><span class="line">    anchorInfo.assignCoordinateFromPadding();</span><br><span class="line">    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第一种：1.RecyclerView被重建，期间调用了<code>onSaveInstanceState</code>方法，目的是为了恢复上次的布局。2.RecyclerView调用了<code>scrollToPosition</code>之类的方法，目的是让RecyclerView滚到准确的位置上去。</li><li>第二种：根据子View来更新锚点信息，如果一个子View有焦点，则根据其来计算锚点信息；如果没有焦点，则根据布局方向选取可见的第一个ItemView或最后一个ItemView</li><li>第三种：前两种都未采用。</li></ul><h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (mHasFixedSize<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>{</span><br><span class="line">        <span class="comment">// layout algorithm:</span></span><br><span class="line">        <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></span><br><span class="line">        <span class="comment">//  item position.</span></span><br><span class="line">        <span class="comment">// 2) fill towards start, stacking from bottom</span></span><br><span class="line">        <span class="comment">// 3) fill towards end, stacking from top</span></span><br><span class="line">        <span class="comment">// 4) scroll to fulfill requirements like stack from bottom.</span></span><br><span class="line">        <span class="comment">// create layout state</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) {</span><br><span class="line">            Log.d(TAG, <span class="string">"is pre layout:"</span> + state.isPreLayout());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> || mPendingScrollPosition != RecyclerView.NO_POSITION) {</span><br><span class="line">            <span class="keyword">if</span> (state.getItemCount() == <span class="number">0</span>) {</span><br><span class="line">                removeAndRecycleAllViews(recycler);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> &amp;&amp; mPendingSavedState.hasValidAnchor()) {</span><br><span class="line">            mPendingScrollPosition = mPendingSavedState.mAnchorPosition;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ensureLayoutState();</span><br><span class="line">        mLayoutState.mRecycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// resolve layout direction</span></span><br><span class="line">        resolveShouldLayoutReverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">        <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">                || mPendingSavedState != <span class="keyword">null</span>) {</span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">            <span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">            mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                        &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">                &lt;= mOrientationHelper.getStartAfterPadding())) {</span><br><span class="line">            <span class="comment">// This case relates to when the anchor child is the focused view and due to layout</span></span><br><span class="line">            <span class="comment">// shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows</span></span><br><span class="line">            <span class="comment">// up after tapping an EditText which shrinks RV causing the focused view (The tapped</span></span><br><span class="line">            <span class="comment">// EditText which is the anchor child) to get kicked out of the screen. Will update the</span></span><br><span class="line">            <span class="comment">// anchor coordinate in order to make sure that the focused view is laid out. Otherwise,</span></span><br><span class="line">            <span class="comment">// the available space in layoutState will be calculated as negative preventing the</span></span><br><span class="line">            <span class="comment">// focused view from being laid out in fill.</span></span><br><span class="line">            <span class="comment">// Note that we won't update the anchor position between layout passes (refer to</span></span><br><span class="line">            <span class="comment">// TestResizingRelayoutWithAutoMeasure), which happens if we were to call</span></span><br><span class="line">            <span class="comment">// updateAnchorInfoForLayout for an anchor that's not the focused view (e.g. a reference</span></span><br><span class="line">            <span class="comment">// child which can change between layout passes).</span></span><br><span class="line">            mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) {</span><br><span class="line">            Log.d(TAG, <span class="string">"Anchor info:"</span> + mAnchorInfo);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LLM may decide to layout items for "extra" pixels to account for scrolling target,</span></span><br><span class="line">        <span class="comment">// caching or predictive animations.</span></span><br><span class="line"></span><br><span class="line">        mLayoutState.mLayoutDirection = mLayoutState.mLastScrollDelta &gt;= <span class="number">0</span></span><br><span class="line">                ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">        mReusableIntPair[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        mReusableIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        calculateExtraLayoutSpace(state, mReusableIntPair);</span><br><span class="line">        <span class="keyword">int</span> extraForStart = Math.max(<span class="number">0</span>, mReusableIntPair[<span class="number">0</span>])</span><br><span class="line">                + mOrientationHelper.getStartAfterPadding();</span><br><span class="line">        <span class="keyword">int</span> extraForEnd = Math.max(<span class="number">0</span>, mReusableIntPair[<span class="number">1</span>])</span><br><span class="line">                + mOrientationHelper.getEndPadding();</span><br><span class="line">        <span class="keyword">if</span> (state.isPreLayout() &amp;&amp; mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">                &amp;&amp; mPendingScrollPositionOffset != INVALID_OFFSET) {</span><br><span class="line">            <span class="comment">// if the child is visible and we are going to move it around, we should layout</span></span><br><span class="line">            <span class="comment">// extra items in the opposite direction to make sure new items animate nicely</span></span><br><span class="line">            <span class="comment">// instead of just fading in</span></span><br><span class="line">            <span class="keyword">final</span> View existing = findViewByPosition(mPendingScrollPosition);</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> current;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> upcomingOffset;</span><br><span class="line">                <span class="keyword">if</span> (mShouldReverseLayout) {</span><br><span class="line">                    current = mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                            - mOrientationHelper.getDecoratedEnd(existing);</span><br><span class="line">                    upcomingOffset = current - mPendingScrollPositionOffset;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    current = mOrientationHelper.getDecoratedStart(existing)</span><br><span class="line">                            - mOrientationHelper.getStartAfterPadding();</span><br><span class="line">                    upcomingOffset = mPendingScrollPositionOffset - current;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (upcomingOffset &gt; <span class="number">0</span>) {</span><br><span class="line">                    extraForStart += upcomingOffset;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    extraForEnd -= upcomingOffset;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> startOffset;</span><br><span class="line">        <span class="keyword">int</span> endOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstLayoutDirection;</span><br><span class="line">        <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) {</span><br><span class="line">            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL</span><br><span class="line">                    : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">                    : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">        detachAndScrapAttachedViews(recycler);</span><br><span class="line">        mLayoutState.mInfinite = resolveIsInfinite();</span><br><span class="line">        mLayoutState.mIsPreLayout = state.isPreLayout();</span><br><span class="line">        <span class="comment">// noRecycleSpace not needed: recycling doesn't happen in below's fill</span></span><br><span class="line">        <span class="comment">// invocations because mScrollingOffset is set to SCROLLING_OFFSET_NaN</span></span><br><span class="line">        mLayoutState.mNoRecycleSpace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) {</span><br><span class="line">            <span class="comment">// fill towards start</span></span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> firstElement = mLayoutState.mCurrentPosition;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                extraForEnd += mLayoutState.mAvailable;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// fill towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForEnd;</span><br><span class="line">            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">                extraForStart = mLayoutState.mAvailable;</span><br><span class="line">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">                mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset = mLayoutState.mOffset;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// fill towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForEnd;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                extraForStart += mLayoutState.mAvailable;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// fill towards start</span></span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) {</span><br><span class="line">                extraForEnd = mLayoutState.mAvailable;</span><br><span class="line">                <span class="comment">// start could not consume all it should. add more items towards end</span></span><br><span class="line">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">                mLayoutState.mExtraFillSpace = extraForEnd;</span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">                endOffset = mLayoutState.mOffset;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// changes may cause gaps on the UI, try to fix them.</span></span><br><span class="line">        <span class="comment">// TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have</span></span><br><span class="line">        <span class="comment">// changed</span></span><br><span class="line">        <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// because layout from end may be changed by scroll to position</span></span><br><span class="line">            <span class="comment">// we re-calculate it.</span></span><br><span class="line">            <span class="comment">// find which side we should check for gaps.</span></span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout ^ mStackFromEnd) {</span><br><span class="line">                <span class="keyword">int</span> fixOffset = fixLayoutEndGap(endOffset, recycler, state, <span class="keyword">true</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">                fixOffset = fixLayoutStartGap(startOffset, recycler, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">int</span> fixOffset = fixLayoutStartGap(startOffset, recycler, state, <span class="keyword">true</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">                fixOffset = fixLayoutEndGap(endOffset, recycler, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset += fixOffset;</span><br><span class="line">                endOffset += fixOffset;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">        <span class="keyword">if</span> (!state.isPreLayout()) {</span><br><span class="line">            mOrientationHelper.onLayoutComplete();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">        }</span><br><span class="line">        mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) {</span><br><span class="line">            validateChildOrder();</span><br><span class="line">        }</span><br><span class="line">    }) {</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// custom onMeasure</span></span><br><span class="line">    <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) {</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mState.mRunPredictiveAnimations) {</span><br><span class="line">            mState.mInPreLayout = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// consume remaining updates to provide a consistent state with the layout pass.</span></span><br><span class="line">            mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">            mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        mAdapterUpdateDuringMeasure = <span class="keyword">false</span>;</span><br><span class="line">        stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mState.mRunPredictiveAnimations) {</span><br><span class="line">        <span class="comment">// If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span></span><br><span class="line">        <span class="comment">// this means there is already an onMeasure() call performed to handle the pending</span></span><br><span class="line">        <span class="comment">// adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span></span><br><span class="line">        <span class="comment">// with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span></span><br><span class="line">        <span class="comment">// because getViewForPosition() will crash when LM uses a child to measure.</span></span><br><span class="line">        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) {</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mState.mItemCount = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>; <span class="comment">// clear</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里主要做了两件事，最终都会调用<code>LayoutManager</code>的<code>onMeasure</code>方法进行测量。</p><ul><li>如果<code>mHasFixedSize</code>为true（也就是调用了<code>setHasFixedSize</code>方法），将直接调用<code>LayoutManager</code>的<code>onMeasure</code>方法进行测量。</li><li>如果为false，同时此时如果有数据更新，则先处理数据更新的事务，然后调用<code>LayoutManager</code>的<code>onMeasure</code>方法进行测量。</li></ul><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();<span class="comment">// 进行layout操作</span></span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;<span class="comment">//赋值为true，即已经layout一次了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们看一下<code>dispatchLayout</code>方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) {</span><br><span class="line">        Log.e(TAG, <span class="string">"No adapter attached; skipping layout"</span>);</span><br><span class="line">        <span class="comment">// leave the state in START</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) {</span><br><span class="line">        Log.e(TAG, <span class="string">"No layout manager attached; skipping layout"</span>);</span><br><span class="line">        <span class="comment">// leave the state in START</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) {</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">            || mLayout.getHeight() != getHeight()) {</span><br><span class="line">        <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">        <span class="comment">// changed size.</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法里，分别判断了<code>mAdapter</code>和<code>mLayout</code>，只要其中一个为null，则直接返回。注意到当<code>mLayout</code>为null时，即RecyclerView没有设置<code>LayoutManager</code>时，<code>dispatchLayout</code>方法直接返回了，因此不会处理layout过程，RecyclerView不会加载数据。</p><p>这个方法中保证了RecyclerView必须经历的三个过程，即<code>dispatchLayoutStep1</code>、<code>dispatchLayoutStep2</code>、<code>dispatchLayoutStep3</code>。</p><p>前两个已经介绍过，我们来看<code>dispatchLayoutStep3</code>方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它将<code>mState.mLayoutStep</code>重置为了<code>State.STEP_START</code>。就是说下一次重新开始<code>dispatchLayout</code>时，也会经历3个方法。</p><p>方法的其他部分主要是做Item的动画，我们不再关注。</p><h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>{</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>RecyclerView的draw流程分为三步：</p><ul><li>调用<code>super.draw</code>方法。这里主要做两件事：1.将<code>children</code>的绘制分发给<code>ViewGroup</code>。2.将分割线的绘制分发给<code>ItemDecoration</code>。</li><li>如果需要的话，调用<code>ItemDecoration</code>的<code>onDrawOver</code>方法。通过这个方法，我们在每个Item上自定义一些装饰。</li><li>如果RecyclerView调用了<code>setClipToPadding</code>，会实现一种特殊的滑动效果——每个ItemView可以滑动到padding区域。</li></ul><h2 id="复用及缓存机制"><a href="#复用及缓存机制" class="headerlink" title="复用及缓存机制"></a>复用及缓存机制</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2021/11/25/java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/11/25/java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><h2 id="什么是泛型程序设计？"><a href="#什么是泛型程序设计？" class="headerlink" title="什么是泛型程序设计？"></a>什么是泛型程序设计？</h2><p><strong>泛型程序设计</strong>（generic programming）是<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序设计语言</a>的一种风格或<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">范式</a>。泛型允许程序员在<a href="https://zh.wikipedia.org/wiki/%E5%BC%B7%E9%A1%9E%E5%9E%8B%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">强类型程序设计语言</a>中编写代码时使用一些以后才指定的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B">类型</a>，在<a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E4%BE%8B">实例化</a>时作为参数指明这些类型。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。<a href="https://zh.wikipedia.org/wiki/Ada">Ada</a>、<a href="https://zh.wikipedia.org/wiki/Delphi">Delphi</a>、<a href="https://zh.wikipedia.org/wiki/Eiffel">Eiffel</a>、<a href="https://zh.wikipedia.org/wiki/Java">Java</a>、<a href="https://zh.wikipedia.org/wiki/C%E2%99%AF">C#</a>、<a href="https://zh.wikipedia.org/wiki/F">F#</a>、<a href="https://zh.wikipedia.org/wiki/Swift_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)">Swift</a> 和 <a href="https://zh.wikipedia.org/wiki/Visual_Basic_.NET">Visual Basic .NET</a> 称之为泛型（generics）；<a href="https://zh.wikipedia.org/wiki/ML%E8%AF%AD%E8%A8%80">ML</a>、<a href="https://zh.wikipedia.org/wiki/Scala">Scala</a> 和 <a href="https://zh.wikipedia.org/wiki/Haskell">Haskell</a> 称之为<a href="https://zh.wikipedia.org/wiki/%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81">参数多态</a>（parametric polymorphism）；<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a> 和 <a href="https://zh.wikipedia.org/wiki/D%E8%AA%9E%E8%A8%80">D</a>称之为<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF_(C%2B%2B)">模板</a>。具有广泛影响的1994年版的《Design Patterns》一书称之为参数化类型（parameterized type）。</p><h2 id="为什么要使用泛型程序设计？"><a href="#为什么要使用泛型程序设计？" class="headerlink" title="为什么要使用泛型程序设计？"></a>为什么要使用泛型程序设计？</h2><ul><li><p><strong>泛型编程可以实现通用算法</strong></p><p>在有泛型类之前，泛型程序设计是用<strong>继承</strong>实现的。程序员必须使用<code>Object</code>编写使用于多种类型的代码，这很繁琐，也很不安全。</p><p>通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。</p></li><li><p><strong>编译时的强类型检查</strong></p><p>泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">files.add(<span class="string">"..."</span>) <span class="comment">//true</span></span><br><span class="line">files.add(<span class="number">1</span>) <span class="comment">//can't</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>避免了类型转换</strong></p><p>未使用泛型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">String s = (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>使用泛型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">String s = list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="定义简单泛型"><a href="#定义简单泛型" class="headerlink" title="定义简单泛型"></a>定义简单泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><strong>泛型类</strong>就是有一个或多个类型变量的类。</p><p>在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 <code>Object</code> 做类型转换。</p><ul><li>一个类型参数</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>{</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span></span>{</span><br><span class="line">        first = newValue;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span></span>{</span><br><span class="line">        second = newValue;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个类中引入了一个类型变量T，用尖括号&lt;&gt;括起来，放在类名的后面。</p><ul><li>泛型类可以有很多不同类型的变量</li></ul><p>例如我们定义的Pair类，第一个字段和第二个字段可以使用不同类型</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> U second;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><em>常见的做法是类型变量使用大写字母，而且很简短。</em></p><p><em>java库中使用变量E表示集合的元素类型，</em></p><p><em>K和V分别表示表的键和值的类型。</em></p><p><em>T（U、S）表示“任意类型”。</em></p></blockquote><ul><li>泛型类可以类型嵌套</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Pair&lt;String&gt; info = <span class="keyword">new</span> Pair(<span class="string">"Hello"</span>);</span><br><span class="line">        MyMap&lt;Integer, Pair&lt;String&gt;&gt; map = <span class="keyword">new</span> MyMap&lt;&gt;(<span class="number">1</span>, info);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// MyMap{key=1, value=Pair{value=Hello}}</span></span><br></pre></td></tr></tbody></table></figure><p>可以用具体的类型替换类型变量来<strong>实例化</strong>泛型类型。</p><p>如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Pair&lt;Integer&gt; pair = <span class="keyword">new</span> Info&lt;&gt;();</span><br><span class="line">        pair.setFirst(<span class="number">10</span>);</span><br><span class="line">        System.out.println(pair.getFirst());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以把实例化的结果想象成一个普通类。</p><p><strong>泛型类相当于普通类的工厂</strong>。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口也可以声明泛型。</p><p>泛型接口语法形式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Content</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="function">T <span class="title">text</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>泛型接口有两种实现方式：</p><ul><li>实现接口的子类明确声明泛型类型</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsInterfaceDemo01</span> <span class="keyword">implements</span> <span class="title">Content</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericsInterfaceDemo01</span><span class="params">(<span class="keyword">int</span> text)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">text</span><span class="params">()</span> </span>{ <span class="keyword">return</span> text; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        GenericsInterfaceDemo01 demo = <span class="keyword">new</span> GenericsInterfaceDemo01(<span class="number">10</span>);</span><br><span class="line">        System.out.print(demo.text());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></tbody></table></figure><ul><li>实现接口的子类不明确声明泛型类型</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsInterfaceDemo02</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Content</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> T text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericsInterfaceDemo02</span><span class="params">(T text)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">text</span><span class="params">()</span> </span>{ <span class="keyword">return</span> text; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        GenericsInterfaceDemo02&lt;String&gt; gen = <span class="keyword">new</span> GenericsInterfaceDemo02&lt;&gt;(<span class="string">"ABC"</span>);</span><br><span class="line">        System.out.print(gen.text());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// ABC</span></span><br></pre></td></tr></tbody></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>还可以定义带有类型参数的方法。</p><p>泛型方法可以在泛型类或普通类中定义。</p><p><strong>类型变量放在修饰符后面，返回类型前面</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"john"</span>, <span class="string">"Q."</span>, <span class="string">"public"</span>);</span><br><span class="line"><span class="comment">//可以省略&lt;String&gt;类型参数，大多数情况下编译器可以推断。类型推断只对赋值操作有效，其他时候并不起作用。</span></span><br><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"john"</span>, <span class="string">"Q."</span>, <span class="string">"public"</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="变量类型的限定"><a href="#变量类型的限定" class="headerlink" title="变量类型的限定"></a>变量类型的限定</h3><p>有时，类或方法需要对类型变量加以约束。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T smallest = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++){</span><br><span class="line">            <span class="keyword">if</span>(smallest.compareTo(a[i]) &gt; <span class="number">0</span>){</span><br><span class="line">                smallest = a[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里有个问题：变量smallest的类型为T，意味着它可以使任何一个类的对象，我们并不能保证T所属的类有一个compareTo方法。</p><p>解决方法是限制T只能是实现了Comparable接口的类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> ...</span></span><br></pre></td></tr></tbody></table></figure><p>一个类型变量或通配符可以有多个限定</p><p><code>T extends Comparable &amp; Serializable</code></p><p>限定类型用&amp;分隔。<strong>可以根据需要拥有多个接口超类型，但最多有一个限定可以是类，且该类必须是限定列表中的第一个限定。</strong></p><h2 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，<strong>Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了</strong>。</p><p>那么，类型擦除做了什么呢？它做了以下工作：</p><ul><li>把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。</li><li>擦除出现的类型声明，即去掉 <code>&lt;&gt;</code> 的内容。比如 <code>T get()</code> 方法声明就变成了 <code>Object get()</code> ；<code>List&lt;String&gt;</code> 就变成了 <code>List</code>。如有必要，插入类型转换以保持类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。</li></ul><h4 id="类型变量未给出限定时"><a href="#类型变量未给出限定时" class="headerlink" title="类型变量未给出限定时"></a>类型变量未给出限定时</h4><p>让我们来看一个示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsErasureTypeDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(list1.getClass());</span><br><span class="line">        System.out.println(list2.getClass());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// class java.util.ArrayList</span></span><br><span class="line"><span class="comment">// class java.util.ArrayList</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>示例说明：</p><p>上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。</p><p>这是因为：<strong>使用泛型时，任何具体的类型信息都被擦除了</strong>。用Object代替了类型变量T。这意味着：<code>ArrayList&lt;Object&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 在运行时，JVM 将它们视为同一类型。</p><p>在list2中我们不能直接填入其他类型的数据，但是可以通过反射强行添加。</p></blockquote><h4 id="类型变量给出了限定"><a href="#类型变量给出了限定" class="headerlink" title="类型变量给出了限定"></a>类型变量给出了限定</h4><p>如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializeable</span></span>{</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这时，会用Comparable 替换类中的T。</p><p>当限定类型切换为&lt;T extends  Serializable  &amp; Comparable&gt;时，原始类型会用Serializable替换T，编译器会在必要时向Comparable插入强制类型转换。为了提高效率，应该将标签接口（即没有方法的接口）放在限定列表的末尾。</p></blockquote><h3 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h3><p>编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。</p><p>例如:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></tbody></table></figure><p>getFirst类型擦出后返回类型是Object。编译器会自动插入转换到Employee的强制类型转换。即，编译器把这个方法调用转换为两条虚拟机指令：</p><ul><li>对原始方法Pair.getFirst的调用。</li><li>将返回的Object类型强制转换为Employee类型。</li></ul><h3 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h3><p>类型擦除会造成多态的冲突，而JVM解决方法就是<strong>桥接方法</strong>。</p><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>{  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>{  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后我们想要一个子类继承它。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>{  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>{  </span><br><span class="line">        <span class="keyword">super</span>.setValue(value);  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p><p>所以，我们在子类中重写这两个方法一点问题也没有，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p><p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>{  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    }  </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>再看子类的两个重写的方法的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>{  </span><br><span class="line">    <span class="keyword">super</span>.setValue(value);  </span><br><span class="line">}  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果是在普通的继承关系中，根本就不会是重写，而是重载。 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span></span>{...}</span><br><span class="line"><span class="comment">// 从父类继承的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span></span>{...}</span><br></pre></td></tr></tbody></table></figure><p>我们在一个main方法测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>{  </span><br><span class="line">        DateInter dateInter = <span class="keyword">new</span> DateInter();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> Date());                  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> Object()); <span class="comment">//编译错误  </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。</p><p><strong>为什么会这样呢</strong>？</p><p>原因是这样的，我们传入父类的泛型类型是<code>Date</code>，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>{  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后在子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p><p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法呢？<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> </p><p><strong>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</strong></p><p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">Pair</span>&lt;<span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span>&gt; </span>{  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokespecial #8                  // Method com/tao/test/Pair."&lt;init&gt;":()V  </span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.util.Date)</span></span>;  <span class="comment">//我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getValue</span><span class="params">()</span></span>;    <span class="comment">//我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br><span class="line">       4: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;     <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.lang.Object)</span></span>;   <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       2: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Override只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p><p>关于setValue()方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span></span>{...}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span></span>{</span><br><span class="line">    setValue((String)value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>桥方法内部其实就是调用了我们自己的 setValue 方法，这样就避免了在重写的时候我们还能调用到父类的方法。解决类型擦除与多态之间的冲突。</p><p>关于getValue()方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己定义的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span></span>{...}</span><br><span class="line"><span class="comment">// 编译器生成的桥方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> getValue();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>子类中的桥方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p><p>如果这是一个普通的继承关系：</p><p>那么父类的setValue方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这在普通的类继承中也是普遍存在的重写，这就是<strong>协变</strong>。</p><h3 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h3><p>对于Java泛型转换，需要记住以下几个事实：</p><ul><li>虚拟机中没有泛型，只有普通的类和方法。</li><li>所有的类型参数都会替换为它们的限定类型。</li><li>会合成桥方法来保持多态。</li><li>为保持类型安全性，必要时会插入强制类型转换。</li></ul><h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><p>考虑一个类和一个子类，如Employee和Manager。Pair&lt;Manager&gt;是Pair&lt;Employee&gt;的一个子类吗?</p><p>答案是：“不是”。</p><img src="https://i.bmp.ovh/imgs/2021/11/fd2648b9ff1a066b.jpg" style="zoom:50%;"><p>无论S和T有什么关系，通常Pair&lt;S&gt;和Pair&lt;T&gt;都没有任何关系。</p><p><strong>这里就看到泛型类型和java数组之间一个重要的区别，可以将一个Manager[]数组赋给一个类型为Employee[]的变量。</strong></p><p>正是由于泛型时基于类型擦除实现的，所以，<strong>泛型类型无法向上转型</strong>。</p><blockquote><p>向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。</p></blockquote><p>这是因为，泛型类并没有自己独有的 <code>Class</code> 类对象。比如：并不存在 <code>Pair&lt;Manager&gt;.class</code> 或是 <code>Pair&lt;Employee&gt;.class</code>，Java 编译器会将二者都视为 <code>Pair.class</code>。</p><p><strong>泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了</strong>。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。</p><p>泛型类可以扩展或实现其他的泛型类，就这一点而言，它们与普通的类没有什么区别。例如：ArrayList&lt;T&gt;类实现了List&lt;T&gt;接口。这意味着一个ArrayList&lt;Manager&gt;可以转换为一个List&lt;Manager&gt;。但是，ArrayList&lt;Manager&gt;不是一个ArrayList&lt;Manager&gt;或List&lt;Manager&gt;。</p><img src="https://i.bmp.ovh/imgs/2021/11/3cb4dd71f3ee8622.jpg" style="zoom:40%;"><h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在通配符类型中，允许类型参数发生变化。</p><p>类型通配符一般是使用 <code>?</code> 代替具体的类型参数。例如 <code>List&lt;?&gt;</code> 在逻辑上是 <code>List&lt;String&gt;</code> ，<code>List&lt;Integer&gt;</code> 等所有 <code>List&lt;具体类型实参&gt;</code> 的父类。</p><h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p>可以使用<strong>上界通配符</strong>来缩小类型参数的类型范围。</p><p>它的语法形式为：<code>&lt;? extends 父类&gt;</code>可以表示所有继承了该父类的子类。</p><p><strong>我们可以通过使用通配符来向上转型</strong>。</p><p>例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已经实例化3个Manager m1, m2, m3;</span></span><br><span class="line">Pair&lt;Manager&gt; managers = <span class="keyword">new</span> Pair&lt;Manager&gt;(m1, m2);</span><br><span class="line">Pair&lt;? extends Employee&gt; employees = managers; <span class="comment">//Ok </span></span><br><span class="line">employees.setFirst(m3);<span class="comment">//编译不通过</span></span><br></pre></td></tr></tbody></table></figure><p>为什么最后一行编译不通过呢？</p><p>我们来看类型<code>Pair&lt;? extends Employee&gt;</code>它的方法如下：</p><p><code>? extends Employee getFirst()</code></p><p><code>void setFirst(? extends Employee)</code></p><p>这样将不可能调用<code>setFirst</code>方法。编译器只知道需要Employee的某个子类型，但不知道具体是什么类型。毕竟<code>?</code>不能匹配。</p><p>而<code>getFirst</code>就不存在这个问题：将<code>getFirst</code>的返回值赋给一个Employee引用是完全合法的。</p><h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><strong>下界通配符</strong>将未知类型限制为该类型的特定类型或超类类型。</p><blockquote><p>🔔 注意：<strong>上界通配符和下界通配符不能同时使用</strong>。</p></blockquote><p>它的语法形式为：<code>&lt;? super 子类&gt;</code>它将类型限制为该子类的所有父类。</p><p>带有超类型限定的通配符的行为与上面所讲的上界通配符相反。可以为方法提供参数，但不能使用返回值。</p><p>例如<code>Pair&lt;? super Manager&gt;</code>有如下方法：</p><p><code>void setFirst(? super Manager)</code></p><p><code>? super Manager getFirst()</code></p><p>编译器无法知道<code>setFirst</code>方法的具体类型，因此不能接受参数类型为<code>Employee</code>或<code>Object</code>的方法调用。只能传递<code>Manager</code>的对象，或者某个子类型对象。另外，如果调用<code>getFirst</code>，不能保证返回对象的类型，只能把它赋给一个<code>Object</code>。</p><img src="https://i.bmp.ovh/imgs/2021/11/2842e70b0096df34.jpg" style="zoom:33%;"><p><strong>直观的讲，带有超类型限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象。</strong></p><h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>无界通配符作用：</p><ul><li>接受任何泛型类型数据</li><li>实现不依赖于具体类型参数的简单方法,如非空判断，size()，clear() 等方法</li><li>用于捕获参数类型并交由泛型方法进行处理</li></ul><p>语法形式：<code>&lt;?&gt;</code></p><p>例如:<code>Pair&lt;?&gt;</code></p><p>它有以下方法：</p><p><code>? getFirst()</code></p><p><code>void setFirst(?)</code></p><p><code>getFirst</code>的返回值只能赋给一个<code>Object</code>。<code>setFirst</code>方法不能被调用。<strong>甚至不能用Object调用</strong>。</p><p><code>Pair\&lt;?&gt;</code>和<code>Pair</code>的本质区别在于：可以用任意Object对象调用原始Pair类的setFirst方法。</p><h2 id="限制与局限性"><a href="#限制与局限性" class="headerlink" title="限制与局限性"></a>限制与局限性</h2><p>🔔 泛型类的构造器不能加入&lt;&gt;括起来的类型参数。</p><p>🔔 泛型的指定中<strong>不能使用基本数据类型</strong>，基本类型不是 Object 子类，应该使用包装类替换。</p><p>🔔 不能创建类型参数的实例。如果我们确实需要实例化一个泛型，可以通过反射实现。</p><p>🔔 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。<strong>但在静态方法中不能使用类的泛型。</strong></p><p>🔔 不能catch 或 throw泛型类的对象。事实上，泛型类扩展Throwable都不合法。</p><p>即</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>{</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不会通过编译。</p><p>但是在异常<strong>声明</strong>中可以使用类型变量。下面方法是合法的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>{</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">catch</span>(Throwable realCause) {</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的这样使用是没问题的。</p><p>🔔 如果泛型结构是一个<strong>接口或抽象类，则不可创建泛型类的对象</strong>。</p><p>🔔 泛型<strong>不同的引用不能相互赋值</strong>。</p><p>例如<code>Pair&lt;String&gt;</code>的对象不能赋值给<code>Pair&lt;Integer&gt;</code>的对象。</p><p>🔔 实例化后，操作原来泛型的结构必须与指定的泛型类型一致。</p><p>🔔 泛型无法使用 Instance of 和 getClass() 进行类型判断</p><p>🔔 泛型如果不指定，将被<strong>擦除</strong>，泛型对应的类型均按照<code>Object</code>处理，但不等价于<code>Object</code></p><p>🔔  仅仅是泛型类相同，而类型参数不同的方法不能重载。</p><p>例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>{ }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>{ } <span class="comment">// 编译错误</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>🔔 关于泛型数组</p><p>不能创建参数化类型的数组</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];  <span class="comment">//ERROR</span></span><br></pre></td></tr></tbody></table></figure><p>这是因为擦除之后，table的类型转换为Object[]，数组会记住它的元素类型，如果试图存储其他类型的元素，会抛出异常。不过对于泛型类型，擦除使得这种机制无效。对于<code>Object[0] = new Pair&lt;Employee&gt;()</code>尽管能通过数组存储的检查，仍会导致一个类型错误。所以，不允许创建泛型数组。</p><p>可以声明通配类型的数组，然后进行强制转换。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = (Pair&lt;String&gt;[]) <span class="keyword">new</span> Pair&lt;?&gt;[<span class="number">10</span>];  <span class="comment">//OK,但不安全</span></span><br></pre></td></tr></tbody></table></figure><p>所以，如果想要收集参数化类型对象，简单的使用ArrayList更有效。</p><p>参考资料及博客：</p><p>《java核心技术卷I》</p><p>Java基础——泛型机制详解   链接：<a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></p><p>深入理解Java泛型   链接：<a href="https://dunwu.github.io/javacore/basics/java-generic.html">https://dunwu.github.io/javacore/basics/java-generic.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2021/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Activity的构成及事件分发机制</title>
      <link href="/2021/10/24/Activity%E7%9A%84%E6%9E%84%E6%88%90%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/10/24/Activity%E7%9A%84%E6%9E%84%E6%88%90%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>View的工作流程</title>
      <link href="/2021/10/24/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/10/24/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>View的工作流程指的就是measure、layout和draw。其中measure用来测量VIew的宽和高，layout用来确定View的位置，draw用来绘制View。</p><h1 id="Acitivity启动过程"><a href="#Acitivity启动过程" class="headerlink" title="Acitivity启动过程"></a>Acitivity启动过程</h1><h2 id="startActivityForResult方法"><a href="#startActivityForResult方法" class="headerlink" title="startActivityForResult方法"></a>startActivityForResult方法</h2><p>先从Activity的startActivity方法说起。</p><p>startActivity方法或startActivityForResult有很多种重载方式，但它们最终都会调用startActivityForResult(intent, requestCode, options)方法。源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> Bundle options)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是第一次启动，则成员变量mParent为空，否则不为空。</span></span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//第一次启动执行</span></span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用Instrumentation的execStartActivity(Context who, IBinder contextThread····)方法</span></span><br><span class="line">            </span><br><span class="line">            Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) {</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),ar.getResultData());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果是请求一个结果（result），我们可以使Activity不可见，直到收到结果，在onCreate(Bundle savedInstanceState)方法或者onResume()期间设置此代码将在此期间隐藏Activity，以避免闪烁，只有在请求结果时才可以这样做，因为这样可以保证在Activity完成时我们将获得信息，无论它发生了什么</span></span><br><span class="line"></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//如果不是第一次启动执行</span></span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) {</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="Instrumentation的execStartActivity方法"><a href="#Instrumentation的execStartActivity方法" class="headerlink" title="Instrumentation的execStartActivity方法"></a>Instrumentation的execStartActivity方法</h2><p>我们来看一看第一次执行时调用的Instrumentation的execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options)方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Instrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>{</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">// 调用ActivityTaskManagerService的startActivity方法</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">         checkStartActivityResult(result, intent);</span><br><span class="line">     } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ActivityTaskManager.getService()<strong>方法得到的是</strong>IActivityTaskManager</strong>接口，它是通过<strong>进程间通讯（Inter-Process Communication，即IPC）</strong>调用的，<strong>IActivityTaskManager</strong>的<strong>服务端</strong>是<strong>ActivityTaskManagerService</strong>，所以最终是调用<strong>ActivityTaskManagerService</strong>的<strong>startActivity</strong>方法，后面的调用过程，这里就不再详细地讲解，最后调用的是<strong>ActivityThread</strong>类的**handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)**方法，</p><h2 id="调用的是ActivityThread类的handleLaunchActivity方法"><a href="#调用的是ActivityThread类的handleLaunchActivity方法" class="headerlink" title="调用的是ActivityThread类的handleLaunchActivity方法"></a>调用的是<strong>ActivityThread</strong>类的handleLaunchActivity方法</h2><p>源码如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">           PendingTransactionActions pendingActions, Intent customIntent)</span> </span>{</span><br><span class="line">       <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">       <span class="comment">// we are back active so skip it.</span></span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line">       mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) {</span><br><span class="line">           mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">           mProfiler.startProfiling();</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">       handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">           TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">       <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">               &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) {</span><br><span class="line">           HardwareRenderer.preload();</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//----------------------从这里开始-------------------------//</span></span><br><span class="line">       </span><br><span class="line">       WindowManagerGlobal.initialize();     <span class="comment">// 初始化全局的WindowManagerGlobal </span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Hint the GraphicsEnvironment that an activity is launching on the process. 提示图形环境Activity正在进程上启动.</span></span><br><span class="line">       GraphicsEnvironment.hintActivityLaunch();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a != <span class="keyword">null</span>) {</span><br><span class="line">           r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">           reportSizeConfigurations(r);</span><br><span class="line">           <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) {</span><br><span class="line">               pendingActions.setOldState(r.state);</span><br><span class="line">               pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">               pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">           <span class="keyword">try</span> {</span><br><span class="line">               ActivityTaskManager.getService()</span><br><span class="line">                       .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                               Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">           } <span class="keyword">catch</span> (RemoteException ex) {</span><br><span class="line">               <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="调用performLaunchActivity方法来创建Activity"><a href="#调用performLaunchActivity方法来创建Activity" class="headerlink" title="调用performLaunchActivity方法来创建Activity"></a>调用performLaunchActivity方法来创建Activity</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>{</span><br><span class="line">       <span class="comment">//一些需要启动的Activity的信息。</span></span><br><span class="line">       ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">       <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) {</span><br><span class="line">           r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                   Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       ComponentName component = r.intent.getComponent();</span><br><span class="line">       <span class="keyword">if</span> (component == <span class="keyword">null</span>) {</span><br><span class="line">           component = r.intent.resolveActivity(</span><br><span class="line">               mInitialApplication.getPackageManager());</span><br><span class="line">           r.intent.setComponent(component);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) {</span><br><span class="line">           component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                   r.activityInfo.targetActivity);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">       Activity activity = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">           <span class="comment">// 反射创建Activity</span></span><br><span class="line">           activity = mInstrumentation.newActivity(</span><br><span class="line">                   cl, component.getClassName(), r.intent);</span><br><span class="line">           StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">           r.intent.setExtrasClassLoader(cl);</span><br><span class="line">           r.intent.prepareToEnterProcess();</span><br><span class="line">           <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) {</span><br><span class="line">               r.state.setClassLoader(cl);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                       <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                               + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">// 创建Application对象，它是个单例，一个进程只有一个Application</span></span><br><span class="line">           Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {</span><br><span class="line">               <span class="comment">// 省略部分代码</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">// Activity resources must be initialized with the same loaders as the</span></span><br><span class="line">               <span class="comment">// application context.</span></span><br><span class="line">               appContext.getResources().addLoaders(</span><br><span class="line">                       app.getResources().getLoaders().toArray(<span class="keyword">new</span> ResourcesLoader[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">               appContext.setOuterContext(activity);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// Activity成功创建，调用Activity的attach方法，这个方法会创建PhoneWindow，它是Window抽象类的子类</span></span><br><span class="line">               <span class="comment">// 将 context等各种数据与Activity绑定，初始化Activity</span></span><br><span class="line">               activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                       r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                       r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                       r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                       r.assistToken);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 省略部分代码</span></span><br><span class="line">               <span class="comment">// 调用Activity的onCreate方法</span></span><br><span class="line">               <span class="keyword">if</span> (r.isPersistable()) {</span><br><span class="line">                   mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">               } <span class="keyword">else</span> {</span><br><span class="line">                   mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">if</span> (!activity.mCalled) {</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                           <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                                   <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">               }</span><br><span class="line">               r.activity = activity;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 设为ON_CREATE状态</span></span><br><span class="line">           r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// updatePendingActivityConfiguration()方法的作用是从mActivities中读取数据以更新ActivityClientRecord，它在不同的线程中运行，所以要取ResourcesManager作为锁对象</span></span><br><span class="line">           <span class="keyword">synchronized</span> (mResourcesManager) {</span><br><span class="line">               mActivities.put(r.token, r);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">       } <span class="keyword">catch</span> (SuperNotCalledException e) {</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                       <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                               + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回Activity</span></span><br><span class="line">       <span class="keyword">return</span> activity;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>performActivity通过反射机制创建了Activity的实例，并且构建了Application的实例。</p><h2 id="调用了Activity的attach方法"><a href="#调用了Activity的attach方法" class="headerlink" title="调用了Activity的attach方法"></a>调用了Activity的attach方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                  CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                  NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>{</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PhoneWindow对象，并且赋值给成员变量mWindow</span></span><br><span class="line">       mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">       mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">       mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将Window和WindowManager绑定</span></span><br><span class="line">       mWindow.setWindowManager(</span><br><span class="line">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">               mToken, mComponent.flattenToString(),</span><br><span class="line">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了Instrumentation对象的callActivityOnCreate方法"><a href="#调用了Instrumentation对象的callActivityOnCreate方法" class="headerlink" title="调用了Instrumentation对象的callActivityOnCreate方法"></a>调用了Instrumentation对象的callActivityOnCreate方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,PersistableBundle persistentState)</span> </span>{</span><br><span class="line">        prePerformCreate(activity); </span><br><span class="line">        activity.performCreate(icicle, persistentState);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了Activity的preformCreate方法"><a href="#调用了Activity的preformCreate方法" class="headerlink" title="调用了Activity的preformCreate方法"></a>调用了Activity的preformCreate方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>{</span><br><span class="line">        dispatchActivityPreCreated(icicle);</span><br><span class="line">        mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">        <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) {</span><br><span class="line">            onCreate(icicle, persistentState);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            onCreate(icicle);</span><br><span class="line">        }</span><br><span class="line">        .......</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了创建好的Activity的onCreate方法，至此，Activity启动完成。"><a href="#调用了创建好的Activity的onCreate方法，至此，Activity启动完成。" class="headerlink" title="调用了创建好的Activity的onCreate方法，至此，Activity启动完成。"></a>调用了创建好的Activity的onCreate方法，至此，Activity启动完成。</h2><img src="https://i.bmp.ovh/imgs/2021/10/ed536344f01dc61a.jpg" style="zoom:50%;"><h2 id="调用OnStart和OnResume执行绘制流程"><a href="#调用OnStart和OnResume执行绘制流程" class="headerlink" title="调用OnStart和OnResume执行绘制流程"></a>调用OnStart和OnResume执行绘制流程</h2><p>接着前面的逻辑，接着就会调用<strong>ActivityThread</strong>类的<strong>handleStartActivity(ActivityClientRecord r, PendingTransactionActions pendingActions)<strong>方法，然后</strong>Activity</strong>类的<strong>onStart</strong>方法就会被调用，然后调用<strong>ActivityThread</strong>类的**handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason)**方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String reason)</span> </span>{</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的onResume方法</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {</span><br><span class="line">        <span class="comment">// 得到Window，Window是抽象类，其中，PhoneWindow类继承Window类，它是Window类的唯一子类</span></span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="comment">// 得到DecorView</span></span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 将DecorView设为不可见</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        <span class="comment">// 得到ViewManager，ViewManager是一个接口，WindowManger也是一个接口，它继承ViewManager接口，其中，WindowManagerImpl类实现ViewManager接口，这里的vm可以看作是WindowMangerImpl对象</span></span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) {</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) {</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 调用WindowManagerImpl类的addView(View view, ViewGroup.LayoutParams params)方法，执行绘制流程</span></span><br><span class="line">                wm.addView(decor, l);<span class="comment">//decorView 和 PhoneWindow 的布局参数</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) {</span><br><span class="line">        <span class="comment">// 如果Window已经被添加，但是在恢复（resume）期间启动了另一个Activity，这样的话，就不要使Window可见</span></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>ActivityThread#handleResumeActivity方法</strong>首先调用<strong>performResumeActivity</strong>，在<strong>performResumeActivity</strong>完成之后在会调用<strong>WindowManager#addView向Window</strong>中添加布局。 所以，实际上布局是在<strong>onResume</strong>完成之后才被加载在<strong>PhoneWindow</strong>中的，不过具体的内容我们还是需要看看<strong>performResumeActivity</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        <span class="comment">// 对于Lifecycle的一些判断</span></span><br><span class="line">        <span class="keyword">if</span> (r.getLifecycleState() == ON_RESUME) {</span><br><span class="line">            <span class="keyword">if</span> (!finalStateRequest) {</span><br><span class="line">               <span class="comment">// ... 如果已经是onResume 就回抛出异常</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用Activity#performResume 调用流程同上onCreate，最终会调用activity的onResume。</span></span><br><span class="line">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line"></span><br><span class="line">            r.state = <span class="keyword">null</span>;</span><br><span class="line">            r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">            r.setState(ON_RESUME);</span><br><span class="line"></span><br><span class="line">            reportTopResumedActivityChanged(r, r.isTopResumedActivity, <span class="string">"topWhenResuming"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           <span class="comment">// ....</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="View的绘制流程-在Activity的onResume方法之后执行"><a href="#View的绘制流程-在Activity的onResume方法之后执行" class="headerlink" title="View的绘制流程 在Activity的onResume方法之后执行"></a>View的绘制流程 在Activity的onResume方法之后执行</h1><h2 id="调用WindowManagerImpl类的addView方法"><a href="#调用WindowManagerImpl类的addView方法" class="headerlink" title="调用WindowManagerImpl类的addView方法"></a>调用<strong>WindowManagerImpl</strong>类的addView方法</h2><p>调用<strong>WindowManagerImpl</strong>类的<strong>addView(View view, ViewGroup.LayoutParams params)<strong>方法分别传入了</strong>DecorView</strong>和<strong>PhoneWindow</strong>的属性</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>{</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="comment">//···</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>{</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        <span class="comment">//decorView 和 PhoneWindow 的布局参数</span></span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,mContext.getUserId());</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//···</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了WindowManagerGlobal类的addView方法"><a href="#调用了WindowManagerGlobal类的addView方法" class="headerlink" title="调用了WindowManagerGlobal类的addView方法"></a>调用了WindowManagerGlobal类的addView方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManagerGlobal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Display display, Window parentWindow)</span> </span>{</span><br><span class="line">    <span class="comment">//···</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) {</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ViewRootImpl对象</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置DecorView的LayoutParams</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将DecorView添加到View的ArrayList中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="comment">// 将ViewRootImpl添加到ViewRootImpl的ArrayList中</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="comment">// 将DecorView的LayoutParams添加到WindowManager.LayoutParams的ArrayList中</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//调用ViewRootImpl的setView(View view, WindowManager.LayoutParams attrs, View panelParentView)方法</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);<span class="comment">//decorView 和 PhoneWindow 的布局参数，NULL</span></span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">            <span class="comment">// 抛出BadTokenException或者InvalidDisplayException</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了ViewRootImpl类的setView方法"><a href="#调用了ViewRootImpl类的setView方法" class="headerlink" title="调用了ViewRootImpl类的setView方法"></a>调用了ViewRootImpl类的setView方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果成员变量mView为空，就将传进来的DecorView赋值给它</span></span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">            <span class="comment">// 调用requestLayout()方法</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    adjustLayoutParamsForCompatibility(mWindowAttributes);</span><br><span class="line">                    <span class="comment">//调用WindowSession#addToDispaly，再调用WindowManagerService#addWindow</span></span><br><span class="line">                    res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mDisplayCutout, inputChannel,</span><br><span class="line">                            mTempInsets, mTempControls);</span><br><span class="line">                    setFrame(mTmpFrame);</span><br><span class="line">            } <span class="keyword">catch</span> {</span><br><span class="line">                <span class="comment">//···</span></span><br><span class="line">            }</span><br><span class="line"><span class="comment">//···</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用View的assignParent(ViewParent parent)方法</span></span><br><span class="line">            view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="requestLayout方法"><a href="#requestLayout方法" class="headerlink" title="requestLayout方法"></a>requestLayout方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) {</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>requestLayout()<strong>方法的作用是</strong>检查当前线程是不是创建ViewRootImpl所在的线程</strong>，<strong>如果是就通知View执行绘制流程</strong>，<strong>否则就抛出CalledFromWrongThreadException异常</strong></p><h2 id="View的assignParent方法"><a href="#View的assignParent方法" class="headerlink" title="View的assignParent方法"></a>View的assignParent方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignParent</span><span class="params">(ViewParent parent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果这个View还没有parent，就将传进来的ViewRootImpl赋值给成员变量mParent</span></span><br><span class="line">        mParent = parent;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果形式参数parent为空，就将成员变量mParent设为空</span></span><br><span class="line">        mParent = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 如果这个View已经有parent，再次设置parent就会抛出RuntimeException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"view "</span> + <span class="keyword">this</span> + <span class="string">" being added, but"</span></span><br><span class="line">                + <span class="string">" it already has a parent"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法的作用是<strong>将ViewRootImpl和DecorView关联起来</strong>，这里传进来的是<strong>ViewRootImpl</strong>，<strong>ViewRootImpl</strong>实现<strong>ViewParent</strong>接口，每一个<strong>Activity</strong>的<strong>根布局</strong>是<strong>DecorView</strong>，<strong>DecorView</strong>的<strong>parentView</strong>是<strong>ViewRootImpl</strong>，所以在<strong>子元素</strong>中调用<strong>invalidate()<strong>方法这类的方法的时候，需要遍历找到</strong>parentView</strong>，最后都会调用<strong>ViewRootImpl</strong>相关的方法。</p><p><a href="https://imgtu.com/i/5bSGWV"><img src="https://z3.ax1x.com/2021/10/27/5bSGWV.jpg" alt="5bSGWV.jpg" style="zoom:50%;"></a></p><h1 id="setContentView方法"><a href="#setContentView方法" class="headerlink" title="setContentView方法"></a>setContentView方法</h1><p>我们的<strong>Activity</strong>类是继承<strong>AppCompatActivity</strong>类.</p><p><strong>Appcompat</strong>最开始是出现在<strong>com.android.support:appcompat-v7</strong>库中，它是为了让<strong>Android SDK 7（Android 2.1，即Android Eclair）</strong>以上的设备可以使用<strong>ActionBar</strong>，而在<strong>com.android.support:appcompat-v7:21</strong>以上的库，<strong>AppCompat</strong>可以为<strong>Android SDK 7（Android 2.1，即Android Eclair）</strong>以上的设备带来<strong>Material Color Palette</strong>、<strong>Widget着色</strong>、<strong>Toolbar</strong>等功能，并且用<strong>AppCompatActivity</strong>替代<strong>ActionBarActivity</strong>，在<strong>Android SDK 28（Android 9.0，即Android Pie）</strong>发布后，<strong>appcompat</strong>库都迁移到了<strong>AndroidX</strong>库，<strong>AndroidX</strong>库是<strong>Android Jetpack</strong>组件。</p><h2 id="AppCompatActivity类的setContentView方法。"><a href="#AppCompatActivity类的setContentView方法。" class="headerlink" title="AppCompatActivity类的setContentView方法。"></a><strong>AppCompatActivity</strong>类的<strong>setContentView方法</strong>。</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppCompatActivity.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>{</span><br><span class="line">    <span class="comment">// 调用AppCompatDelegate的setContentView(int resId)方法</span></span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="getDelegate方法"><a href="#getDelegate方法" class="headerlink" title="getDelegate方法"></a>getDelegate方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppCompatActivity.java</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppCompatDelegate <span class="title">getDelegate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mDelegate == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果mDelegate为空，就调用AppCompatDelegate抽象类的create(@NonNull Activity activity, @Nullable AppCompatCallback callback)方法</span></span><br><span class="line">        mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mDelegate;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="AppCompatDelegate抽象类的create方法"><a href="#AppCompatDelegate抽象类的create方法" class="headerlink" title="AppCompatDelegate抽象类的create方法"></a><strong>AppCompatDelegate</strong>抽象类的<strong>create</strong>方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppCompatDelegate.java</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppCompatDelegate <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> AppCompatCallback callback)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建AppCompatDelegateImpl对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImpl(activity, callback);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以<strong>AppCompatDelegateImpl</strong>类是继承<strong>AppCompatDelegate</strong>抽象类。</p><h2 id="AppCompatDelegateImpl的setContentView方法"><a href="#AppCompatDelegateImpl的setContentView方法" class="headerlink" title="AppCompatDelegateImpl的setContentView方法"></a>AppCompatDelegateImpl的setContentView方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppCompatDelegateImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建DecorView，并且将其添加到Window</span></span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    <span class="comment">// 找到DecorView中的contentView</span></span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    <span class="comment">// 移除contentView中所有的View</span></span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    <span class="comment">// 根据传入的resId将要加载的XML布局添加到contentView</span></span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    <span class="comment">// onContentChanged()方法是一个钩子方法，它会在屏幕的内容视图发生变化时调用</span></span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ensureSubDecor方法"><a href="#ensureSubDecor方法" class="headerlink" title="ensureSubDecor方法"></a><strong>ensureSubDecor</strong>方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppCompatDelegateImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureSubDecor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!mSubDecorInstalled) {</span><br><span class="line">        <span class="comment">// 如果还没有创建DecorView，就调用createSubDecor()方法创建DecorView</span></span><br><span class="line">        mSubDecor = createSubDecor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到title的字符</span></span><br><span class="line">        CharSequence title = getTitle();</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(title)) {</span><br><span class="line">            <span class="comment">// 如果设置了title，就执行以下逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) {</span><br><span class="line">                mDecorContentParent.setWindowTitle(title);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (peekSupportActionBar() != <span class="keyword">null</span>) {</span><br><span class="line">                peekSupportActionBar().setWindowTitle(title);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) {</span><br><span class="line">                mTitleView.setText(title);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//适配尺寸在设备上，一些参数的初始化</span></span><br><span class="line">        applyFixedSizeWindow();</span><br><span class="line"></span><br><span class="line">        onSubDecorInstalled(mSubDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记已经创建DecorView</span></span><br><span class="line">        mSubDecorInstalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建面板菜单</span></span><br><span class="line">        PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mIsDestroyed &amp;&amp; (st == <span class="keyword">null</span> || st.menu == <span class="keyword">null</span>)) {</span><br><span class="line">            <span class="comment">// 通过添加刷新通知消息到主线程对应的消息队列中来刷新界面，目的是防止onCreateOptionsMenu(Nenu menu)方法在Activity调用onCreate(@Nullable Bundle savedInstanceState)方法的途中被调用</span></span><br><span class="line">            invalidatePanelMenu(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作用是<strong>创建DecorView</strong>，<strong>并且将其添加到Window中</strong>，<strong>同时创建面板菜单</strong></p><h2 id="createSubDecor方法"><a href="#createSubDecor方法" class="headerlink" title="createSubDecor方法"></a><strong>createSubDecor</strong>方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppCompatDelegateImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewGroup <span class="title">createSubDecor</span><span class="params">()</span> </span>{</span><br><span class="line">    TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) {</span><br><span class="line">        a.recycle();</span><br><span class="line">        <span class="comment">// 如果使用AppCompatActivity，但是没有设置一个Theme.AppCompat的主题，就抛出IllegalStateException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"You need to use a Theme.AppCompat theme (or descendant) with this activity."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Window的属性</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, <span class="keyword">false</span>)) {</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, <span class="keyword">false</span>)) {</span><br><span class="line">        <span class="comment">// 不允许没有标题的actionBar</span></span><br><span class="line">        requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, <span class="keyword">false</span>)) {</span><br><span class="line">        requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, <span class="keyword">false</span>)) {</span><br><span class="line">        requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY);</span><br><span class="line">    }</span><br><span class="line">    mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, <span class="keyword">false</span>);</span><br><span class="line">    a.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ensureWindow()方法来检查DecorView是否已经添加到Window</span></span><br><span class="line">    ensureWindow();</span><br><span class="line">    <span class="comment">// 调用成员变量mWindow的getDecorView()方法创建DecorView，要注意的是，成员变量mWindow声明为Window，Window是一个抽象类，这里的实现类是PhoneWindow</span></span><br><span class="line">    mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到LayoutInflater</span></span><br><span class="line">    <span class="keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标志添加到对应的布局</span></span><br><span class="line">    <span class="keyword">if</span> (!mWindowNoTitle) {</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) {</span><br><span class="line">            <span class="comment">// 如果窗口需要浮动，就添加id是abc_dialog_title_material的布局</span></span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_dialog_title_material, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 浮动窗口不能有操作栏，重置标志</span></span><br><span class="line">            mHasActionBar = mOverlayActionBar = <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mHasActionBar) {</span><br><span class="line">            <span class="comment">// 如果窗口有actionBar，就执行以下逻辑</span></span><br><span class="line">            TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            mContext.getTheme().resolveAttribute(R.attr.actionBarTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Context themedContext;</span><br><span class="line">            <span class="keyword">if</span> (outValue.resourceId != <span class="number">0</span>) {</span><br><span class="line">                themedContext = <span class="keyword">new</span> ContextThemeWrapper(mContext, outValue.resourceId);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                themedContext = mContext;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用主题化上下文（themedContext）添加id是abc_screen_toolbar的布局</span></span><br><span class="line">            subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                    .inflate(R.layout.abc_screen_toolbar, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            mDecorContentParent = (DecorContentParent) subDecor</span><br><span class="line">                    .findViewById(R.id.decor_content_parent);</span><br><span class="line">            mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将特性传给DecorContentParent</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlayActionBar) {</span><br><span class="line">                mDecorContentParent.initFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mFeatureProgress) {</span><br><span class="line">                mDecorContentParent.initFeature(Window.FEATURE_PROGRESS);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mFeatureIndeterminateProgress) {</span><br><span class="line">                mDecorContentParent.initFeature(Window.FEATURE_INDETERMINATE_PROGRESS);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mOverlayActionMode) {</span><br><span class="line">            <span class="comment">// 如果需要覆盖Activity的内容，就添加id是abc_screen_simple_overlay_action_mode的布局</span></span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_screen_simple_overlay_action_mode, <span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果不需要覆盖Activity的内容，就添加id是abc_screen_simple的布局</span></span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subDecor == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果DecorView这个时候还是空，就抛出IllegalArgumentException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"AppCompat does not support the current theme features: { "</span></span><br><span class="line">                        + <span class="string">"windowActionBar: "</span> + mHasActionBar</span><br><span class="line">                        + <span class="string">", windowActionBarOverlay: "</span>+ mOverlayActionBar</span><br><span class="line">                        + <span class="string">", android:windowIsFloating: "</span> + mIsFloating</span><br><span class="line">                        + <span class="string">", windowActionModeOverlay: "</span> + mOverlayActionMode</span><br><span class="line">                        + <span class="string">", windowNoTitle: "</span> + mWindowNoTitle</span><br><span class="line">                        + <span class="string">" }"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDecorContentParent == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果成员变量mDecorContentParent为空，就将DecorView中的id为title的TextView赋值给成员变量mTitleView</span></span><br><span class="line">        mTitleView = (TextView) subDecor.findViewById(R.id.title);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让装饰可以选择适合系统窗口，例如：Window的装饰</span></span><br><span class="line">    ViewUtils.makeOptionalFitsSystemWindows(subDecor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">            R.id.action_bar_activity_content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到contentView</span></span><br><span class="line">    <span class="keyword">final</span> ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">if</span> (windowContentView != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (windowContentView.getChildCount() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果已经有View添加到Window的contentView，就把它们迁移到contentView</span></span><br><span class="line">            <span class="keyword">final</span> View child = windowContentView.getChildAt(<span class="number">0</span>);</span><br><span class="line">            windowContentView.removeViewAt(<span class="number">0</span>);</span><br><span class="line">            contentView.addView(child);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        windowContentView.setId(View.NO_ID);</span><br><span class="line">        <span class="comment">// 给contentView添加android.R.id.content的id，对Fragment挺有用</span></span><br><span class="line">        contentView.setId(android.R.id.content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// decorContent有一个前景可绘制的设置（windowContentOverlay），设为空，是因为我们自己处理它</span></span><br><span class="line">        <span class="keyword">if</span> (windowContentView <span class="keyword">instanceof</span> FrameLayout) {</span><br><span class="line">            ((FrameLayout) windowContentView).setForeground(<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用PhoneWindow的setContentView(View view)方法</span></span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line"></span><br><span class="line">    contentView.setAttachListener(<span class="keyword">new</span> ContentFrameLayout.OnAttachListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedFromWindow</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>{</span><br><span class="line">            dismissPopups();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回DecorView</span></span><br><span class="line">    <span class="keyword">return</span> subDecor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考文章及资料：<br>《Android进阶之光》      //这本书的代码是之前的版本了，有的东西已经过时。</p><p>深入了解Android的View工作原理：<a href="https://www.jianshu.com/p/4361fe3cf287">https://www.jianshu.com/p/4361fe3cf287</a></p><p>Android UI体系知识&amp;面试题: <a href="https://www.bilibili.com/read/cv13672159?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv13672159?spm_id_from=333.999.0.0</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android多线程</title>
      <link href="/2021/10/21/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/10/21/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Android沿用了java的线程模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View的滑动冲突</title>
      <link href="/2021/10/14/View%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
      <url>/2021/10/14/View%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>​        我们在完成android需求时，可能会遇到多种控件同时可以滑动的场景，这时就可能会出现滑动冲突。在学习完android事件的分发机制之后，我们来学习滑动冲突的处理办法。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><img src="https://i.bmp.ovh/imgs/2021/10/22942787a7ed19cb.png"></p><span id="more"></span><h1 id="常见的滑动冲突场景"><a href="#常见的滑动冲突场景" class="headerlink" title="常见的滑动冲突场景"></a>常见的滑动冲突场景</h1><img src="https://i.bmp.ovh/imgs/2021/10/bf87cbe1b2d94420.png" style="zoom: 50%;"><ul><li><p>场景一：外部滑动方向和内部不一致。</p></li><li><p>场景二：外部滑动方向和内部一致。</p></li><li><p>场景三：以上两种情况的嵌套。</p><blockquote><p>场景一的应用场景示例：ViewPager和Fragment的配合。（ViewPager内部处理了滑动冲突）</p><p>场景二的应用场景示例：SrollerView里嵌套ListView。</p></blockquote></li></ul><h1 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h1><h2 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h2><p>因为内外两层的滑动方向不一致，所以当用户进行外层滑动时，需要让外部的View拦截点击事件，当用户进行内层的滑动时，需要让内部View拦截点击事件。这时我们可以根据滑动的特征来解决滑动冲突。即<strong>根据滑动的方向来判断拦截事件的View</strong>。</p><p>这个问题就变得很简单了——我们可以根据滑动过程中<strong>两个点的坐标来得出滑动的方向</strong>。</p><p>例如：</p><ul><li>水平方向和竖直方向的距离差</li><li>滑动路径和水平方向形成的夹角</li><li>水平和竖直方向的速度差</li></ul><h2 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h2><p>这个场景无法根据场景一的判断条件来做出判断，但我们一般能在业务上找到突破点。比如在某种状态时需要外部View响应用户的滑动，在另一种状态时需要内部View响应。</p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>抛开滑动规则，我们需要找到一种不依赖具体的滑动规则的通用的解决方法。</p><h2 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h2><p>即点击事件都先经过父容器的拦截处理。如果父容器需要此事件就进行拦截，否则不拦截。</p><p>需要<strong>重写父容器的onInterceptTouchEvent方法</strong>，在方法内做相应的拦截。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span> <span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">       <span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">       <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">       <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:<span class="comment">//1</span></span><br><span class="line">               intercept = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">               <span class="keyword">if</span>( *父容器需要的当前点击事件*  ){</span><br><span class="line">                   intercept = <span class="keyword">true</span>;</span><br><span class="line">               }<span class="keyword">else</span>{</span><br><span class="line">                   intercept = <span class="keyword">false</span>;</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:<span class="comment">//2</span></span><br><span class="line">               intercept = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       }</span><br><span class="line">       lastInterceptX = x;</span><br><span class="line">       lastInterceptY = y;</span><br><span class="line">       <span class="keyword">return</span> intercept;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>针对不同的滑动冲突，只需要修改父容器需要的当前点击事件这个条件即可。</p><blockquote><p>1：不可拦截ACTION_DOWN事件，一旦拦截，后续MOVE和UP事件都会交由父容器处理</p><p>2：必须返回false.如果返回true，并且滑动事件交给子View处理，那么子View将接收不到ACTION_UP事件，子View的onClick事件也无法触发。而父View不一样，如果父View在ACTION_MOVE中开始拦截事件，那么后续ACTION_UP也将默认交给父View处理！</p></blockquote><h2 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h2><p>父容器不拦截任何事件，所有事件都传递给子元素，根据子元素对事件的消耗情况判断是否交由父容器处理。</p><p><strong>与Android中事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作</strong></p><p><strong>需要重写子元素的diapatchTouchEvent方法</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);<span class="comment">//不允许父元素拦截事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - lastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - lastY;</span><br><span class="line">                <span class="keyword">if</span>(  *父容器需要此类点击事件*  ){</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);  <span class="comment">//将事件传递给父元素</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>父元素要默认拦截除了ACTION_DOWN以外的其他事件</strong>，这样当子元素调用parent.requestDisallowInterceptTouchEvent（false）方法时（即子元素不对该事件进行处理，交由父容器处理），父元素才能继续拦截所需事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>为什么父容器不能拦截ACTION_DOWN事件呢？</p><p>因为<strong>ACTION_DOWN事件不受FLAG_DISALLOW_INTERCEPT这个标记位的控制</strong>，所以一旦父容器拦截了ACTION_DOWN事件，则所有事件都无法传递到子元素中去。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="1-场景一"><a href="#1-场景一" class="headerlink" title="1.场景一"></a>1.场景一</h2><h3 id="外部拦截"><a href="#外部拦截" class="headerlink" title="外部拦截"></a>外部拦截</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理滑动冲突</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span> <span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                intercept = <span class="keyword">false</span>;</span><br><span class="line">                Log.d(<span class="string">"this"</span>,<span class="string">" false"</span>);</span><br><span class="line">                <span class="keyword">if</span>(!scroller.isFinished()) {</span><br><span class="line">                    scroller.abortAnimation();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - lastInterceptX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - lastInterceptY;</span><br><span class="line">                <span class="comment">//viewGroup拦截水平滑动</span></span><br><span class="line">                <span class="keyword">if</span>(Math.abs(deltaX) - Math.abs(deltaY) &gt; <span class="number">0</span>){</span><br><span class="line">                    intercept = <span class="keyword">true</span>;</span><br><span class="line">                    Log.d(<span class="string">"this"</span>,<span class="string">"true"</span>);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    intercept = <span class="keyword">false</span>;</span><br><span class="line">                    Log.d(<span class="string">"this"</span>,<span class="string">"false"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                intercept = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        lastX = x;</span><br><span class="line">        lastY = y;</span><br><span class="line">        lastInterceptX = x;</span><br><span class="line">        lastInterceptY = y;</span><br><span class="line">        <span class="keyword">return</span> intercept;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="内部拦截"><a href="#内部拦截" class="headerlink" title="内部拦截"></a>内部拦截</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子元素重写的ListView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: {<span class="comment">//不允许父布局拦截</span></span><br><span class="line">                mHorizontalView1.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: {</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) {<span class="comment">//要让父布局拦截</span></span><br><span class="line">                    mHorizontalView1.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父元素HorizontalView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span> <span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN){</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">if</span>(!scroller.isFinished()){</span><br><span class="line">                scroller.abortAnimation();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>由于内部拦截比较复杂，一般不推荐使用。</p><p>未完待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rxjava笔记</title>
      <link href="/2021/07/31/Rxjava%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/31/Rxjava%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ftp.bmp.ovh/imgs/2021/07/2d246025850df29b.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/c9c97ebe6c5339f7.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/5b634956e63e2778.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/f7d85b4c5a31f3fc.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/ea959b00ad8cee3e.png"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/c428a326f23730f1.png"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/297b474435eac378.png"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/91e4e4b55ad1c010.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀表达式及计算</title>
      <link href="/2021/07/16/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%AE%A1%E7%AE%97/"/>
      <url>/2021/07/16/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="概念与表示"><a href="#概念与表示" class="headerlink" title="概念与表示"></a>概念与表示</h2><h3 id="对表达式的记法"><a href="#对表达式的记法" class="headerlink" title="对表达式的记法"></a>对表达式的记法</h3><p>前缀表达式、中缀表达式、后缀表达式（逆波兰式）它们都是对表达式的记法。它们之间的区别在于运算符相对与操作数的位置不同：前缀表达式的运算符位于与其相关的操作数之前；中缀和后缀同理。后缀表达式又称逆波兰式是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式形式，不需要括号来标识操作符的优先级。</p><span id="more"></span><p>举例：</p><p>(3 + 4) × 5 - 6 就是中缀表达式<br>- × + 3 4 5 6 前缀表达式<br>3 4 + 5 × 6 - 后缀表达式</p><h3 id="为何使用后缀表达式？"><a href="#为何使用后缀表达式？" class="headerlink" title="为何使用后缀表达式？"></a>为何使用后缀表达式？</h3><p>中缀表达式是人们常用的算术表示方法。虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。</p><h2 id="中缀到后缀的表示"><a href="#中缀到后缀的表示" class="headerlink" title="中缀到后缀的表示"></a>中缀到后缀的表示</h2><h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><p>需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为存放结果（逆波兰式）的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p><p>（1）若取出的字符是操作数，则分析出完整的运算数，该操作数直接送入S2栈。</p><p>（2）若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果该运算符(不包括括号运算符)优先级高于S1栈栈顶运算符（包括左括号）优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符送入S1栈。</p><p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p><p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次送入S2栈，此时抛弃“（”。</p><p>（5）重复上面的1~4步，直至处理完所有的输入字符。</p><p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p><p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算</p><p>举例：</p><img src="https://i.bmp.ovh/imgs/2021/07/9754479463989414.png" style="zoom:33%;"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCharStack</span> </span>{<span class="comment">//自定义的栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCharStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.maxSize = size;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> value)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(top &lt; maxSize-<span class="number">1</span>){</span><br><span class="line">            array[++top] = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出栈顶数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array[top--];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问栈顶数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array[top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">peekN</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了便于后面分解展示栈中的内容，我们增加了一个遍历栈的方法(实际上栈只能访问栈顶元素的)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayStack</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.print(<span class="string">"Stack(bottom--&gt;top):"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; top+<span class="number">1</span>; i++){</span><br><span class="line">            System.out.print(peekN(i));</span><br><span class="line">            System.out.print(<span class="string">' '</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">StackToString</span><span class="params">()</span></span>{</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; top+<span class="number">1</span>; i++){</span><br><span class="line">            str.append(peekN(i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (top == -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (top == maxSize-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成逆波兰表达式的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfixToSuffix</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> MyCharStack s1;<span class="comment">// 定义运算符栈</span></span><br><span class="line">    <span class="keyword">private</span> MyCharStack s2;<span class="comment">// 定义存储结果栈</span></span><br><span class="line">    <span class="keyword">private</span> String input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造方法，参数为输入的中缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfixToSuffix</span><span class="params">(String in)</span> </span>{</span><br><span class="line">        input = in;</span><br><span class="line">        s1 = <span class="keyword">new</span> MyCharStack(input.length());</span><br><span class="line">        s2 = <span class="keyword">new</span> MyCharStack(input.length());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中缀表达式转换为后缀表达式，将结果存储在栈中返回，逆序显示即后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyCharStack <span class="title">doTrans</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length(); j++) {</span><br><span class="line">            <span class="comment">/*显示转化的过程</span></span><br><span class="line"><span class="comment">            System.out.print("s1栈元素为：");</span></span><br><span class="line"><span class="comment">            s1.displayStack();</span></span><br><span class="line"><span class="comment">            System.out.print("s2栈元素为：");</span></span><br><span class="line"><span class="comment">            s2.displayStack();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">char</span> ch = input.charAt(j);</span><br><span class="line">            <span class="comment">//System.out.println("当前解析的字符:" + ch);</span></span><br><span class="line">            <span class="keyword">switch</span> (ch) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    gotOper(ch, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'×'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'÷'</span>:</span><br><span class="line">                    gotOper(ch, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    s1.push(ch);<span class="comment">// 如果当前字符是'(',则将其入栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    gotParen(ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 1、如果当前解析的字符是操作数，则直接压入s2</span></span><br><span class="line">                    s2.push(ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }<span class="comment">// end switch</span></span><br><span class="line">        }<span class="comment">// end for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    }</span><br><span class="line">、                                   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gotOper</span><span class="params">(<span class="keyword">char</span> opThis, <span class="keyword">int</span> prec1)</span> </span>{<span class="comment">//正在解析的字符和其优先级</span></span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">char</span> opTop = s1.pop();<span class="comment">//将这个运算符和栈顶的运算符准备进行优先级进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (opTop == <span class="string">'('</span>) {<span class="comment">// 如果栈顶是'(',直接将操作符压入s1</span></span><br><span class="line">                s1.push(opTop);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {<span class="comment">//算出栈顶元素的优先级</span></span><br><span class="line">                <span class="keyword">int</span> prec2;</span><br><span class="line">                <span class="keyword">if</span> (opTop == <span class="string">'+'</span> || opTop == <span class="string">'-'</span>) {</span><br><span class="line">                    prec2 = <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    prec2 = <span class="number">2</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (prec2 &lt; prec1) {<span class="comment">// 如果当前运算符比s1栈顶运算符优先级高，则将运算符压入s1</span></span><br><span class="line">                    s1.push(opTop);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果当前运算符与栈顶运算符相同或者小于优先级别，那么将S1栈顶的运算符弹出并压入到S2中</span></span><br><span class="line">                    <span class="comment">// 并且要再次再次转到while循环中与 s1 中新的栈顶运算符相比较；</span></span><br><span class="line">                    s2.push(opTop);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }<span class="comment">// end while</span></span><br><span class="line">        <span class="comment">// 如果s1为空，则直接将当前解析的运算符压入s1</span></span><br><span class="line">        s1.push(opThis);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前字符是 ')' 时，如果栈顶是'(',则将这一对括号丢弃，否则依次弹出s1栈顶的字符，压入s2，直到遇到'('</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gotParen</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">char</span> chx = s1.pop();</span><br><span class="line">            <span class="keyword">if</span> (chx == <span class="string">'('</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                s2.push(chx);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><p>新建一个表达式,如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostFix</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">evalPostFix</span><span class="params">(String token)</span> </span>{</span><br><span class="line">        Stack&lt;Double&gt; s = <span class="keyword">new</span> Stack&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">double</span> a, b, result = <span class="number">0.0</span>;<span class="comment">//ab是计算过程的中间变量，result是入栈时的变量</span></span><br><span class="line">        <span class="keyword">boolean</span> isNumber;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; token.length() - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                isNumber = <span class="keyword">true</span>;</span><br><span class="line">                result = Double.parseDouble(token);<span class="comment">//若输入字符不是数字，肯定报异常，即让布尔类型为false</span></span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                isNumber = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isNumber)<span class="comment">//如果是数字，那么就入栈</span></span><br><span class="line">                s.push(result);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果是运算符，那么就栈顶出两个数字，计算后再入栈</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">switch</span> (token.charAt(<span class="number">0</span>)) {</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b + a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b - a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'÷'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b / a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'×'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b * a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }<span class="comment">//当循环结束时，栈里只剩下一个元素</span></span><br><span class="line">        <span class="keyword">return</span> s.peek();<span class="comment">//返回栈顶元素，并不删除</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成逆波兰表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String is)</span> </span>{</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        String[] s = is.split(<span class="string">""</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, s);</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : list) {</span><br><span class="line">        <span class="comment">//使用正则表达式如果是数字</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) {</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//pop出两个数，并运算，在入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) {</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) {</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"×"</span>)) {</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"÷"</span>)) {</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line"><span class="comment">//把结果压入栈中</span></span><br><span class="line">                stack.push(<span class="string">""</span> + res);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"><span class="comment">//最后停留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/06/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>即将所需排序的数组分为有序和无序两个部分且有序区在前。每次从无序区中取出一个元素插到有序区的适当位置。</p><p>如果需要排序的元素插入有序区的中间，则在插入元素后有序区的每一位元素后移。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法一：交换元素值*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;         <span class="comment">//用来存储下一个要排序的元素</span></span><br><span class="line"><span class="keyword">int</span> sorted;       <span class="comment">//有序区的长度</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; n ; i++){<span class="comment">//从第二个元素开始排序</span></span><br><span class="line">sorted = i<span class="number">-1</span>;        <span class="comment">//有序区从头到将要排序的元素的前一个</span></span><br><span class="line">temp = p[i];         </span><br><span class="line"><span class="keyword">while</span>(sorted &gt;= <span class="number">0</span> &amp;&amp; p[sorted] &gt; temp){     <span class="comment">//从后向前比较，将比较和后移工作放在一个while循环里，因为不清楚循环次数所以使用while循环</span></span><br><span class="line">p[sorted+<span class="number">1</span>] = p[sorted];                <span class="comment">//从要排序的元素开始，前一个元素向后移</span></span><br><span class="line">sorted--;</span><br><span class="line">}</span><br><span class="line">p[sorted+<span class="number">1</span>] = temp;                         <span class="comment">//while循环结束即要排序的元素应在的位置</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法二：交换元素地址*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> sorted;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> *s = p,*e = p+n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( ; s &lt; e ; s++){</span><br><span class="line">sorted = s-p<span class="number">-1</span>;</span><br><span class="line">temp = *s;</span><br><span class="line"><span class="keyword">while</span>(sorted &gt;= <span class="number">0</span> &amp;&amp; *(p+sorted) &gt; temp){</span><br><span class="line">*(p+sorted+<span class="number">1</span>) = *(p+sorted);</span><br><span class="line">sorted--;</span><br><span class="line">}</span><br><span class="line">*(p+sorted+<span class="number">1</span>) = temp;</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><img src="https://ftp.bmp.ovh/imgs/2021/06/fd95b517223f9fc2.png" style="zoom:50%;"><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是利用递归不断将数组分成两份直到分成每个数组一个元素。然后将分好的有序小数组两两比较进行合并。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> temp[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> l_pos = left; <span class="comment">//用来存储归并的两个数组中左半部分的首元素</span></span><br><span class="line"><span class="keyword">int</span> r_pos = mid+<span class="number">1</span>;<span class="comment">//用来存储归并的两个数组中右半部分的首元素</span></span><br><span class="line"><span class="keyword">int</span> pos = left;<span class="comment">//用来存储已经排序好的元素位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l_pos &lt;= mid &amp;&amp; r_pos &lt;= right){<span class="comment">//当两个数组中有剩余元素时</span></span><br><span class="line"><span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos]){<span class="comment">//将两个有序数组合并</span></span><br><span class="line">temp[pos++] = arr[l_pos++];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">temp[pos++] = arr[r_pos++];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l_pos &lt;= mid){<span class="comment">//如果只有左数组有剩余元素则直接填充</span></span><br><span class="line">temp[pos++] = arr[l_pos++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(r_pos &lt;= right){<span class="comment">//如果只有右数组有剩余元素则直接填充</span></span><br><span class="line">temp[pos++] = arr[r_pos++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right){<span class="comment">//将归并的这一部分复制到元素组中</span></span><br><span class="line">arr[left] = temp[left];</span><br><span class="line">left++; </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> temp[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(left &lt; right){<span class="comment">//如果没有划分成只剩一个元素的数组，就继续进行递归划分</span></span><br><span class="line"><span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;<span class="comment">//设置中间值</span></span><br><span class="line">mergeSort(arr,temp,left,mid);<span class="comment">//分别划分左半部分</span></span><br><span class="line">        mergeSort(arr,temp,mid+<span class="number">1</span>,right);<span class="comment">//和右半部分</span></span><br><span class="line">merge(arr,temp,left,mid,right); <span class="comment">//对划分好的数组进行合并</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showArr</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>{<span class="comment">//打印数组</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i++){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//分配暂时存储的数组</span></span><br><span class="line">showArr(arr,n);</span><br><span class="line"><span class="keyword">if</span>(temp){</span><br><span class="line">mergeSort(arr,temp,<span class="number">0</span>,n<span class="number">-1</span>);<span class="comment">//如果成功分配则进行排序</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR!"</span>);</span><br><span class="line">}</span><br><span class="line">showArr(arr,n);</span><br><span class="line"></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配KMP算法</title>
      <link href="/2021/06/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8DKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8DKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h1><p>给定一行字符串文本为主串，另一个字符串为模式串，在主串中查找模式串首次出现的位置，并返回其位置下标。</p><h2 id="蛮力法（BF）"><a href="#蛮力法（BF）" class="headerlink" title="蛮力法（BF）"></a>蛮力法（BF）</h2><p>即依次比较主串和模式串的每一个字母，碰见不匹配的字母时，主串和模式串从头右移一位重新匹配，直至成功或遍历完成。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> i,k,m;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="built_in">strlen</span>(S) - j ; i++ ){</span><br><span class="line">k = i ; </span><br><span class="line">m = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(k &lt;= i + j){</span><br><span class="line"><span class="keyword">if</span>( S[k++] != T[m++] )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>( k == i+j ){</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">char</span> S[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(S[i] != <span class="string">'\0'</span> &amp;&amp; T[j] != <span class="string">'\0'</span>){</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j]){</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">index++;</span><br><span class="line">i = index; </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(T[j] == <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="求字符串相等最大真前后缀"><a href="#求字符串相等最大真前后缀" class="headerlink" title="求字符串相等最大真前后缀"></a>求字符串相等最大真前后缀</h2><p>字符串的真前/后缀指不包括字符串自身的前缀/后缀。给定一个字符串，编写函数，求解字符串T所有前缀子串（包括自己）的最大相等真前后缀的长度，并存入next数组中。</p><h3 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h3><p>从长度为1开始判断，长度为1时输出0；长度为n（n&gt;=2），判断前n-1个字符和后n-1个字符是否相同，若不相同则减小比较的长度。知道找出相等真前后缀为止。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/dde53e3bd256248f.png" style="zoom:33%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxAffixLength</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">int</span> next[],<span class="keyword">int</span> length)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i,j,len;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,length*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> ; T[i] != <span class="string">'\0'</span> ; i++ ){<span class="comment">//计算[0,i]的最大真前后缀的长度 </span></span><br><span class="line"><span class="keyword">for</span>( len = i<span class="number">-1</span> ; len &gt;= <span class="number">1</span> ; len-- ){</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; len ; j++ ){ <span class="comment">//比较[0,len-1]和[i-len+1,i] </span></span><br><span class="line"><span class="keyword">if</span>( T[j] != T[i-len+j+<span class="number">1</span>] )  <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>( j == len ){</span><br><span class="line">next[i] = len;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="根据已求求下一个"><a href="#根据已求求下一个" class="headerlink" title="根据已求求下一个"></a>根据已求求下一个</h3><img src="https://ftp.bmp.ovh/imgs/2021/06/64b47a8e33b37c56.png" style="zoom:40%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PMT</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">int</span> next[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> i ,j ;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,NUM*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T[<span class="number">0</span>] == T[<span class="number">1</span>]){</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; T[i] != <span class="string">'\0'</span> ; i++ ){  <span class="comment">//计算【0，i】的最大真前后缀的长度 </span></span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span>( j != <span class="number">0</span> ){</span><br><span class="line"><span class="keyword">if</span>( T[i] == T[next[j<span class="number">-1</span>]] ){</span><br><span class="line">next[i] = next[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">j = next[j<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>有效利用已匹配的前缀，减少指针回溯。</p><p>整体思路：在已匹配的前缀当中寻找到最长可匹配后缀子串和最长可匹配前缀子串，在下一轮中直接把两者对齐，从而实现模式串的快速移动。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/aa039bb509dc3ba5.png" style="zoom:80%;"><p>​                                                                                                                                                                （图源知乎）</p><p>next数组是我们上面求的最大真前后缀数组进行处理后得到的。</p><p>处理：将每一位的最大真前后缀字符数向后移一格。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法主体逻辑。str是主串，pattern是模式串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[],<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//主循环，遍历主串字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(S); i++) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; S[i] != T[j]) </span><br><span class="line">        {</span><br><span class="line">            j = next[j];<span class="comment">//遇到坏字符时，查询next数组并改变模式串的起点继续与主串进行匹配，直到移到子串起始字符不成功，则主串继续移动进行匹配 </span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) {</span><br><span class="line">            j++;</span><br><span class="line">        }<span class="keyword">if</span> (j == <span class="built_in">strlen</span>(T)) {<span class="comment">//匹配成功，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> i - <span class="built_in">strlen</span>(T) + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯和递归算法总结</title>
      <link href="/2021/05/30/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2021/05/30/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="分书问题"><a href="#分书问题" class="headerlink" title="分书问题"></a>分书问题</h2><img src="https://ftp.bmp.ovh/imgs/2021/06/9d4613e7aa04fd0d.png" style="zoom:33%;"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>(1) 定义一个整型的二维数组，将表中的<strong>阅读喜好</strong>用初始化方法赋给这个二维数组。可定义：</p><p>int like[5][5] = { {0,0,1,1,0}, {1,1,0,0,1}, {0,1,1,0,1}, {0,0,0,1,0}, {0,1,0,0,1} }; </p><p>(2) 定义一个整型一维数组book[5]，用来<strong>记录书是否已被选用</strong>。用下标作为5本书的编号，被选过元素值为1，未被选过元素值为0，初始化皆为0。</p><p>int book[5] = {0,0,0,0,0};</p><p>(3) 画出思路图。</p><p>① 定义试着给第i人分书的函数Try(i)，i = 0,1,2,3,4。</p><p>② 试着给第i个人分书，先试分0号书，再分1号书，分2号书，……，因此有一个与结点，让j表示书，j=0，1，2，3，4。</p><p>③条件c是由两部分“与”起来的，“第i个人喜欢j书，且j书尚未被分走”。满足这个条件是i人能够得到j书的条件。 </p><p>④ 如果不满足c条件，则什么也不做，这是直接可解结点。、</p><p>⑤ 满足c条件，做三件事：<br>      第一件事：将j书分给i，用一个数组take[i]=j,记住书j给了i，同时记录j书已被选用，book[j]=1.<br>      第二件事：查看i是否为4，如果不为4，表示尚未将所有5个人所要的书分完，这时应递归再试下一个人，即Try(i+1)。若果i==4，则应先使方案数n=n+1，然后输出第n个方案下的每个人所得之书。<br>      第三件事：回溯。让第i人退回j书，恢复j书尚未被选的标志，即book[j]=0.这是在已输出第n个方案之后，去寻找下一个分书方案所必需的。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/11064001369b467f.png" style="zoom:33%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>] = { {<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>}, {<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>}, {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>}, {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>}, {<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>} }; <span class="comment">//表示书的喜好情况 </span></span><br><span class="line"><span class="keyword">int</span> book[<span class="number">5</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};  <span class="comment">//表示书是否分走 </span></span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>] = {<span class="number">0</span>};  <span class="comment">//表示分书情况 </span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Try</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j,k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">5</span> ; j++){ <span class="comment">//表示书号 </span></span><br><span class="line"><span class="keyword">if</span>(like[i][j] == <span class="number">1</span> &amp;&amp; book[j] == <span class="number">0</span>){<span class="comment">//这人喜欢这书且书还没被分走 </span></span><br><span class="line">take[i] = j;<span class="comment">//记录该人拿走该书</span></span><br><span class="line">book[j] = <span class="number">1</span>;<span class="comment">//记录该书已被分走 </span></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">4</span>){ <span class="comment">//所有人都分好书</span></span><br><span class="line">n++;<span class="comment">//方案数增加，准备打印分数方案</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"==========第%d个方案是==========\n"</span>,n);</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; <span class="number">5</span> ; k++){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个人拿的第%d本书\n"</span>,k+<span class="number">1</span>,take[k]+<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{<span class="comment">//书还没分完 </span></span><br><span class="line">Try(i+<span class="number">1</span>);<span class="comment">//满足这个人的需求后，继续尝试分后边的书 </span></span><br><span class="line">}</span><br><span class="line">book[j] = <span class="number">0</span>;<span class="comment">//回溯时将书退回</span></span><br><span class="line">}<span class="comment">//如果没有找到就继续尝试下一本书 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">Try(<span class="number">0</span>);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将整个问题拆解成几个小问题，分步解决。</p><p>1.判断是否可以放下皇后棋子（同行同列同对角线上还没有棋子）</p><p>2.try函数用来实现递归和回溯</p><p>3.打印结果</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> place[<span class="number">8</span>] = {<span class="number">0</span>};<span class="comment">//皇后放置的位置</span></span><br><span class="line"><span class="keyword">int</span> snum = <span class="number">0</span>;<span class="comment">//方法总数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"===第%d个方案\n"</span>,++snum);</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d行的皇后放置在第%d列\n"</span>,i,place[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; <span class="number">8</span> ; k++ ){</span><br><span class="line"><span class="keyword">if</span>(place[k] == j || <span class="built_in">abs</span>(place[k] - j ) == <span class="built_in">abs</span>(k - i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">7</span>){</span><br><span class="line">showResult();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ ){</span><br><span class="line"><span class="keyword">if</span>(canPlace(i,j)){ </span><br><span class="line">place[i] = j;</span><br><span class="line"><span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">place[i] = <span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">try</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对于法一，法二使用的二维数组更加直观</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> chessboard[<span class="number">8</span>][<span class="number">8</span>] = {<span class="number">0</span>};<span class="comment">//棋盘的位置是否有元素 </span></span><br><span class="line"><span class="keyword">int</span> snum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isDanger</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>{ </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){<span class="comment">//row</span></span><br><span class="line"><span class="keyword">if</span>(chessboard[row][i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){<span class="comment">//column</span></span><br><span class="line"><span class="keyword">if</span>(chessboard[i][col] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ ){</span><br><span class="line"><span class="keyword">if</span>( chessboard[i][j] == <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(i-row) == <span class="built_in">abs</span>(j-col) )</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"====第%d个方案====\n"</span>,++snum);</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ ){</span><br><span class="line"><span class="keyword">if</span>( chessboard[i][j] == <span class="number">1</span> )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"chessboard[%d][%d]\n"</span>,i,j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eightQueen</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="keyword">if</span>( row &gt; <span class="number">7</span> ){</span><br><span class="line">printResult();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>( col = <span class="number">0</span> ; col &lt; <span class="number">8</span> ; col++ ){</span><br><span class="line"><span class="keyword">if</span>(isDanger(row,col)){</span><br><span class="line">chessboard[row][col] = <span class="number">1</span>;</span><br><span class="line">eightQueen( row + <span class="number">1</span> );</span><br><span class="line">chessboard[row][col] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">eightQueen(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>每个物品有两种状态及放入和未放入。我们假设除最后一个以外的前面已经是最优解，再找出最后一个的最优解即可。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/25f4115791e1d802.png" style="zoom:33%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">5</span>] = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>};</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">5</span>] = {<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">int</span> value1,value2;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(weight[i] &lt;= j &amp;&amp; i != <span class="number">-1</span>){   <span class="comment">//物体质量小于背包容量且不是无效数据 </span></span><br><span class="line">value1 = <span class="built_in">exp</span>(i<span class="number">-1</span>,j-weight[i]) + value[i];      <span class="comment">//这个物体放入后的价值</span></span><br><span class="line">value2 = <span class="built_in">exp</span>(i<span class="number">-1</span>,j);   <span class="comment">//不放的价值</span></span><br><span class="line">value1 &gt; value2 ? (max = value1) : (max = value2); <span class="comment">//比较选择放入或不放</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line">result = <span class="built_in">exp</span>(<span class="number">4</span>,<span class="number">10</span>);<span class="comment">//需要检测的物体个数，背包容量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="素数环问题"><a href="#素数环问题" class="headerlink" title="素数环问题"></a>素数环问题</h2><p>用1~n共n个不重复整数构造一个环形结构，使相邻两个数之和为素数。</p><p>如下图是一个n=6的素数环。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/3d0e41fcccd808f1.png" style="zoom:50%;"><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>同样把问题拆解成几个负责不同功能的函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//判断是否为素数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,k;</span><br><span class="line">k = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> n)</span>  <span class="comment">//传入数组首指针，要放置的位置，要放置的数值，数组大小，函数用来检查能不能放入该数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k,flag;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;i;k++)<span class="comment">//检查前面是否已经使用过该数</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(p[k]==j)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">flag = isPrime(j+p[i<span class="number">-1</span>]); <span class="comment">//若放置则与前数和是否为素数</span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span> &amp;&amp; i==n<span class="number">-1</span>)     <span class="comment">//若是最后一个位置则需要和第一个数构成素数环</span></span><br><span class="line">{</span><br><span class="line">flag = isPrime(j+p[<span class="number">0</span>]); </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n)</span>  <span class="comment">//传入数组首地址和数组大小</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****第%d个解****\n"</span>,++count);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeCycle</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j,k;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);  <span class="comment">//动态开辟数组空间</span></span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">//数组置零</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//先给第0号位赋上值 ，因为是环状结构，为避免出现相同结构的解，将第一个元素固定。</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=p[i]+<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//找出能在该位置放置的满足条件的第一个数。如果是第一次寻找，则j从1开始，若是回溯，则从上次确定的值开始</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(canPlace(p,i,j,n)==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">p[i] = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(j&gt;n)   <span class="comment">//如果上一个循环正常结束，即该位置没有可放置的数</span></span><br><span class="line">{</span><br><span class="line">p[i--] = <span class="number">0</span>;   <span class="comment">//p[i]=0;i--;回溯至上一个位置,这个位置置0。</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>)   <span class="comment">//如果最后一个位置的数也放置完毕，则输出结果，并将前一个数置零以便寻找下一种解情况</span></span><br><span class="line">{</span><br><span class="line">showResult(p,n);</span><br><span class="line">p[i--] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>              <span class="comment">//如果还没有放置完数，则将i++继续进行大循环。</span></span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放空间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"finished\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input an integer\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">primeCycle(n);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>待编辑…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于回调和反射的简单分享</title>
      <link href="/2021/05/22/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E4%BA%AB/"/>
      <url>/2021/05/22/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">(Door door)</span></span>{</span><br><span class="line">        door.open(); </span><br><span class="line">        System.out.println(<span class="string">"新的一天开始了"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>{</span><br><span class="line">        System.out,println(<span class="string">"门被打开了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在打印“新的一天开始了”内容时，door.open()方法已经执行结束。（可能会造成阻塞问题）</p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">(Door door)</span></span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable(){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">                door.open();  </span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        System.out.println(<span class="string">"新的一天开始了"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>{</span><br><span class="line">        System.out,println(<span class="string">"门被打开了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将调用放在一个新的线程中，后边的操作将不再依赖于调用方法的结束。（解决同步调用的阻塞问题）</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>双向调用模式</p><p><em>A callback is a function this is passed as an argument to another function and is executed after its patent function has completed.</em></p><p><em>回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行</em></p><p>回调的思想是：<strong>一.类A的a()方法调用类B的b()方法</strong></p><p>​                           <strong>二.类B的b()方法执行完毕主动调用类A的callback()方法</strong></p><p>原理：首先创建一个回调对象，然后再创建一个控制器对象，将回调对象需要被调用的方法告诉控制器对象，控制器对象负责检查某个场景是否出现或某个条件是否满足，当满足时，自动调用回调对象的方法。</p><h3 id="例一："><a href="#例一：" class="headerlink" title="例一："></a>例一：</h3><p>情景：老板A对员工B说，我现在交给你一个任务，并且我把我的电话号码给你，你一旦完成任务就给我打电话。</p><p>1.创建一个回调接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptEvent</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.创建回调接口的实现类，即本例中的老板类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">CallBack</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话给老板，告知已经完成工作了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.创建控制类，也就是本例中的员工对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    CallBack callBack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(CallBack callBack)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.callBack=callBack;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"工作中...."</span>);</span><br><span class="line">        callBack.acceptEvent();<span class="comment">//接口实现类的对象调用接口中的方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>创建测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//创建控制器对象，将提供给他的回调对象传入</span></span><br><span class="line">        Employee employee=<span class="keyword">new</span> Employee(<span class="keyword">new</span> Boss());    <span class="comment">//传递一个实现接口的类的对象</span></span><br><span class="line">        <span class="comment">//启动控制器对象运行</span></span><br><span class="line">        employee.doWork();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在本例中，如果员工的工作结果可能不止向一类人传递，比如还会给经理、测试等人传递结果。这时我们可以将接收结果这个方法看做一种公共需求，接收到结果后后续处理操作也不一样，我们可以将这个方法定义到接口中，再在具体的类中进行实现。</p><h3 id="例二：（安卓中的实例）"><a href="#例二：（安卓中的实例）" class="headerlink" title="例二：（安卓中的实例）"></a>例二：（安卓中的实例）</h3><p>在android中回调机制被大量的使用。比如，在Activity中定义了很多生命周期的不同状态要调用的方法，这些方法都是空实现，系统框架要调用，用户也要调用来实现。</p><p>　　举个简单的例子就是Button的点击响应事件实现机制</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.view.View;  </span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;  </span><br><span class="line"><span class="keyword">import</span> android.widget.Button;  </span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 这个就相当于Class A </span></span><br><span class="line"><span class="comment"> * 实现了 OnClickListener接口</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>{  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Class A 包含Class B(View)的引用</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> Button button;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        button = findViewById(R.id.button1);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 b </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用户点击Button时调用的回调函数，你可以做你要做的事  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{  </span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"OnClick"</span>, Toast.LENGTH_LONG).show();  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="例三：（还是安卓实例）"><a href="#例三：（还是安卓实例）" class="headerlink" title="例三：（还是安卓实例）"></a>例三：（还是安卓实例）</h3><p> 点击文本框弹出对话框，将输入的文字显示在文本框中。</p><p><a href="https://github.com/liuyuxin-cloud/Android/tree/main/callbackdemo">https://github.com/liuyuxin-cloud/Android/tree/main/callbackdemo</a></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p><p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p><p><strong>反射机制使java具有动态特性</strong></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><img src="https://ftp.bmp.ovh/imgs/2021/06/d693bb0688d7f75d.png" style="zoom:33%;"><p>关于java.lang.Class 类的理解</p><p>​    将类编译生成字节码文件(.class)再用(java.exe)命令对每个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。</p><p>加载到内存中的类称为运行时类，它们是Class类的实例。</p><p>（java万物皆对象  我们的自定义类是Class类的对象）</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1、反编译：.class–&gt;.java</p><p>2、通过反射机制访问java对象的属性，方法，构造方法等</p><p>3、当我们在使用IDE,比如Ecplise，IntelliJ IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p><p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p><p>例子：</p><img src="https://ftp.bmp.ovh/imgs/2021/06/af8de99466562b90.png" style="zoom:33%;"><p>反射前对于自定义类的操作：</p><p>1.通过构造器实例化对象</p><p>2.通过对象调用内部属性、方法</p><p>3.在类外部不可以通过对象调用内部私有(private)结构（封装性的限制）</p><p>反射后：</p><p>1.通过反射创建类的对象</p><p>2.通过反射调用对象指定的属性、方法</p><p>3.通过反射可调用类的私有结构</p><p>什么时候使用反射？</p><p>1.具有动态性时</p><p>2.编译时不确定造哪个对象时</p><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>Java.lang.Class;</p><p>Java.lang.reflect.Constructor;</p><p>Java.lang.reflect.Field;</p><p>Java.lang.reflect.Method;</p><p>Java.lang.reflect.Modifier;</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>1、获得Class：主要有三种方法：</strong></p><p>（1）Object–&gt;getClass</p><p>（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性</p><p>（3）通过class类的静态方法：forName(String className)（最常用）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">Class stuClass2 = Student.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式获取Class对象</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">Class stuClass3 = Class.forName(<span class="string">"fanshe.Student"</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">} <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2、判断是否为某个类的示例：</strong></p><p>一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>3、创建实例：通过反射来生成对象主要有两种方法：</strong></p><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;Object str = c.newInstance();</span><br></pre></td></tr></tbody></table></figure><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String的Class对象</span></span><br><span class="line">Class&lt;?&gt; str = String.class;<span class="comment">//通过Class对象获取指定的Constructor构造器对象</span></span><br><span class="line">Constructor constructor=c.getConstructor(String.class);<span class="comment">//通过参数判断指定的构造器</span></span><br><span class="line"><span class="comment">//根据构造器创建实例：</span></span><br><span class="line">Object obj = constructor.newInstance(“hello reflection”);</span><br></pre></td></tr></tbody></table></figure><p><strong>4、通过反射获取构造方法并使用：</strong></p><p>（1）批量获取的方法：<br>public Constructor[] getConstructors()：所有”公有的”构造方法<br>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p><p>（2）单个获取的方法，并调用：<br>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：<br>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p><p><a href="https://blog.csdn.net/a745233700/article/details/82893076">https://blog.csdn.net/a745233700/article/details/82893076</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python笔记</title>
      <link href="/2021/05/21/Python%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/21/Python%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="变量和简单数据类型"><a href="#变量和简单数据类型" class="headerlink" title="变量和简单数据类型"></a>变量和简单数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>引号括起来的都是字符串</strong></p><p><strong>修改大小写</strong></p><p>.title()                每个单词首字母大写</p><p>.upper()            全大写</p><p>.lower()             全小写</p><p><strong>在字符串中使用变量</strong></p><p>在字符串中插入变量的值，在前引号前加上f（format）在字符串内将插入的变量用{}括起。</p><p><strong>删除空白</strong></p><p>python能找出字符串开头和结尾多余的空白。</p><p>.rstrip()            删除结尾的空白（暂时）永久删除需关联到变量</p><p>.lstrip()                    开头</p><p>.strip()                     开头和结尾</p><h3 id="数"><a href="#数" class="headerlink" title="数"></a>数</h3><p><strong>整数</strong></p><p>**表示乘方运算</p><p><strong>浮点数</strong></p><p>结果包含的小数位数可能是不确定的</p><p>任意两个数相除时，结果总是浮点数。</p><p><strong>下划线</strong></p><p>可使用下划线将数字分组不会打印下划线</p><p><strong>赋值</strong></p><p>可同时给多个变量赋值</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y,z = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p><strong>常量</strong></p><p>python没有内置的常量类型，通常使用全大写来指出将某个变量视为常量。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>python用#注释一行</p><h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a>列表简介</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>用[]表示列表，用逗号分隔其中元素。</p><p>打印列表时会将[]一同打印。</p><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><p>添加索引     打印时不打印[]</p><p>索引从0开始</p><p>当索引为负数时，python将从列表最后一个元素开始访问。</p><h3 id="元素的增删改"><a href="#元素的增删改" class="headerlink" title="元素的增删改"></a>元素的增删改</h3><p>创建的列表大多是动态的。</p><p><strong>改</strong>        拿出索引，指定新值。</p><p><strong>增</strong>        1. 末尾（附加）         .append(‘ ‘)</p><p>​            2. 插入                        .insert(  <em>int</em> ,’ ‘)         指定新元素索引，将后方元素后移</p><p><strong>删</strong>        1. del语句                    del  <em>name</em>[<em>int</em>]        删除指定索引元素，后方元素前移</p><p>​            2. pop()方法                .pop()                      删除列表中元素并可继续使用。</p><p>​                                                                                  弹出列表末尾的元素。</p><p>​                                                 .pop(<em>int</em>)                  弹出任意位置的元素</p><p>​            3. remove()方法         .remove(‘ ‘)             根据值删除元素(也可继续使用这个值)</p><h3 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h3><p><strong>永久排序</strong>                    .sort()                                    按字母顺序</p><p>​                                   .sort(reverse=True)             按反字母顺序</p><p><strong>临时排序</strong>                    sorted(<em>name</em>)                       可临时按顺序或反顺序</p><p><strong>反转排列顺序</strong>            .reverse()                              永久性修改</p><p><strong>确定列表长度</strong>            len(<em>name</em>)                            </p><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><p><strong>for循环</strong>        for item in list_of_items:</p><p>​                            to do …</p><p>将对每个元素执行相同的操作，知道列表中的元素遍历结束。</p><h3 id="数字列表"><a href="#数字列表" class="headerlink" title="数字列表"></a>数字列表</h3><p><strong>函数range()</strong>                                    轻松生成一系列数：range(<em>int1</em>,<em>int2</em>)    # int1 ~ int2 - 1</p><p>​                                                                                            range(<em>int</em>)             #  0 ~ int - 1</p><p>​                                                         可指定生成数的步长：range(<em>int1</em>,<em>int2</em>,<em>int3</em>)        # 从int1开始每次增加int3直至大于等于int2</p><p><strong>使用range()创建数字列表</strong>            使用list()将range()结果转化为列表：<em>name</em> = list(range(<em>int</em>))</p><p><strong>进行简单计算</strong>                                  <em>numbers</em> = [<em>int1</em>,…,<em>intn</em>]            min(<em>number</em>)        #最小值</p><p>​                                                                                                             max(<em>number</em>)       #最大值</p><p>​                                                                                                             sum(<em>number</em>)       #求和</p><p><strong>列表解析</strong>                                        </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;[1,4,9,16,25,36,49,64,81,100]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用列表的一部分"><a href="#使用列表的一部分" class="headerlink" title="使用列表的一部分"></a>使用列表的一部分</h3><p><strong>切片</strong>                                            <em>name</em>[<em>int1</em> : <em>int2</em>]                    #索引由int1开始到int2-1结束</p><p>​                                                                                                    #省略int1时从头开始，省略int2时到末尾结束。可为负数。</p><p>​                                                                                                    #可使用for循环遍历</p><p><strong>复制列表</strong>                                    <em>new_list</em> = <em>name</em>[ : ]                #复制，将副本赋值给new_list</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>定义一系列不可修改的元素</p><p><strong>定义</strong>                                            <em>name</em> = (item1,…,itemn)    #使用（）定义元组  <strong>只有一个元素时要在后面加上逗号</strong></p><p><strong>遍历</strong>                                            使用for循环</p><p><strong>修改</strong>                                            重新定义整个元组</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><strong>基本格式</strong>                                        </p><p>​                                                                          if   <em>something</em> :</p><p>​                                                                                <em>to do…</em></p><p>​                                                                           elif  <em>something</em>:</p><p>​                                                                                <em>to do…</em></p><p>​                                                                           else :</p><p>​                                                                                <em>to do…</em></p><p><strong>检查多个条件</strong>                                                    使用and/or关键字</p><p><strong>检查特定值是否包含/不包含在列表中</strong>            ‘<em>item</em>‘ in <em>list_name</em> </p><p>​                                                                            ‘<em>item</em>‘ not in <em>list_name</em></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p><strong>简介</strong>                在python中，<strong>字典</strong>是一系列<strong>键值对</strong>。与<strong>键</strong>关联的<strong>值</strong>可以是数、字符串、列表乃至字典。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = {<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p><strong>访问字典中的值</strong>                    依次指定字典名和放在方括号内的键。                #<em>name</em>[‘<em>item</em>‘]</p><p><strong>添加键值对</strong>                            依次指定字典名和放在方括号内的键及赋值。    #<em>name</em>[‘<em>item</em>‘] = ‘<em>value</em>‘</p><p><strong>改</strong>                                           依次指定字典名和放在方括号内的键及修改值。#<em>name</em>[‘item’] = ‘<em>new value</em>‘</p><p><strong>删</strong>                                            del语句 依次指定字典名和放在方括号内的键。#del <em>name</em>[‘<em>item</em>‘]     </p><p><strong>由类似对象组成的字典</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = {</span><br><span class="line"><span class="string">'jen'</span>:<span class="string">'python'</span>,</span><br><span class="line"><span class="string">'sarah'</span>:<span class="string">'java'</span>,</span><br><span class="line"><span class="string">'edward'</span>:<span class="string">'c'</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>使用get()来访问值</strong>               当指定的键不存在时会出错，但在使用get()方法时会返回一个默认值。</p><p>​                                                #<em>name</em>.get(‘<em>item</em>‘,<em>default value</em>)默认值可不指定，将返回none</p><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p><strong>遍历所有键值对</strong>                    for循环                    #for key,value in <em>name</em>.items():</p><p>​                                                                                #key,value可以使用任意名称</p><p><strong>遍历所有键</strong>                            for循环                    #for key in <em>name</em>.keys():</p><p>​                                                                                #实际上返回一个列表，包含字典中所有键</p><p><strong>按特定顺序遍历所有键</strong>        for循环                    #可使用sorted()函数对keys进行排序</p><p><strong>遍历所有值</strong>                           for循环                    #for value in <em>name</em>.values():</p><p>​                                                                               #需要考虑剔除重复项时可使用set()方法  结果是一个不                                                                                    重复的列表</p><p>​                                                                               #可直接用{}创建集合，集合中元素不会重复。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p><strong>字典列表</strong>                                先创建几个字典，后将字典存储到列表中</p><p><strong>在字典中存储列表</strong>                将列表作为字典里的值；可使用二重循环遍历字典中的列表</p><p><strong>在字典中存储字典</strong>                嵌套在字典里的字典尽可能具有相同结构</p><h2 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h2><h3 id="函数input（）的工作原理"><a href="#函数input（）的工作原理" class="headerlink" title="函数input（）的工作原理"></a>函数input（）的工作原理</h3><p><strong>input(<em>string</em>)</strong>                        接收一个参数用来向用户显示的提示或说明。接收用户输入的字符串</p><p><strong>int()</strong>                                        将接收到的字符串类型的数字转化为int类型</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>设置退出条件</strong>                        while   <em>option</em></p><p><strong>使用标志</strong>                                while   <em>flag</em>    当要求很多条件满足时才继续运行时，可定义一个变量，用于判断整个程序是否处于活动状态。</p><p>​                                                #active = True 当有条件使active = False时退出循环。</p><p><strong>使用break、continue</strong></p><h3 id="使用while循环处理列表和字典"><a href="#使用while循环处理列表和字典" class="headerlink" title="使用while循环处理列表和字典"></a>使用while循环处理列表和字典</h3><p>for循环是一种遍历列表的有效方式，但<strong>不应在for循环中修改列表</strong>，在<strong>遍历列表同时修改</strong>时，使用while循环。</p><p><strong>在列表之间移动元素</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先，创建一个待验证的用户列表</span></span><br><span class="line"><span class="comment">#  和一个用于存储的已验证用户的空列表。</span></span><br><span class="line">unconfirmed_users = [<span class="string">'alice'</span>,<span class="string">'brain'</span>,<span class="string">'candace'</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证每一个用户，直到没有未验证的用户为止。</span></span><br><span class="line"><span class="comment">#  将每个经过验证的用户都移到已验证用户列表中</span></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = uncomfirmed_users.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Verifying user:<span class="subst">{current_user.title()}</span>"</span>)</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#显示所有已验证的用户</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n The following users have been confirmed:"</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    <span class="built_in">print</span>(confirmed_user.title())</span><br></pre></td></tr></tbody></table></figure><p><strong>删除为特定值的所有列表元素</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">'cat'</span>,<span class="string">'dog'</span>,<span class="string">'fish'</span>,<span class="string">'cat'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">pets.remove(<span class="string">'cat'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>def  <em>f_name</em>():                            def关键字定义函数</p><p>“””对函数作用的解释”””            文档字符串的注释</p><h3 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h3><p><strong>位置实参</strong>                                    根据函数中的形参位置对应实参</p><p><strong>关键字实参</strong>                                即用  <em>形参名= ‘实参 ‘</em>  指定</p><p><strong>返回值</strong>                                        直接  <em>return</em></p><p><strong>默认值</strong>                                        定义时可为参数设置默认值  <em>形参 = ‘ …’</em></p><p><strong>参数可选</strong>                                    当有参数可以不必传入时，将该参数定义在最后并用空串设为默认值</p><p><strong>返回字典</strong>                                    在方法中定义字典，return字典名</p><p><strong>传递列表</strong>                                    可将列表名作为参数传给函数</p><p><strong>禁止函数修改列表</strong>                    将列表的副本传给函数            <em>function_name(list_name[:])</em>    #切片表示法[:]创建列表的副本。</p><p><strong>传递任意数量的实参</strong>                只有一个形参 形参前加上星号*    <em>def  f_name(*params)</em>        #*代表让python创建一个名为params的空元                                                   组，并将所有接收到的值都封装进这个元组中</p><p><strong>使用任意数量关键字实参</strong>        在关键字形参前加上两个星号，代表让python创建一个空字典。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span>(<span class="params">first,last,**user_info</span>):</span></span><br><span class="line"><span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">user_info[<span class="string">'first_name'</span>] = first</span><br><span class="line">user_info[<span class="string">'last_name'</span>] = last</span><br><span class="line"><span class="keyword">return</span> user_info</span><br><span class="line"></span><br><span class="line">user_profile = bulid_profile(<span class="string">'albert'</span>,<span class="string">'einstein'</span>,</span><br><span class="line"> location = <span class="string">'princeton'</span></span><br><span class="line"> field = <span class="string">'physics'</span>)</span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">'location'</span> : <span class="string">'princeton'</span>, <span class="string">'field'</span> : <span class="string">'physics'</span>,<span class="string">'first_name'</span> : <span class="string">'albert'</span>,<span class="string">'last_name'</span> : <span class="string">'einstein'</span>}</span><br></pre></td></tr></tbody></table></figure><h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h3><p>import语句允许在当前运行的程序中使用模块中的代码。</p><p><strong>导入整个模块</strong>                            模块是扩展名为.py 的文件，import+<em>module_name</em> 即可导入模块并使用其中的函数</p><p>​                                                    #<em>module_name.fuction_name</em></p><p><strong>导入特定函数</strong>                            from  <em>module_name</em>  import  <em>function_0,function_1,function_2</em></p><p><strong>使用as给函数指定别名</strong>            要导入的函数的名称可能与程序中现有的名称冲突，或者因为函数名称太长，可指定独一无二的别名。</p><p>​                                                   #  <em>from module_name import function_name as nike_name</em></p><p><strong>给模块指定别名</strong>                        #  <em>import module_name as nike_name</em></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>#类名首字母大写</span></span><br><span class="line"><span class="class">"""创建类"""</span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">__init__</span>(<span class="params">self,*name,age*</span>)#相当于构造器 初始化属性 <span class="title">self</span>形参必须有且位于最前 每次创建实例时<span class="title">python</span>自动运行</span></span><br><span class="line">self.name = name        </span><br><span class="line">self.age = age            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name0</span>    #...        #...    </span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">function_name1</span>    #...        #...        </span></span><br></pre></td></tr></tbody></table></figure><h3 id="根据类创建实例"><a href="#根据类创建实例" class="headerlink" title="根据类创建实例"></a>根据类创建实例</h3><p>跟java类似                        instanse1 = class_name(params)</p><p>待编辑……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习第三次</title>
      <link href="/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E6%AC%A1/"/>
      <url>/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java复习第三次"><a href="#java复习第三次" class="headerlink" title="java复习第三次"></a>java复习第三次</h1><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>lambda表达式是一个<strong>可传递的代码块</strong>，可在以后执行一次或多次。lambda表示参数。</p><p>Lambda 允许把<strong>函数</strong>作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h3><p><strong>-&gt;</strong>    操作符将lambda表达式分为两个部分            左侧：lambda表达式的参数列表            右侧：lambda表达式所执行的功能即lambda体</p><p><strong>1.无参数，无返回值</strong></p><p>无参数仍要提供空括号，就像无方法参数一样。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>2.一个参数，无返回值</strong></p><p>当参数类型可推导得出时小括号可以省略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br><span class="line">x -&gt; System.out.println(x);</span><br></pre></td></tr></tbody></table></figure><p><strong>3.多个参数，有返回值</strong></p><p>当参数类型可推导得出时参数类型可省略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x – y ;</span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y ;  </span><br></pre></td></tr></tbody></table></figure><p><strong>4.只有一条语句</strong></p><p>大括号和return都可以省略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x – y ;</span><br></pre></td></tr></tbody></table></figure><p><strong>5.有多条语句</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x,y) -&gt; {</span><br><span class="line">System.out.println(<span class="string">"函数式接口"</span>);</span><br><span class="line"><span class="keyword">return</span> x - y ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口。</p><p><strong>是lambda表达式使用的前提</strong></p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p><strong>只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用</strong></p><p> <strong>对象::实例方法</strong>    objectName::instanceMethod                     将lambda的参数当做方法的参数使用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; sc = System.out::println;</span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line">Consumer&lt;String&gt; sc2 = (x) -&gt; System.out.println(x);</span><br><span class="line">sc.accept(<span class="string">"618, 狂欢happy"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>类::静态方法</strong>        ClassName::staticMethod                             将lambda的参数当做方法的参数使用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; sf = String::valueOf;</span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line">Function&lt;Integer, String&gt; sf2 = (x) -&gt; String.valueOf(x);</span><br><span class="line">String apply1 = sf.apply(<span class="number">61888</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>类::实例方法</strong>       ClassName::instanceMethod                        将lambda的第一个参数当做方法的调用者，其他的参数作为方法的参数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; sbp = String::equals;</span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line">BiPredicate&lt;String, String&gt; sbp2 = (x, y) -&gt; x.equals(y);</span><br><span class="line"><span class="keyword">boolean</span> test = sbp.test(<span class="string">"a"</span>, <span class="string">"A"</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>与方法引用类似，不过方法名为new</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] :: <span class="keyword">new</span><span class="comment">//等价x -&gt; new int[x]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>内部类：</strong> 所谓内部类就是在一个类内部进行其他类结构的嵌套操作。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。</p><p><strong>为什么使用？</strong></p><p>在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，<strong>间接解决类无法多继承引起的一系列问题</strong>。</p><p>例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> String str =<span class="string">"外部类中的字符串"</span>;</span><br><span class="line">    <span class="comment">//************************** </span></span><br><span class="line">    <span class="comment">//定义一个内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line">        <span class="keyword">private</span> String inStr= <span class="string">"内部类中的字符串"</span>;</span><br><span class="line">        <span class="comment">//定义一个普通方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="comment">//调用外部类的str属性</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************** </span></span><br><span class="line">    <span class="comment">//在外部类中定义一个方法，该方法负责产生内部类对象并调用print()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//内部类对象</span></span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="comment">//内部类对象提供的print</span></span><br><span class="line">        in.print();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//创建外部类对象</span></span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//外部类方法</span></span><br><span class="line">        out.fun();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li><p>内部类与外部类可以方便的访问彼此的私有域（包括私有方法、私有属性）。</p></li><li><p>内部类是另外一种封装，对外部的其他类隐藏。</p></li><li><p>内部类可以实现java的单继承局限。</p></li><li><p>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</p></li><li><p>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</p></li><li><p>创建内部类对象的时刻并不依赖于外围类对象的创建。</p></li><li><pre><code class="java">class A {    private String name = "A类的私有域";    public String getName() {        return name;    }}class B {    private int age = 20;    public int getAge() {        return age;    }}class Outter {    private class InnerClassA extends A {        public String name() {            return super.getName();    }}    private class InnerClassB extends B {        public int age() {            return super.getAge();    }}    public String name() {        return new InnerClassA().name();    }    public int age() {        return new InnerClassB().age();    }}public class Test2 {        public static void main(String[] args) {            Outter outter = new Outter();            System.out.println(outter.name());            System.out.println(outter.age());        }}</code></pre></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://blog.csdn.net/weixin_42762133/article/details/82890555">https://blog.csdn.net/weixin_42762133/article/details/82890555</a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>待编辑……..</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习第二次</title>
      <link href="/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1/"/>
      <url>/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java复习第二次"><a href="#java复习第二次" class="headerlink" title="java复习第二次"></a>java复习第二次</h1><h2 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h2><p>表明正在构造的新类派生于一个已存在的类。称为超类、基类或父类，新类称为子类。</p><p>应将最一般的方法放在超类中，更一般的方法放在子类中。</p><h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>在子类中，可以增加字段、方法或覆盖超类的方法，但继承不会删除任何字段或方法。</p><p>调用超类方法/构造器使用关键字super。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>指对象变量是多态的，指超类的任何对象的任何地方都可以使用子类对象替换。（子类对象具有子类和超类的性质，但超类对象不一定具有子类的性质）</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>1.编译器查看对象的类型声明和方法名。会列举所有同名方法。</p><p>2.确定方法调用的参数进行匹配。</p><p>3.如果方法被private、final、static修饰，则编译器能准确调用（静态绑定）。</p><p>4.采用动态绑定调用方法时，虚拟机会调用与所引用对象实际类型对应的方法。优先调用子类的，若子类未定义，则调用超类方法。</p><h3 id="阻止继承（final）"><a href="#阻止继承（final）" class="headerlink" title="阻止继承（final）"></a>阻止继承（final）</h3><p>阻止继承类：将类声明为final</p><p>阻止子类覆盖方法：将方法声明为final</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将子类对象赋值给超类是可以的，但将超类对象赋值给子类必须进行强转。<strong>在进行强转前需使用instanceof操作符判断是否能成功强转。</strong></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>位于上层的类更具有一般性，更抽象。可使用abstract关键字将类声明为抽象。</p><p><strong>包含一个或多个抽象方法的类本身必须声明为抽象。</strong></p><p>抽象方法没有方法体。</p><p>抽象类可包含具体方法。（不建议这样做）</p><p>抽象类不能实例化，但可以定义一个抽象类的对象变量，但这个变量只能引用非抽象子类的实例。</p><h3 id="object类（所有类的超类）"><a href="#object类（所有类的超类）" class="headerlink" title="object类（所有类的超类）"></a>object类（所有类的超类）</h3><p>java中的每个类都继承object类。</p><p>可以用object类型的变量引用任何类型的对象。</p><h4 id="equals方法（boolean）"><a href="#equals方法（boolean）" class="headerlink" title="equals方法（boolean）"></a>equals方法（boolean）</h4><p>object类中的equals方法用于检测一个对象是否等于另一个对象。（确定是否引用相等）</p><p>如果检测两个对象是否拥有相等的状态，则需重写equals方法。（若在子类中则需先调用超类的方法）</p><p>性质：自反、对称、传递、一致</p><h4 id="hashCode（散列码）方法（int）"><a href="#hashCode（散列码）方法（int）" class="headerlink" title="hashCode（散列码）方法（int）"></a>hashCode（散列码）方法（int）</h4><p>是由对象导出的一个整型值。无规律。两个不同的对象散列码基本不同。</p><p>此方法定义在object类中，因此每个对象都有默认的散列码，其值由对象的存储地址得出。</p><p>字符串的散列码是由内容导出的，而字符串构建器由存储地址导出。</p><h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>object类中定义，返回对象的类名和散列码。</p><p>可在类中重写打印对象状态。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>**接口不是类，而是对希望符合这个接口类的一组需求 **</p><p>所有方法自动为public</p><p>**绝对不会有实例字段 **</p><p>可以定义方法（无方法体）可以定义常量。</p><p>不能构造接口的对象，却能声明接口的变量，必须引用实现了这个接口的类的对象。</p><p>可使用extends扩展接口。</p><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>一个类只能继承一个父类，但可以实现多个接口。</p><p>待编辑……</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习第一次</title>
      <link href="/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
      <url>/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java-复习第一次"><a href="#java-复习第一次" class="headerlink" title="java  复习第一次"></a>java  复习第一次</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><ul><li>依赖</li></ul><p>即使用一个类时需要访问另一个类的对象</p><p>e.g.  订单类需要访问账户对象查看信用状态</p><ul><li>聚合</li></ul><p>类A的对象包含一些类B的对象</p><ul><li>继承</li></ul><p>子类继承父类</p><h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li> final实例字段 </li></ul><blockquote><ul><li><p>这样的字段必须在构造对象时初始化并不能再修改。</p></li><li><p>此修饰符对于类型为基本类型或不可变类的字段尤其有用。</p></li></ul></blockquote><ul><li><p>静态字段 </p><blockquote><ul><li><p>将一个字段定义为static，则每个类只有一个这样的字段，即使没有对象，静态字段也存在。（属于类而不属于单个对象）</p></li><li><p>而对于非静态的实例字段，每个对象都有自己的一个副本。（所有类的对象的这个字段都是一个/类的每个对象都有各自的）</p></li></ul></blockquote></li><li><p>初始化数据字段的方法</p><blockquote><p>1.在构造器中设置值</p><p>2.在声明中赋值</p><p>3.初始化块: 一个类的声明中可以包含任意多个代码块。只要构造类的对象，这些块就会被执行。</p></blockquote></li></ul><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><ul><li><p>与类同名</p></li><li><p>一个类可以有多个构造器（参数不同）（重载）</p></li><li><p>构造器可以没有参数或有多个参数</p></li><li><p>没有返回值(其实返回值就是所创建的类的对象)</p></li><li><p>常与new操作符一起调用</p></li><li><p>无参数的构造器：创建对象时，对象状态会设置为适当的默认值。</p></li><li><p>使用this关键字调用同类的另一个构造器</p></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>显式参数和隐式参数</p><blockquote><ul><li><p>在方法名后的括号中声明的是显式参数</p></li><li><p>在方法中使用的对象的属性（方法调用的目标或接收者）是隐式参数。关键字this指示隐式参数。</p></li></ul></blockquote></li><li><p>静态方法</p><blockquote><p>调用时并不使用任何类的对象， 没有隐式参数，不能访问对象的实例字段，不能在对象上执行操作。</p><p>可访问静态字段，用类直接调用，静态方法和静态数据成员会随着类的定义而被分配和装载入内存中。</p></blockquote></li><li><p>普通方法</p><blockquote><ul><li><p>既可以访问静态数据成员 又可以访问非静态数据成员</p></li><li><p>只有在类的对象创建时在对象的内存中才有这个方法的代码段</p></li><li><p>只能用构造的类的对象调用方法</p></li></ul></blockquote></li></ul><ul><li><p>工厂方法</p><blockquote><ul><li><p>使用静态工厂方法构造对象</p></li><li><p>无法命名构造器（构造器的名字必须与类名相同，但希望有两个不同的名字时）</p></li><li><p>使用构造器时无法改变构造对象的类型</p></li></ul></blockquote></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>想要使用对象，必须通过构造器构造对象并指定初始状态，再对对象应用方法。</p><p>可用var关键字声明局部变量，无需指定类型。</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>​            将一个字段定义为static，则每个类只有一个这样的字段，即使没有对象，静态字段也存在。（属于类而不属于单个对象）而对于        非静态的实例字段，每个对象都有自己的一个副本。（所有类的对象的这个字段都是一个/类的每个对象都有各自的）</p><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><p>​        在类中定义一个静态常量后，可直接用类来调用这个常量。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>调用时并不使用任何类的对象，没有隐式参数，不能访问对象的实例字段，不能在对象上执行操作。可访问静态字段，用类直接调用。</p><h2 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h2><ul><li>使用静态工厂方法构造对象。</li></ul><blockquote><p>LocalDate.now()；构造这个对象时的日期</p><p>LocalDate.of(YYYY,MM,DD)；指定日期</p></blockquote><p>对于已构造的对象可使用getYear，getMonthValue，getDayOfMonth方法得到年月日</p><p>使用plusDay（int）方法计算距离当前日期的新日期</p><p>只访问对象不更改的成为访问器方法</p><p>修改对象的称为修改器方法</p><h2 id="java中各种访问器修饰符"><a href="#java中各种访问器修饰符" class="headerlink" title="java中各种访问器修饰符"></a>java中各种访问器修饰符</h2><h3 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h3><p>​        修饰的类，类属性变量及方法，包内及包外的任何类（包括子类和普通类）都可以访问。</p><h3 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h3><p>​        修饰的类，类属性变量及方法，只有本类可以访问，而在包内包外的任何类都不能访问。</p><h3 id="Protect"><a href="#Protect" class="headerlink" title="Protect"></a>Protect</h3><p>​        修饰的类，类属性变量及方法，包内的任何类及包外那些继承了该类的子类才能访问，重点突出继承。</p><h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p>​        如果一个类，类属性变量及方法没有用任何的修饰符，则其为默认的访问权限Default，默认的访问权限的类，类属性变量及方法，包内的任何类（包括继承了此类的子类）都可以访问他，而对于包外的任何类都不能访问他（包括包外继承了此类的子类），重点突出包。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​        Protected修饰符修饰的成员变量和方法也称为受保护的成员变量和方法，受保护的成员变量和方法可以再本类或者同一个包中的其他类（包括子类）中通过类的实例进行访问，也可以被同一个包中的类或不同包中的类继承，但是不能再不同包中的其他类（包括子    类）中通过类的实例进行访问。Protected属于子类限制修饰符。</p><p>​        Public修饰符修饰的类，那么该类的类名必须与他所在的源文件同名，一个.java源文件中有且只有一个Public类，顶层类只能用Public和默认修饰符（无修饰符）修饰。</p><p>​        Protected修饰符修饰的类属性成员变量和方法，只可以被子类访问，而不管子类是不是和父类位于同一个包中。</p><p>​        Default修饰符修饰的类属性成员变量和方法，只可以被同一个包中的其他类访问，不管其他类是不是该类的子类。Default属于包限制修饰符。</p><h2 id="Java中static方法和普通方法的区别"><a href="#Java中static方法和普通方法的区别" class="headerlink" title="Java中static方法和普通方法的区别"></a>Java中static方法和普通方法的区别</h2><h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><p>是使用static关键字修饰的方法，又叫类方法。属于类的，不属于对象，在实例化对象之前就可以通过类名.方法名调用静态方法。（静态属性，静态方法都是属于类的，可以直接通过类名调用）。</p><p>A.在静态方法中，可以调用静态方法。<br>B.在静态方法中，不能调用非静态方法。<br>C.在静态方法中，可以引用类变量（即，static修饰的变量）。<br>D.在静态方法中，不能引用成员变量（即，没有static修饰的变量）。<br>E.在静态方法中，不能使用super和this关键字</p><p>F.静态方法可以直接调用，类名调用和对象调用。（类名.方法名 / 对象名.方法名）</p><p>G.静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。（也就是静态方法属于类）静态方法会随着类的定义而被分配和装载入内存中，编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然可能有多个实例，但这些实例共享该内存，特别值得注意的是，任何一个对象对静态数据成员的修改，都会影响其它对象。</p><h3 id="非静态方法"><a href="#非静态方法" class="headerlink" title="非静态方法"></a>非静态方法</h3><p>是不含有static关键字修饰的普通方法，又称为实例方法，成员方法。属于对象的，不属于类的。（成员属性，成员方法是属于对象的，必须通过new关键字创建对象后，再通过对象调用）。</p><p>A.在普通方法中，可以调用普通方法。<br>B.在普通方法中，可以调用静态方法<br>C.在普通方法中，可以引用类变量和成员变量<br>D.在普通方法中，可以使用super和this关键字</p><p>E.非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。（也就是非静态方法属于对象）。静态不能引用非静态这一特性，是由于静态的会随着类的定义而被分配和装载入内存中这一关键点决定的；如果静态引用了非静态的，根本无法从内存中找到非静态的代码段，势必会出错，这种做法是Java虚拟机决不允许的</p><p>F.但是非静态方法只能通过对象调用。（对象名.方法名）</p><h4 id="总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用"><a href="#总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用" class="headerlink" title="总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用"></a>总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用</h4><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><ul><li>链接博客：<a href="https://www.cnblogs.com/zhangyinhua/p/7689974.html">https://www.cnblogs.com/zhangyinhua/p/7689974.html</a></li></ul><h3 id="一、String简介"><a href="#一、String简介" class="headerlink" title="一、String简介"></a>一、String简介</h3><h4 id="1-1、String（字符串常量）概述"><a href="#1-1、String（字符串常量）概述" class="headerlink" title="1.1、String（字符串常量）概述"></a>1.1、String（字符串常量）概述</h4><p>　　在API中是这样描述：</p><p>　　　　String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>　　　　字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p><p>　　java.lang.String：</p><p>　　　　<img src="https://i.bmp.ovh/imgs/2021/06/b2e0a2fe6e82f27f.png"></p><h4 id="1-2、分析String源码"><a href="#1-2、分析String源码" class="headerlink" title="1.2、分析String源码"></a>1.2、分析String源码</h4><h5 id="1）String的成员变量"><a href="#1）String的成员变量" class="headerlink" title="1）String的成员变量"></a>1）String的成员变量</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">　<span class="comment">/** String的属性值 */</span>  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line"> <span class="comment">/**数组被使用的开始位置**/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"> <span class="comment">/**String中元素的个数**/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="comment">/**String类型的hash值**/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Class String is special cased within the Serialization Stream         Protocol.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">  * &lt;a href="{<span class="doctag">@docRoot</span>}/../platform/serialization/spec/output.html"&gt;</span></span><br><span class="line"><span class="comment">  * Object Serialization Specification, Section 6.2, "Stream Elements"&lt;/a&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">     <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></tbody></table></figure><p>　　　　从源码看出String底层使用一个字符数组来维护的。</p><p>　　　　成员变量可以知道String类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的String类型对象，存储String数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始。</p><h5 id="2）String的构造方法"><a href="#2）String的构造方法" class="headerlink" title="2）String的构造方法"></a>2）String的构造方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String() </span><br><span class="line">          初始化一个新创建的 String 对象，使其表示一个空字符序列。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes) </span><br><span class="line">          通过使用平台的默认字符集解码指定的 <span class="keyword">byte</span> 数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, Charset charset) </span><br><span class="line">          通过使用指定的 charset 解码指定的 <span class="keyword">byte</span> 数组，构造一个新的 String。  </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length) </span><br><span class="line">          通过使用平台的默认字符集解码指定的 <span class="keyword">byte</span> 子数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset) </span><br><span class="line">          通过使用指定的 charset 解码指定的 <span class="keyword">byte</span> 子数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName) </span><br><span class="line">          通过使用指定的字符集解码指定的 <span class="keyword">byte</span> 子数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName) </span><br><span class="line">          通过使用指定的 charset 解码指定的 <span class="keyword">byte</span> 数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">char</span>[] value) </span><br><span class="line">          分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。 </span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> offset, <span class="keyword">int</span> count) </span><br><span class="line">          分配一个新的 String，它包含取自字符数组参数一个子数组的字符。 </span><br><span class="line">String(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count) </span><br><span class="line">          分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。 </span><br><span class="line">String(String original) </span><br><span class="line">          初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。 </span><br><span class="line">String(StringBuffer buffer) </span><br><span class="line">          分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。 </span><br><span class="line">String(StringBuilder builder) </span><br><span class="line">          分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。 </span><br></pre></td></tr></tbody></table></figure><h3 id="二、创建字符串对象两种方式的区别"><a href="#二、创建字符串对象两种方式的区别" class="headerlink" title="二、创建字符串对象两种方式的区别"></a>二、创建字符串对象两种方式的区别</h3><h4 id="2-1、直接赋值方式创建对象"><a href="#2-1、直接赋值方式创建对象" class="headerlink" title="2.1、直接赋值方式创建对象"></a>2.1、直接赋值方式创建对象</h4><p>　　直接赋值方式创建对象是在方法区的常量池</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"hello"</span>;<span class="comment">//直接赋值的方式</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-2、通过构造方法创建字符串对象"><a href="#2-2、通过构造方法创建字符串对象" class="headerlink" title="2.2、通过构造方法创建字符串对象"></a>2.2、通过构造方法创建字符串对象</h4><p>　　通过构造方法创建字符串对象是在堆内存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"hello"</span>);<span class="comment">//实例化的方式</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-3、两种实例化方式的比较"><a href="#2-3、两种实例化方式的比较" class="headerlink" title="2.3、两种实例化方式的比较"></a>2.3、两种实例化方式的比较</h4><h5 id="1）编写代码比较"><a href="#1）编写代码比较" class="headerlink" title="1）编写代码比较"></a>1）编写代码比较</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String str1 = <span class="string">"Lance"</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"Lance"</span>);</span><br><span class="line">        String str3 = str2; <span class="comment">//引用传递，str3直接指向st2的堆内存地址</span></span><br><span class="line">        String str4 = <span class="string">"Lance"</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  ==:</span></span><br><span class="line"><span class="comment">         * 基本数据类型：比较的是基本数据类型的值是否相同</span></span><br><span class="line"><span class="comment">         * 引用数据类型：比较的是引用数据类型的地址值是否相同</span></span><br><span class="line"><span class="comment">         * 所以在这里的话：String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">         System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2）内存图分析"><a href="#2）内存图分析" class="headerlink" title="2）内存图分析"></a>2）内存图分析</h5><p><img src="https://i.bmp.ovh/imgs/2021/06/681a849a91ac6fc9.png"></p><p>可能这里还是不够明显，构造方法实例化方式的内存图：String str = new String(“Hello”);</p><p>首先：</p><p>​                              <img src="https://i.bmp.ovh/imgs/2021/06/78d97ef8ef8590e2.png"> 　　　　</p><p>当我们再一次的new一个String对象时：</p><p>　　　　　　<img src="https://i.bmp.ovh/imgs/2021/06/409ef81452f665b1.png"></p><h5 id="3）字符串常量池"><a href="#3）字符串常量池" class="headerlink" title="3）字符串常量池"></a>3）字符串常量池</h5><p>　　　　　　在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象，</p><p>　　　　　　这样，所有直接赋值的String对象，如果利用相同的“Lance”，则String对象==返回true；</p><p>　　　　　　比如：对象手工入池</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">     String str =<span class="keyword">new</span> String(<span class="string">"Lance"</span>).intern();<span class="comment">//对匿名对象"hello"进行手工入池操作</span></span><br><span class="line">     String str1=<span class="string">"Lance"</span>;</span><br><span class="line">     System.out.println(str==str1);<span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="4）总结：两种实例化方式的区别"><a href="#4）总结：两种实例化方式的区别" class="headerlink" title="4）总结：两种实例化方式的区别"></a>4）总结：两种实例化方式的区别</h5><p>　　　　　　1）直接赋值（String str = “hello”）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p>　　　　　　2）构造方法（String str=  new String(“hello”);）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。</p><p>　　　　　　　　在开发的过程中不会采用构造方法进行字符串的实例化。</p><p>　　　　5）避免空指向</p><p>　　　　　　首先了解： == 和public boolean equals()比较字符串的区别</p><p>　　　　　　==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向。</p><p>　　　　　　举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　String str = <span class="keyword">null</span>;</span><br><span class="line">　　　　　　<span class="keyword">if</span>(str.equals(<span class="string">"hello"</span>)){<span class="comment">//此时会出现空指向异常</span></span><br><span class="line">　　　　　　　　...</span><br><span class="line">　　　　　　}</span><br><span class="line">　　　　　　<span class="keyword">if</span>(<span class="string">"hello"</span>.equals(str)){<span class="comment">//此时equals会处理null值，可以避免空指向异常</span></span><br><span class="line">　　　　　　　　　...</span><br><span class="line">　　　　　　}</span><br></pre></td></tr></tbody></table></figure><p>　　　6）String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾</p><p> 　　　　　<img src="https://i.bmp.ovh/imgs/2021/06/661f67370a5cd175.png" style="zoom:50%;"></p><h3 id="三、String常用的方法"><a href="#三、String常用的方法" class="headerlink" title="三、String常用的方法"></a>三、String常用的方法</h3><p>　　<img src="https://i.bmp.ovh/imgs/2021/06/b4ccb91e286f6ba2.png" style="zoom:67%;"></p><h4 id="3-1、String的判断功能"><a href="#3-1、String的判断功能" class="headerlink" title="3.1、String的判断功能"></a>3.1、String的判断功能</h4><h5 id="1）常用方法"><a href="#1）常用方法" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>： 比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span>： 判断字符串对象是否以指定的str开头</span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span>： 判断字符串对象是否以指定的str结尾</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）代码测试"><a href="#2）代码测试" class="headerlink" title="2）代码测试"></a>2）代码测试</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">           <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"hello"</span>;</span><br><span class="line">        String s3 = <span class="string">"Hello"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2));</span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// boolean startsWith(String str):判断字符串对象是否以指定的str开头</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">"he"</span>));</span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">"ll"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">------------</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">------------</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2、String类的获取功能"><a href="#3-2、String类的获取功能" class="headerlink" title="3.2、String类的获取功能"></a>3.2、String类的获取功能</h4><h5 id="1）常用方法-1"><a href="#1）常用方法-1" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:获取字符串的长度，其实也就是字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>:获取指定索引处的字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>:获取str在字符串对象中第一次出现的索引</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>:从start开始截取字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:从start开始，到end结束截取字符串。包括start，不包括end</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）代码测试-1"><a href="#2）代码测试-1" class="headerlink" title="2）代码测试"></a>2）代码测试</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">          <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"helloworld"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"l"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"owo"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"ak"</span>));</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String substring(int start):从start开始截取字符串</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String substring(int start,int end):从start开始，到end结束截取字符串</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">        System.out.println(s.substring(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">----</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">----</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">----</span><br><span class="line">helloworld</span><br><span class="line">world</span><br><span class="line">----</span><br><span class="line">helloworld</span><br><span class="line">lowor</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3、String的转换功能"><a href="#3-3、String的转换功能" class="headerlink" title="3.3、String的转换功能"></a>3.3、String的转换功能</h4><h5 id="1）常用方法-2"><a href="#1）常用方法-2" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">char</span>[] toCharArray()：把字符串转换为字符数组</span><br><span class="line">　　<span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：把字符串转换为小写字符串</span></span><br><span class="line"><span class="function">　　String <span class="title">toUpperCase</span><span class="params">()</span>：把字符串转换为大写字符串</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）核心代码"><a href="#2）核心代码" class="headerlink" title="2）核心代码"></a>2）核心代码</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">         <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"abcde"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) {</span><br><span class="line">            System.out.println(chs[x]);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String toLowerCase():把字符串转换为小写字符串</span></span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>.toLowerCase());</span><br><span class="line">        <span class="comment">// String toUpperCase():把字符串转换为大写字符串</span></span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>.toUpperCase());</span><br><span class="line">        </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-----</span><br><span class="line">helloworld</span><br><span class="line">HELLOWORLD</span><br></pre></td></tr></tbody></table></figure><p>　　注意：　　</p><p>　　　　字符串的遍历有两种方式：一是ength()加上charAt()。二是把字符串转换为字符数组，然后遍历数组。</p><h4 id="3-4、其他常用方法"><a href="#3-4、其他常用方法" class="headerlink" title="3.4、其他常用方法"></a>3.4、其他常用方法</h4><h5 id="1）常用方法-3"><a href="#1）常用方法-3" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　去除字符串两端空格：<span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　按照指定符号分割字符串：String[] <span class="title">split</span><span class="params">(String str)</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）核心代码-1"><a href="#2）核心代码-1" class="headerlink" title="2）核心代码"></a>2）核心代码</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">          <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">"helloworld"</span>;</span><br><span class="line">        String s2 = <span class="string">" helloworld "</span>;</span><br><span class="line">        String s3 = <span class="string">" hello world "</span>;</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s1 + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s1.trim() + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s2 + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s2.trim() + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s3 + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s3.trim() + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String[] split(String str)</span></span><br><span class="line">        <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s4 = <span class="string">"aa,bb,cc"</span>;</span><br><span class="line">        String[] strArray = s4.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) {</span><br><span class="line">            System.out.println(strArray[x]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---helloworld---</span><br><span class="line">---helloworld---</span><br><span class="line">--- helloworld ---</span><br><span class="line">---helloworld---</span><br><span class="line">--- hello world ---</span><br><span class="line">---hello world---   </span><br><span class="line">--------------------</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br></pre></td></tr></tbody></table></figure><h3 id="四、String的不可变性"><a href="#四、String的不可变性" class="headerlink" title="四、String的不可变性"></a>四、String的不可变性</h3><p>当我们去阅读源代码的时候，会发现有这样的一句话：</p><p><img src="https://i.bmp.ovh/imgs/2021/06/77ba33db8221bf91.png"></p><p>意思就是说：String是个常量，从一出生就注定不可变。</p><p>我想大家应该就知道为什么String不可变了，String类被final修饰，官方注释说明创建后不能被改变，但是为什么String要使用final修饰呢？　</p><h4 id="4-1、前言"><a href="#4-1、前言" class="headerlink" title="4.1、前言"></a>4.1、前言</h4><p>　　了解一个经典的面试题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(a==b);  <span class="comment">//true</span></span><br><span class="line">        System.out.println(a.equals(b));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(a==c);  <span class="comment">//false</span></span><br><span class="line">        System.out.println(a.equals(c));  <span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　内存图：</p><p>　　　　<img src="https://i.bmp.ovh/imgs/2021/06/bd29ee48dfea9c6a.png" style="zoom:80%;"></p><h4 id="4-2、分析"><a href="#4-2、分析" class="headerlink" title="4.2、分析"></a>4.2、分析</h4><p>　　因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，</p><p>　　就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。　　</p><p>　　需要说明一点的是，在object中，equals()是用来比较内存地址的，但是String重写了equals()方法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。</p><h4 id="4-3、String不可变的好处"><a href="#4-3、String不可变的好处" class="headerlink" title="4.3、String不可变的好处"></a>4.3、String不可变的好处</h4><p>　　可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</p><p>　　我们的程序中大量使用了String字符串，有可能是出于安全性考虑。</p><p>　　大家都知道HashMap中key为String类型，如果可变将变的多么可怕。</p><p>　　当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。</p><h3 id="五、字符串常量池"><a href="#五、字符串常量池" class="headerlink" title="五、字符串常量池"></a>五、字符串常量池</h3><h4 id="5-1、字符串常量池概述"><a href="#5-1、字符串常量池概述" class="headerlink" title="5.1、字符串常量池概述"></a>5.1、字符串常量池概述</h4><h5 id="1）常量池表（Constant-Pool-table）"><a href="#1）常量池表（Constant-Pool-table）" class="headerlink" title="1）常量池表（Constant_Pool table）"></a>1）常量池表（Constant_Pool table）</h5><p>　　　　Class文件中存储所有常量（包括字符串）的table。<br>　　　　这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。</p><h5 id="2）运行时常量池（Runtime-Constant-Pool）"><a href="#2）运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="2）运行时常量池（Runtime Constant Pool）"></a>2）运行时常量池（Runtime Constant Pool）</h5><p>　　　　JVM内存中方法区的一部分，这是运行时的内容<br>　　　　这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池<br>　　　　上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容</p><h5 id="3）字符串常量池（String-Pool）"><a href="#3）字符串常量池（String-Pool）" class="headerlink" title="3）字符串常量池（String Pool）"></a>3）字符串常量池（String Pool）</h5><p>　　　　这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个<br>　　　　JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</p><h4 id="5-2、享元模式"><a href="#5-2、享元模式" class="headerlink" title="5.2、享元模式"></a>5.2、享元模式</h4><p>　　其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式<br>　　也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素<br>　　Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p><h4 id="5-3、详细分析"><a href="#5-3、详细分析" class="headerlink" title="5.3、详细分析"></a>5.3、详细分析</h4><p>　　举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x  = <span class="number">10</span>;</span><br><span class="line">String y = <span class="string">"hello"</span>;</span><br></pre></td></tr></tbody></table></figure><p>　　1)首先，<code>10</code>和<code>"hello"</code>会在经过javac（或者其他编译器）编译过后变为Class文件中<code>constant_pool table</code>的内容</p><p>　　2)当我们的程序运行时，也就是说JVM运行时，每个Class<code>constant_pool table</code>中的内容会被加载到JVM内存中的方法区中各自Class的<code>Runtime Constant Pool。</code></p><p>　　3)一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是”hello”）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下：　　　</p><p>　　　　一是：在Java Heap中根据”hello”字面量create一个字符串对象<br>　　　　二是：将字面量”hello”与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：”hello” = 对象的引用地址。</p><p>　　　另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？</p><p>　　策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，如上3</p><p>　　如此，就实现了享元模式，提高的内存利用效率。</p><p>　　举例：</p><p>　　　　　　使用String s = new String(“hello”);会创建几个对象</p><p>　　　　　　会创建2个对象</p><p>　　　　　　首先，出现了字面量”hello”，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量”hello”首先创建1个String对象。</p><p>　　　　　　接着，new String(“hello”)，关键字new又在Java Heap中创建了1个对象，然后调用接收String参数的构造器进行了初始化。最终s的引用是这个String对象.</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/04/24/hello-world/"/>
      <url>/2021/04/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
