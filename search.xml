<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Activity的构成及事件分发机制</title>
      <link href="/2021/10/24/Activity%E7%9A%84%E6%9E%84%E6%88%90%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/10/24/Activity%E7%9A%84%E6%9E%84%E6%88%90%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>View的工作流程</title>
      <link href="/2021/10/24/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/10/24/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>View的工作流程指的就是measure、layout和draw。其中measure用来测量VIew的宽和高，layout用来确定View的位置，draw用来绘制View。</p><h1 id="Acitivity启动过程"><a href="#Acitivity启动过程" class="headerlink" title="Acitivity启动过程"></a>Acitivity启动过程</h1><h2 id="startActivityForResult方法"><a href="#startActivityForResult方法" class="headerlink" title="startActivityForResult方法"></a>startActivityForResult方法</h2><p>先从Activity的startActivity方法说起。</p><p>startActivity方法或startActivityForResult有很多种重载方式，但它们最终都会调用startActivityForResult(intent, requestCode, options)方法。源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> Bundle options)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是第一次启动，则成员变量mParent为空，否则不为空。</span></span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//第一次启动执行</span></span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用Instrumentation的execStartActivity(Context who, IBinder contextThread····)方法</span></span><br><span class="line">            </span><br><span class="line">            Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) {</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),ar.getResultData());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果是请求一个结果（result），我们可以使Activity不可见，直到收到结果，在onCreate(Bundle savedInstanceState)方法或者onResume()期间设置此代码将在此期间隐藏Activity，以避免闪烁，只有在请求结果时才可以这样做，因为这样可以保证在Activity完成时我们将获得信息，无论它发生了什么</span></span><br><span class="line"></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//如果不是第一次启动执行</span></span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) {</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="Instrumentation的execStartActivity方法"><a href="#Instrumentation的execStartActivity方法" class="headerlink" title="Instrumentation的execStartActivity方法"></a>Instrumentation的execStartActivity方法</h2><p>我们来看一看第一次执行时调用的Instrumentation的execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options)方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/Instrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>{</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">// 调用ActivityTaskManagerService的startActivity方法</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">         checkStartActivityResult(result, intent);</span><br><span class="line">     } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ActivityTaskManager.getService()<strong>方法得到的是</strong>IActivityTaskManager</strong>接口，它是通过<strong>进程间通讯（Inter-Process Communication，即IPC）</strong>调用的，<strong>IActivityTaskManager</strong>的<strong>服务端</strong>是<strong>ActivityTaskManagerService</strong>，所以最终是调用<strong>ActivityTaskManagerService</strong>的<strong>startActivity</strong>方法，后面的调用过程，这里就不再详细地讲解，最后调用的是<strong>ActivityThread</strong>类的**handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)**方法，</p><h2 id="调用的是ActivityThread类的handleLaunchActivity方法"><a href="#调用的是ActivityThread类的handleLaunchActivity方法" class="headerlink" title="调用的是ActivityThread类的handleLaunchActivity方法"></a>调用的是<strong>ActivityThread</strong>类的handleLaunchActivity方法</h2><p>源码如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">           PendingTransactionActions pendingActions, Intent customIntent)</span> </span>{</span><br><span class="line">       <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">       <span class="comment">// we are back active so skip it.</span></span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line">       mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) {</span><br><span class="line">           mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">           mProfiler.startProfiling();</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">       handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">           TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">       <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">               &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) {</span><br><span class="line">           HardwareRenderer.preload();</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//----------------------从这里开始-------------------------//</span></span><br><span class="line">       </span><br><span class="line">       WindowManagerGlobal.initialize();     <span class="comment">// 初始化全局的WindowManagerGlobal </span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Hint the GraphicsEnvironment that an activity is launching on the process. 提示图形环境Activity正在进程上启动.</span></span><br><span class="line">       GraphicsEnvironment.hintActivityLaunch();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a != <span class="keyword">null</span>) {</span><br><span class="line">           r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">           reportSizeConfigurations(r);</span><br><span class="line">           <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) {</span><br><span class="line">               pendingActions.setOldState(r.state);</span><br><span class="line">               pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">               pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">           <span class="keyword">try</span> {</span><br><span class="line">               ActivityTaskManager.getService()</span><br><span class="line">                       .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                               Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">           } <span class="keyword">catch</span> (RemoteException ex) {</span><br><span class="line">               <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="调用performLaunchActivity方法来创建Activity"><a href="#调用performLaunchActivity方法来创建Activity" class="headerlink" title="调用performLaunchActivity方法来创建Activity"></a>调用performLaunchActivity方法来创建Activity</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>{</span><br><span class="line">       <span class="comment">//一些需要启动的Activity的信息。</span></span><br><span class="line">       ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">       <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) {</span><br><span class="line">           r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                   Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       ComponentName component = r.intent.getComponent();</span><br><span class="line">       <span class="keyword">if</span> (component == <span class="keyword">null</span>) {</span><br><span class="line">           component = r.intent.resolveActivity(</span><br><span class="line">               mInitialApplication.getPackageManager());</span><br><span class="line">           r.intent.setComponent(component);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) {</span><br><span class="line">           component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                   r.activityInfo.targetActivity);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">       Activity activity = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">           <span class="comment">// 反射创建Activity</span></span><br><span class="line">           activity = mInstrumentation.newActivity(</span><br><span class="line">                   cl, component.getClassName(), r.intent);</span><br><span class="line">           StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">           r.intent.setExtrasClassLoader(cl);</span><br><span class="line">           r.intent.prepareToEnterProcess();</span><br><span class="line">           <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) {</span><br><span class="line">               r.state.setClassLoader(cl);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                       <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                               + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">// 创建Application对象，它是个单例，一个进程只有一个Application</span></span><br><span class="line">           Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {</span><br><span class="line">               <span class="comment">// 省略部分代码</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">// Activity resources must be initialized with the same loaders as the</span></span><br><span class="line">               <span class="comment">// application context.</span></span><br><span class="line">               appContext.getResources().addLoaders(</span><br><span class="line">                       app.getResources().getLoaders().toArray(<span class="keyword">new</span> ResourcesLoader[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">               appContext.setOuterContext(activity);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// Activity成功创建，调用Activity的attach方法，这个方法会创建PhoneWindow，它是Window抽象类的子类</span></span><br><span class="line">               <span class="comment">// 将 context等各种数据与Activity绑定，初始化Activity</span></span><br><span class="line">               activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                       r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                       r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                       r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                       r.assistToken);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 省略部分代码</span></span><br><span class="line">               <span class="comment">// 调用Activity的onCreate方法</span></span><br><span class="line">               <span class="keyword">if</span> (r.isPersistable()) {</span><br><span class="line">                   mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">               } <span class="keyword">else</span> {</span><br><span class="line">                   mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">if</span> (!activity.mCalled) {</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                           <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                                   <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">               }</span><br><span class="line">               r.activity = activity;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 设为ON_CREATE状态</span></span><br><span class="line">           r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// updatePendingActivityConfiguration()方法的作用是从mActivities中读取数据以更新ActivityClientRecord，它在不同的线程中运行，所以要取ResourcesManager作为锁对象</span></span><br><span class="line">           <span class="keyword">synchronized</span> (mResourcesManager) {</span><br><span class="line">               mActivities.put(r.token, r);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">       } <span class="keyword">catch</span> (SuperNotCalledException e) {</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                       <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                               + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回Activity</span></span><br><span class="line">       <span class="keyword">return</span> activity;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>performActivity通过反射机制创建了Activity的实例，并且构建了Application的实例。</p><h2 id="调用了Activity的attach方法"><a href="#调用了Activity的attach方法" class="headerlink" title="调用了Activity的attach方法"></a>调用了Activity的attach方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/Activity.java</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                  CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                  NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>{</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PhoneWindow对象，并且赋值给成员变量mWindow</span></span><br><span class="line">       mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">       mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">       mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将Window和WindowManager绑定</span></span><br><span class="line">       mWindow.setWindowManager(</span><br><span class="line">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">               mToken, mComponent.flattenToString(),</span><br><span class="line">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了Instrumentation对象的callActivityOnCreate方法"><a href="#调用了Instrumentation对象的callActivityOnCreate方法" class="headerlink" title="调用了Instrumentation对象的callActivityOnCreate方法"></a>调用了Instrumentation对象的callActivityOnCreate方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,PersistableBundle persistentState)</span> </span>{</span><br><span class="line">        prePerformCreate(activity); </span><br><span class="line">        activity.performCreate(icicle, persistentState);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了Activity的preformCreate方法"><a href="#调用了Activity的preformCreate方法" class="headerlink" title="调用了Activity的preformCreate方法"></a>调用了Activity的preformCreate方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>{</span><br><span class="line">        dispatchActivityPreCreated(icicle);</span><br><span class="line">        mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">        <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) {</span><br><span class="line">            onCreate(icicle, persistentState);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            onCreate(icicle);</span><br><span class="line">        }</span><br><span class="line">        .......</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="调用了创建好的Activity的onCreate方法，至此，Activity启动完成。"><a href="#调用了创建好的Activity的onCreate方法，至此，Activity启动完成。" class="headerlink" title="调用了创建好的Activity的onCreate方法，至此，Activity启动完成。"></a>调用了创建好的Activity的onCreate方法，至此，Activity启动完成。</h2><img src="https://i.bmp.ovh/imgs/2021/10/ed536344f01dc61a.jpg" style="zoom:50%;"><p>参考文章及资料：<br>《Android进阶之光》//这本书的代码是之前的版本了，有的东西已经过时。</p><p>深入了解Android的View工作原理：<a href="https://www.jianshu.com/p/4361fe3cf287">https://www.jianshu.com/p/4361fe3cf287</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> andoird </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android多线程</title>
      <link href="/2021/10/21/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/10/21/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Android沿用了java的线程模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View的滑动冲突</title>
      <link href="/2021/10/14/View%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
      <url>/2021/10/14/View%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>​        我们在完成android需求时，可能会遇到多种控件同时可以滑动的场景，这时就可能会出现滑动冲突。在学习完android事件的分发机制之后，我们来学习滑动冲突的处理办法。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><img src="https://i.bmp.ovh/imgs/2021/10/22942787a7ed19cb.png"></p><span id="more"></span><h1 id="常见的滑动冲突场景"><a href="#常见的滑动冲突场景" class="headerlink" title="常见的滑动冲突场景"></a>常见的滑动冲突场景</h1><img src="https://i.bmp.ovh/imgs/2021/10/bf87cbe1b2d94420.png" style="zoom: 50%;"><ul><li><p>场景一：外部滑动方向和内部不一致。</p></li><li><p>场景二：外部滑动方向和内部一致。</p></li><li><p>场景三：以上两种情况的嵌套。</p><blockquote><p>场景一的应用场景示例：ViewPager和Fragment的配合。（ViewPager内部处理了滑动冲突）</p><p>场景二的应用场景示例：SrollerView里嵌套ListView。</p></blockquote></li></ul><h1 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h1><h2 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h2><p>因为内外两层的滑动方向不一致，所以当用户进行外层滑动时，需要让外部的View拦截点击事件，当用户进行内层的滑动时，需要让内部View拦截点击事件。这时我们可以根据滑动的特征来解决滑动冲突。即<strong>根据滑动的方向来判断拦截事件的View</strong>。</p><p>这个问题就变得很简单了——我们可以根据滑动过程中<strong>两个点的坐标来得出滑动的方向</strong>。</p><p>例如：</p><ul><li>水平方向和竖直方向的距离差</li><li>滑动路径和水平方向形成的夹角</li><li>水平和竖直方向的速度差</li></ul><h2 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h2><p>这个场景无法根据场景一的判断条件来做出判断，但我们一般能在业务上找到突破点。比如在某种状态时需要外部View响应用户的滑动，在另一种状态时需要内部View响应。</p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>抛开滑动规则，我们需要找到一种不依赖具体的滑动规则的通用的解决方法。</p><h2 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h2><p>即点击事件都先经过父容器的拦截处理。如果父容器需要此事件就进行拦截，否则不拦截。</p><p>需要<strong>重写父容器的onInterceptTouchEvent方法</strong>，在方法内做相应的拦截。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span> <span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">       <span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">       <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">       <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:<span class="comment">//1</span></span><br><span class="line">               intercept = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">               <span class="keyword">if</span>( *父容器需要的当前点击事件*  ){</span><br><span class="line">                   intercept = <span class="keyword">true</span>;</span><br><span class="line">               }<span class="keyword">else</span>{</span><br><span class="line">                   intercept = <span class="keyword">false</span>;</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:<span class="comment">//2</span></span><br><span class="line">               intercept = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       }</span><br><span class="line">       lastInterceptX = x;</span><br><span class="line">       lastInterceptY = y;</span><br><span class="line">       <span class="keyword">return</span> intercept;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>针对不同的滑动冲突，只需要修改父容器需要的当前点击事件这个条件即可。</p><blockquote><p>1：不可拦截ACTION_DOWN事件，一旦拦截，后续MOVE和UP事件都会交由父容器处理</p><p>2：必须返回false.如果返回true，并且滑动事件交给子View处理，那么子View将接收不到ACTION_UP事件，子View的onClick事件也无法触发。而父View不一样，如果父View在ACTION_MOVE中开始拦截事件，那么后续ACTION_UP也将默认交给父View处理！</p></blockquote><h2 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h2><p>父容器不拦截任何事件，所有事件都传递给子元素，根据子元素对事件的消耗情况判断是否交由父容器处理。</p><p><strong>与Android中事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作</strong></p><p><strong>需要重写子元素的diapatchTouchEvent方法</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);<span class="comment">//不允许父元素拦截事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - lastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - lastY;</span><br><span class="line">                <span class="keyword">if</span>(  *父容器需要此类点击事件*  ){</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);  <span class="comment">//将事件传递给父元素</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>父元素要默认拦截除了ACTION_DOWN以外的其他事件</strong>，这样当子元素调用parent.requestDisallowInterceptTouchEvent（false）方法时（即子元素不对该事件进行处理，交由父容器处理），父元素才能继续拦截所需事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>为什么父容器不能拦截ACTION_DOWN事件呢？</p><p>因为<strong>ACTION_DOWN事件不受FLAG_DISALLOW_INTERCEPT这个标记位的控制</strong>，所以一旦父容器拦截了ACTION_DOWN事件，则所有事件都无法传递到子元素中去。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="1-场景一"><a href="#1-场景一" class="headerlink" title="1.场景一"></a>1.场景一</h2><h3 id="外部拦截"><a href="#外部拦截" class="headerlink" title="外部拦截"></a>外部拦截</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理滑动冲突</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span> <span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                intercept = <span class="keyword">false</span>;</span><br><span class="line">                Log.d(<span class="string">"this"</span>,<span class="string">" false"</span>);</span><br><span class="line">                <span class="keyword">if</span>(!scroller.isFinished()) {</span><br><span class="line">                    scroller.abortAnimation();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - lastInterceptX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - lastInterceptY;</span><br><span class="line">                <span class="comment">//viewGroup拦截水平滑动</span></span><br><span class="line">                <span class="keyword">if</span>(Math.abs(deltaX) - Math.abs(deltaY) &gt; <span class="number">0</span>){</span><br><span class="line">                    intercept = <span class="keyword">true</span>;</span><br><span class="line">                    Log.d(<span class="string">"this"</span>,<span class="string">"true"</span>);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    intercept = <span class="keyword">false</span>;</span><br><span class="line">                    Log.d(<span class="string">"this"</span>,<span class="string">"false"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                intercept = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        lastX = x;</span><br><span class="line">        lastY = y;</span><br><span class="line">        lastInterceptX = x;</span><br><span class="line">        lastInterceptY = y;</span><br><span class="line">        <span class="keyword">return</span> intercept;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="内部拦截"><a href="#内部拦截" class="headerlink" title="内部拦截"></a>内部拦截</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子元素重写的ListView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: {<span class="comment">//不允许父布局拦截</span></span><br><span class="line">                mHorizontalView1.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: {</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) {<span class="comment">//要让父布局拦截</span></span><br><span class="line">                    mHorizontalView1.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父元素HorizontalView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span> <span class="params">(MotionEvent event)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN){</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">if</span>(!scroller.isFinished()){</span><br><span class="line">                scroller.abortAnimation();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>由于内部拦截比较复杂，一般不推荐使用。</p><p>未完待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rxjava笔记</title>
      <link href="/2021/07/31/Rxjava%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/31/Rxjava%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ftp.bmp.ovh/imgs/2021/07/2d246025850df29b.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/c9c97ebe6c5339f7.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/5b634956e63e2778.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/f7d85b4c5a31f3fc.png"></p><p><img src="https://i.bmp.ovh/imgs/2021/07/ea959b00ad8cee3e.png"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/c428a326f23730f1.png"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/297b474435eac378.png"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/91e4e4b55ad1c010.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀表达式及计算</title>
      <link href="/2021/07/16/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%AE%A1%E7%AE%97/"/>
      <url>/2021/07/16/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="概念与表示"><a href="#概念与表示" class="headerlink" title="概念与表示"></a>概念与表示</h2><h3 id="对表达式的记法"><a href="#对表达式的记法" class="headerlink" title="对表达式的记法"></a>对表达式的记法</h3><p>前缀表达式、中缀表达式、后缀表达式（逆波兰式）它们都是对表达式的记法。它们之间的区别在于运算符相对与操作数的位置不同：前缀表达式的运算符位于与其相关的操作数之前；中缀和后缀同理。后缀表达式又称逆波兰式是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式形式，不需要括号来标识操作符的优先级。</p><span id="more"></span><p>举例：</p><p>(3 + 4) × 5 - 6 就是中缀表达式<br>- × + 3 4 5 6 前缀表达式<br>3 4 + 5 × 6 - 后缀表达式</p><h3 id="为何使用后缀表达式？"><a href="#为何使用后缀表达式？" class="headerlink" title="为何使用后缀表达式？"></a>为何使用后缀表达式？</h3><p>中缀表达式是人们常用的算术表示方法。虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。</p><h2 id="中缀到后缀的表示"><a href="#中缀到后缀的表示" class="headerlink" title="中缀到后缀的表示"></a>中缀到后缀的表示</h2><h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><p>需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为存放结果（逆波兰式）的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p><p>（1）若取出的字符是操作数，则分析出完整的运算数，该操作数直接送入S2栈。</p><p>（2）若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果该运算符(不包括括号运算符)优先级高于S1栈栈顶运算符（包括左括号）优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符送入S1栈。</p><p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p><p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次送入S2栈，此时抛弃“（”。</p><p>（5）重复上面的1~4步，直至处理完所有的输入字符。</p><p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p><p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算</p><p>举例：</p><img src="https://i.bmp.ovh/imgs/2021/07/9754479463989414.png" style="zoom:33%;"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCharStack</span> </span>{<span class="comment">//自定义的栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCharStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.maxSize = size;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> value)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(top &lt; maxSize-<span class="number">1</span>){</span><br><span class="line">            array[++top] = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出栈顶数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array[top--];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问栈顶数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array[top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">peekN</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了便于后面分解展示栈中的内容，我们增加了一个遍历栈的方法(实际上栈只能访问栈顶元素的)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayStack</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.print(<span class="string">"Stack(bottom--&gt;top):"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; top+<span class="number">1</span>; i++){</span><br><span class="line">            System.out.print(peekN(i));</span><br><span class="line">            System.out.print(<span class="string">' '</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">StackToString</span><span class="params">()</span></span>{</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; top+<span class="number">1</span>; i++){</span><br><span class="line">            str.append(peekN(i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (top == -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> (top == maxSize-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成逆波兰表达式的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfixToSuffix</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> MyCharStack s1;<span class="comment">// 定义运算符栈</span></span><br><span class="line">    <span class="keyword">private</span> MyCharStack s2;<span class="comment">// 定义存储结果栈</span></span><br><span class="line">    <span class="keyword">private</span> String input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造方法，参数为输入的中缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfixToSuffix</span><span class="params">(String in)</span> </span>{</span><br><span class="line">        input = in;</span><br><span class="line">        s1 = <span class="keyword">new</span> MyCharStack(input.length());</span><br><span class="line">        s2 = <span class="keyword">new</span> MyCharStack(input.length());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中缀表达式转换为后缀表达式，将结果存储在栈中返回，逆序显示即后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyCharStack <span class="title">doTrans</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length(); j++) {</span><br><span class="line">            <span class="comment">/*显示转化的过程</span></span><br><span class="line"><span class="comment">            System.out.print("s1栈元素为：");</span></span><br><span class="line"><span class="comment">            s1.displayStack();</span></span><br><span class="line"><span class="comment">            System.out.print("s2栈元素为：");</span></span><br><span class="line"><span class="comment">            s2.displayStack();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">char</span> ch = input.charAt(j);</span><br><span class="line">            <span class="comment">//System.out.println("当前解析的字符:" + ch);</span></span><br><span class="line">            <span class="keyword">switch</span> (ch) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    gotOper(ch, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'×'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'÷'</span>:</span><br><span class="line">                    gotOper(ch, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    s1.push(ch);<span class="comment">// 如果当前字符是'(',则将其入栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    gotParen(ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 1、如果当前解析的字符是操作数，则直接压入s2</span></span><br><span class="line">                    s2.push(ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }<span class="comment">// end switch</span></span><br><span class="line">        }<span class="comment">// end for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    }</span><br><span class="line">、                                   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gotOper</span><span class="params">(<span class="keyword">char</span> opThis, <span class="keyword">int</span> prec1)</span> </span>{<span class="comment">//正在解析的字符和其优先级</span></span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">char</span> opTop = s1.pop();<span class="comment">//将这个运算符和栈顶的运算符准备进行优先级进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (opTop == <span class="string">'('</span>) {<span class="comment">// 如果栈顶是'(',直接将操作符压入s1</span></span><br><span class="line">                s1.push(opTop);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {<span class="comment">//算出栈顶元素的优先级</span></span><br><span class="line">                <span class="keyword">int</span> prec2;</span><br><span class="line">                <span class="keyword">if</span> (opTop == <span class="string">'+'</span> || opTop == <span class="string">'-'</span>) {</span><br><span class="line">                    prec2 = <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    prec2 = <span class="number">2</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (prec2 &lt; prec1) {<span class="comment">// 如果当前运算符比s1栈顶运算符优先级高，则将运算符压入s1</span></span><br><span class="line">                    s1.push(opTop);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果当前运算符与栈顶运算符相同或者小于优先级别，那么将S1栈顶的运算符弹出并压入到S2中</span></span><br><span class="line">                    <span class="comment">// 并且要再次再次转到while循环中与 s1 中新的栈顶运算符相比较；</span></span><br><span class="line">                    s2.push(opTop);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }<span class="comment">// end while</span></span><br><span class="line">        <span class="comment">// 如果s1为空，则直接将当前解析的运算符压入s1</span></span><br><span class="line">        s1.push(opThis);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前字符是 ')' 时，如果栈顶是'(',则将这一对括号丢弃，否则依次弹出s1栈顶的字符，压入s2，直到遇到'('</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gotParen</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">char</span> chx = s1.pop();</span><br><span class="line">            <span class="keyword">if</span> (chx == <span class="string">'('</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                s2.push(chx);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><p>新建一个表达式,如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostFix</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">evalPostFix</span><span class="params">(String token)</span> </span>{</span><br><span class="line">        Stack&lt;Double&gt; s = <span class="keyword">new</span> Stack&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">double</span> a, b, result = <span class="number">0.0</span>;<span class="comment">//ab是计算过程的中间变量，result是入栈时的变量</span></span><br><span class="line">        <span class="keyword">boolean</span> isNumber;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; token.length() - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                isNumber = <span class="keyword">true</span>;</span><br><span class="line">                result = Double.parseDouble(token);<span class="comment">//若输入字符不是数字，肯定报异常，即让布尔类型为false</span></span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                isNumber = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isNumber)<span class="comment">//如果是数字，那么就入栈</span></span><br><span class="line">                s.push(result);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果是运算符，那么就栈顶出两个数字，计算后再入栈</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">switch</span> (token.charAt(<span class="number">0</span>)) {</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b + a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b - a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'÷'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b / a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'×'</span>:</span><br><span class="line">                        a = s.pop();</span><br><span class="line">                        b = s.pop();</span><br><span class="line">                        s.push(b * a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }<span class="comment">//当循环结束时，栈里只剩下一个元素</span></span><br><span class="line">        <span class="keyword">return</span> s.peek();<span class="comment">//返回栈顶元素，并不删除</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成逆波兰表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String is)</span> </span>{</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        String[] s = is.split(<span class="string">""</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, s);</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : list) {</span><br><span class="line">        <span class="comment">//使用正则表达式如果是数字</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) {</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//pop出两个数，并运算，在入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) {</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) {</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"×"</span>)) {</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"÷"</span>)) {</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line"><span class="comment">//把结果压入栈中</span></span><br><span class="line">                stack.push(<span class="string">""</span> + res);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"><span class="comment">//最后停留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/06/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>即将所需排序的数组分为有序和无序两个部分且有序区在前。每次从无序区中取出一个元素插到有序区的适当位置。</p><p>如果需要排序的元素插入有序区的中间，则在插入元素后有序区的每一位元素后移。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法一：交换元素值*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;         <span class="comment">//用来存储下一个要排序的元素</span></span><br><span class="line"><span class="keyword">int</span> sorted;       <span class="comment">//有序区的长度</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; n ; i++){<span class="comment">//从第二个元素开始排序</span></span><br><span class="line">sorted = i<span class="number">-1</span>;        <span class="comment">//有序区从头到将要排序的元素的前一个</span></span><br><span class="line">temp = p[i];         </span><br><span class="line"><span class="keyword">while</span>(sorted &gt;= <span class="number">0</span> &amp;&amp; p[sorted] &gt; temp){     <span class="comment">//从后向前比较，将比较和后移工作放在一个while循环里，因为不清楚循环次数所以使用while循环</span></span><br><span class="line">p[sorted+<span class="number">1</span>] = p[sorted];                <span class="comment">//从要排序的元素开始，前一个元素向后移</span></span><br><span class="line">sorted--;</span><br><span class="line">}</span><br><span class="line">p[sorted+<span class="number">1</span>] = temp;                         <span class="comment">//while循环结束即要排序的元素应在的位置</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法二：交换元素地址*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> sorted;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> *s = p,*e = p+n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( ; s &lt; e ; s++){</span><br><span class="line">sorted = s-p<span class="number">-1</span>;</span><br><span class="line">temp = *s;</span><br><span class="line"><span class="keyword">while</span>(sorted &gt;= <span class="number">0</span> &amp;&amp; *(p+sorted) &gt; temp){</span><br><span class="line">*(p+sorted+<span class="number">1</span>) = *(p+sorted);</span><br><span class="line">sorted--;</span><br><span class="line">}</span><br><span class="line">*(p+sorted+<span class="number">1</span>) = temp;</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><img src="https://ftp.bmp.ovh/imgs/2021/06/fd95b517223f9fc2.png" style="zoom:50%;"><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是利用递归不断将数组分成两份直到分成每个数组一个元素。然后将分好的有序小数组两两比较进行合并。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> temp[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span> l_pos = left; <span class="comment">//用来存储归并的两个数组中左半部分的首元素</span></span><br><span class="line"><span class="keyword">int</span> r_pos = mid+<span class="number">1</span>;<span class="comment">//用来存储归并的两个数组中右半部分的首元素</span></span><br><span class="line"><span class="keyword">int</span> pos = left;<span class="comment">//用来存储已经排序好的元素位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l_pos &lt;= mid &amp;&amp; r_pos &lt;= right){<span class="comment">//当两个数组中有剩余元素时</span></span><br><span class="line"><span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos]){<span class="comment">//将两个有序数组合并</span></span><br><span class="line">temp[pos++] = arr[l_pos++];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">temp[pos++] = arr[r_pos++];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l_pos &lt;= mid){<span class="comment">//如果只有左数组有剩余元素则直接填充</span></span><br><span class="line">temp[pos++] = arr[l_pos++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(r_pos &lt;= right){<span class="comment">//如果只有右数组有剩余元素则直接填充</span></span><br><span class="line">temp[pos++] = arr[r_pos++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right){<span class="comment">//将归并的这一部分复制到元素组中</span></span><br><span class="line">arr[left] = temp[left];</span><br><span class="line">left++; </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> temp[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(left &lt; right){<span class="comment">//如果没有划分成只剩一个元素的数组，就继续进行递归划分</span></span><br><span class="line"><span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;<span class="comment">//设置中间值</span></span><br><span class="line">mergeSort(arr,temp,left,mid);<span class="comment">//分别划分左半部分</span></span><br><span class="line">        mergeSort(arr,temp,mid+<span class="number">1</span>,right);<span class="comment">//和右半部分</span></span><br><span class="line">merge(arr,temp,left,mid,right); <span class="comment">//对划分好的数组进行合并</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showArr</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>{<span class="comment">//打印数组</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i++){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//分配暂时存储的数组</span></span><br><span class="line">showArr(arr,n);</span><br><span class="line"><span class="keyword">if</span>(temp){</span><br><span class="line">mergeSort(arr,temp,<span class="number">0</span>,n<span class="number">-1</span>);<span class="comment">//如果成功分配则进行排序</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR!"</span>);</span><br><span class="line">}</span><br><span class="line">showArr(arr,n);</span><br><span class="line"></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配KMP算法</title>
      <link href="/2021/06/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8DKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8DKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h1><p>给定一行字符串文本为主串，另一个字符串为模式串，在主串中查找模式串首次出现的位置，并返回其位置下标。</p><h2 id="蛮力法（BF）"><a href="#蛮力法（BF）" class="headerlink" title="蛮力法（BF）"></a>蛮力法（BF）</h2><p>即依次比较主串和模式串的每一个字母，碰见不匹配的字母时，主串和模式串从头右移一位重新匹配，直至成功或遍历完成。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> i,k,m;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="built_in">strlen</span>(S) - j ; i++ ){</span><br><span class="line">k = i ; </span><br><span class="line">m = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(k &lt;= i + j){</span><br><span class="line"><span class="keyword">if</span>( S[k++] != T[m++] )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>( k == i+j ){</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">char</span> S[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(S[i] != <span class="string">'\0'</span> &amp;&amp; T[j] != <span class="string">'\0'</span>){</span><br><span class="line"><span class="keyword">if</span>(S[i] == T[j]){</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">index++;</span><br><span class="line">i = index; </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(T[j] == <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="求字符串相等最大真前后缀"><a href="#求字符串相等最大真前后缀" class="headerlink" title="求字符串相等最大真前后缀"></a>求字符串相等最大真前后缀</h2><p>字符串的真前/后缀指不包括字符串自身的前缀/后缀。给定一个字符串，编写函数，求解字符串T所有前缀子串（包括自己）的最大相等真前后缀的长度，并存入next数组中。</p><h3 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h3><p>从长度为1开始判断，长度为1时输出0；长度为n（n&gt;=2），判断前n-1个字符和后n-1个字符是否相同，若不相同则减小比较的长度。知道找出相等真前后缀为止。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/dde53e3bd256248f.png" style="zoom:33%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxAffixLength</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">int</span> next[],<span class="keyword">int</span> length)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i,j,len;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,length*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> ; T[i] != <span class="string">'\0'</span> ; i++ ){<span class="comment">//计算[0,i]的最大真前后缀的长度 </span></span><br><span class="line"><span class="keyword">for</span>( len = i<span class="number">-1</span> ; len &gt;= <span class="number">1</span> ; len-- ){</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; len ; j++ ){ <span class="comment">//比较[0,len-1]和[i-len+1,i] </span></span><br><span class="line"><span class="keyword">if</span>( T[j] != T[i-len+j+<span class="number">1</span>] )  <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>( j == len ){</span><br><span class="line">next[i] = len;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="根据已求求下一个"><a href="#根据已求求下一个" class="headerlink" title="根据已求求下一个"></a>根据已求求下一个</h3><img src="https://ftp.bmp.ovh/imgs/2021/06/64b47a8e33b37c56.png" style="zoom:40%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PMT</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">int</span> next[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> i ,j ;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,NUM*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T[<span class="number">0</span>] == T[<span class="number">1</span>]){</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; T[i] != <span class="string">'\0'</span> ; i++ ){  <span class="comment">//计算【0，i】的最大真前后缀的长度 </span></span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span>( j != <span class="number">0</span> ){</span><br><span class="line"><span class="keyword">if</span>( T[i] == T[next[j<span class="number">-1</span>]] ){</span><br><span class="line">next[i] = next[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">j = next[j<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>有效利用已匹配的前缀，减少指针回溯。</p><p>整体思路：在已匹配的前缀当中寻找到最长可匹配后缀子串和最长可匹配前缀子串，在下一轮中直接把两者对齐，从而实现模式串的快速移动。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/aa039bb509dc3ba5.png" style="zoom:80%;"><p>​                                                                                                                                                                （图源知乎）</p><p>next数组是我们上面求的最大真前后缀数组进行处理后得到的。</p><p>处理：将每一位的最大真前后缀字符数向后移一格。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法主体逻辑。str是主串，pattern是模式串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[],<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//主循环，遍历主串字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(S); i++) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; S[i] != T[j]) </span><br><span class="line">        {</span><br><span class="line">            j = next[j];<span class="comment">//遇到坏字符时，查询next数组并改变模式串的起点继续与主串进行匹配，直到移到子串起始字符不成功，则主串继续移动进行匹配 </span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) {</span><br><span class="line">            j++;</span><br><span class="line">        }<span class="keyword">if</span> (j == <span class="built_in">strlen</span>(T)) {<span class="comment">//匹配成功，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> i - <span class="built_in">strlen</span>(T) + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯和递归算法总结</title>
      <link href="/2021/05/30/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2021/05/30/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="分书问题"><a href="#分书问题" class="headerlink" title="分书问题"></a>分书问题</h2><img src="https://ftp.bmp.ovh/imgs/2021/06/9d4613e7aa04fd0d.png" style="zoom:33%;"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>(1) 定义一个整型的二维数组，将表中的<strong>阅读喜好</strong>用初始化方法赋给这个二维数组。可定义：</p><p>int like[5][5] = { {0,0,1,1,0}, {1,1,0,0,1}, {0,1,1,0,1}, {0,0,0,1,0}, {0,1,0,0,1} }; </p><p>(2) 定义一个整型一维数组book[5]，用来<strong>记录书是否已被选用</strong>。用下标作为5本书的编号，被选过元素值为1，未被选过元素值为0，初始化皆为0。</p><p>int book[5] = {0,0,0,0,0};</p><p>(3) 画出思路图。</p><p>① 定义试着给第i人分书的函数Try(i)，i = 0,1,2,3,4。</p><p>② 试着给第i个人分书，先试分0号书，再分1号书，分2号书，……，因此有一个与结点，让j表示书，j=0，1，2，3，4。</p><p>③条件c是由两部分“与”起来的，“第i个人喜欢j书，且j书尚未被分走”。满足这个条件是i人能够得到j书的条件。 </p><p>④ 如果不满足c条件，则什么也不做，这是直接可解结点。、</p><p>⑤ 满足c条件，做三件事：<br>      第一件事：将j书分给i，用一个数组take[i]=j,记住书j给了i，同时记录j书已被选用，book[j]=1.<br>      第二件事：查看i是否为4，如果不为4，表示尚未将所有5个人所要的书分完，这时应递归再试下一个人，即Try(i+1)。若果i==4，则应先使方案数n=n+1，然后输出第n个方案下的每个人所得之书。<br>      第三件事：回溯。让第i人退回j书，恢复j书尚未被选的标志，即book[j]=0.这是在已输出第n个方案之后，去寻找下一个分书方案所必需的。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/11064001369b467f.png" style="zoom:33%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>] = { {<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>}, {<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>}, {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>}, {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>}, {<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>} }; <span class="comment">//表示书的喜好情况 </span></span><br><span class="line"><span class="keyword">int</span> book[<span class="number">5</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};  <span class="comment">//表示书是否分走 </span></span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>] = {<span class="number">0</span>};  <span class="comment">//表示分书情况 </span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Try</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j,k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">5</span> ; j++){ <span class="comment">//表示书号 </span></span><br><span class="line"><span class="keyword">if</span>(like[i][j] == <span class="number">1</span> &amp;&amp; book[j] == <span class="number">0</span>){<span class="comment">//这人喜欢这书且书还没被分走 </span></span><br><span class="line">take[i] = j;<span class="comment">//记录该人拿走该书</span></span><br><span class="line">book[j] = <span class="number">1</span>;<span class="comment">//记录该书已被分走 </span></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">4</span>){ <span class="comment">//所有人都分好书</span></span><br><span class="line">n++;<span class="comment">//方案数增加，准备打印分数方案</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"==========第%d个方案是==========\n"</span>,n);</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; <span class="number">5</span> ; k++){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个人拿的第%d本书\n"</span>,k+<span class="number">1</span>,take[k]+<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{<span class="comment">//书还没分完 </span></span><br><span class="line">Try(i+<span class="number">1</span>);<span class="comment">//满足这个人的需求后，继续尝试分后边的书 </span></span><br><span class="line">}</span><br><span class="line">book[j] = <span class="number">0</span>;<span class="comment">//回溯时将书退回</span></span><br><span class="line">}<span class="comment">//如果没有找到就继续尝试下一本书 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">Try(<span class="number">0</span>);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将整个问题拆解成几个小问题，分步解决。</p><p>1.判断是否可以放下皇后棋子（同行同列同对角线上还没有棋子）</p><p>2.try函数用来实现递归和回溯</p><p>3.打印结果</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> place[<span class="number">8</span>] = {<span class="number">0</span>};<span class="comment">//皇后放置的位置</span></span><br><span class="line"><span class="keyword">int</span> snum = <span class="number">0</span>;<span class="comment">//方法总数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"===第%d个方案\n"</span>,++snum);</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d行的皇后放置在第%d列\n"</span>,i,place[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; <span class="number">8</span> ; k++ ){</span><br><span class="line"><span class="keyword">if</span>(place[k] == j || <span class="built_in">abs</span>(place[k] - j ) == <span class="built_in">abs</span>(k - i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">7</span>){</span><br><span class="line">showResult();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ ){</span><br><span class="line"><span class="keyword">if</span>(canPlace(i,j)){ </span><br><span class="line">place[i] = j;</span><br><span class="line"><span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">place[i] = <span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">try</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对于法一，法二使用的二维数组更加直观</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> chessboard[<span class="number">8</span>][<span class="number">8</span>] = {<span class="number">0</span>};<span class="comment">//棋盘的位置是否有元素 </span></span><br><span class="line"><span class="keyword">int</span> snum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isDanger</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>{ </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){<span class="comment">//row</span></span><br><span class="line"><span class="keyword">if</span>(chessboard[row][i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){<span class="comment">//column</span></span><br><span class="line"><span class="keyword">if</span>(chessboard[i][col] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ ){</span><br><span class="line"><span class="keyword">if</span>( chessboard[i][j] == <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(i-row) == <span class="built_in">abs</span>(j-col) )</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"====第%d个方案====\n"</span>,++snum);</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ ){</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ ){</span><br><span class="line"><span class="keyword">if</span>( chessboard[i][j] == <span class="number">1</span> )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"chessboard[%d][%d]\n"</span>,i,j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eightQueen</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="keyword">if</span>( row &gt; <span class="number">7</span> ){</span><br><span class="line">printResult();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>( col = <span class="number">0</span> ; col &lt; <span class="number">8</span> ; col++ ){</span><br><span class="line"><span class="keyword">if</span>(isDanger(row,col)){</span><br><span class="line">chessboard[row][col] = <span class="number">1</span>;</span><br><span class="line">eightQueen( row + <span class="number">1</span> );</span><br><span class="line">chessboard[row][col] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">eightQueen(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>每个物品有两种状态及放入和未放入。我们假设除最后一个以外的前面已经是最优解，再找出最后一个的最优解即可。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/25f4115791e1d802.png" style="zoom:33%;"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">5</span>] = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>};</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">5</span>] = {<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">int</span> value1,value2;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(weight[i] &lt;= j &amp;&amp; i != <span class="number">-1</span>){   <span class="comment">//物体质量小于背包容量且不是无效数据 </span></span><br><span class="line">value1 = <span class="built_in">exp</span>(i<span class="number">-1</span>,j-weight[i]) + value[i];      <span class="comment">//这个物体放入后的价值</span></span><br><span class="line">value2 = <span class="built_in">exp</span>(i<span class="number">-1</span>,j);   <span class="comment">//不放的价值</span></span><br><span class="line">value1 &gt; value2 ? (max = value1) : (max = value2); <span class="comment">//比较选择放入或不放</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line">result = <span class="built_in">exp</span>(<span class="number">4</span>,<span class="number">10</span>);<span class="comment">//需要检测的物体个数，背包容量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="素数环问题"><a href="#素数环问题" class="headerlink" title="素数环问题"></a>素数环问题</h2><p>用1~n共n个不重复整数构造一个环形结构，使相邻两个数之和为素数。</p><p>如下图是一个n=6的素数环。</p><img src="https://ftp.bmp.ovh/imgs/2021/06/3d0e41fcccd808f1.png" style="zoom:50%;"><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>同样把问题拆解成几个负责不同功能的函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//判断是否为素数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,k;</span><br><span class="line">k = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> n)</span>  <span class="comment">//传入数组首指针，要放置的位置，要放置的数值，数组大小，函数用来检查能不能放入该数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k,flag;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;i;k++)<span class="comment">//检查前面是否已经使用过该数</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(p[k]==j)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">flag = isPrime(j+p[i<span class="number">-1</span>]); <span class="comment">//若放置则与前数和是否为素数</span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span> &amp;&amp; i==n<span class="number">-1</span>)     <span class="comment">//若是最后一个位置则需要和第一个数构成素数环</span></span><br><span class="line">{</span><br><span class="line">flag = isPrime(j+p[<span class="number">0</span>]); </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n)</span>  <span class="comment">//传入数组首地址和数组大小</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****第%d个解****\n"</span>,++count);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeCycle</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j,k;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);  <span class="comment">//动态开辟数组空间</span></span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">//数组置零</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//先给第0号位赋上值 ，因为是环状结构，为避免出现相同结构的解，将第一个元素固定。</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=p[i]+<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//找出能在该位置放置的满足条件的第一个数。如果是第一次寻找，则j从1开始，若是回溯，则从上次确定的值开始</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(canPlace(p,i,j,n)==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">p[i] = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(j&gt;n)   <span class="comment">//如果上一个循环正常结束，即该位置没有可放置的数</span></span><br><span class="line">{</span><br><span class="line">p[i--] = <span class="number">0</span>;   <span class="comment">//p[i]=0;i--;回溯至上一个位置,这个位置置0。</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>)   <span class="comment">//如果最后一个位置的数也放置完毕，则输出结果，并将前一个数置零以便寻找下一种解情况</span></span><br><span class="line">{</span><br><span class="line">showResult(p,n);</span><br><span class="line">p[i--] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>              <span class="comment">//如果还没有放置完数，则将i++继续进行大循环。</span></span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放空间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"finished\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input an integer\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">primeCycle(n);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>待编辑…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于回调和反射的简单分享</title>
      <link href="/2021/05/22/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E4%BA%AB/"/>
      <url>/2021/05/22/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">(Door door)</span></span>{</span><br><span class="line">        door.open(); </span><br><span class="line">        System.out.println(<span class="string">"新的一天开始了"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>{</span><br><span class="line">        System.out,println(<span class="string">"门被打开了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在打印“新的一天开始了”内容时，door.open()方法已经执行结束。（可能会造成阻塞问题）</p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openDoor</span><span class="params">(Door door)</span></span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable(){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">                door.open();  </span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        System.out.println(<span class="string">"新的一天开始了"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>{</span><br><span class="line">        System.out,println(<span class="string">"门被打开了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将调用放在一个新的线程中，后边的操作将不再依赖于调用方法的结束。（解决同步调用的阻塞问题）</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>双向调用模式</p><p><em>A callback is a function this is passed as an argument to another function and is executed after its patent function has completed.</em></p><p><em>回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行</em></p><p>回调的思想是：<strong>一.类A的a()方法调用类B的b()方法</strong></p><p>​                           <strong>二.类B的b()方法执行完毕主动调用类A的callback()方法</strong></p><p>原理：首先创建一个回调对象，然后再创建一个控制器对象，将回调对象需要被调用的方法告诉控制器对象，控制器对象负责检查某个场景是否出现或某个条件是否满足，当满足时，自动调用回调对象的方法。</p><h3 id="例一："><a href="#例一：" class="headerlink" title="例一："></a>例一：</h3><p>情景：老板A对员工B说，我现在交给你一个任务，并且我把我的电话号码给你，你一旦完成任务就给我打电话。</p><p>1.创建一个回调接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptEvent</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.创建回调接口的实现类，即本例中的老板类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">CallBack</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话给老板，告知已经完成工作了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.创建控制类，也就是本例中的员工对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    CallBack callBack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(CallBack callBack)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.callBack=callBack;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"工作中...."</span>);</span><br><span class="line">        callBack.acceptEvent();<span class="comment">//接口实现类的对象调用接口中的方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>创建测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//创建控制器对象，将提供给他的回调对象传入</span></span><br><span class="line">        Employee employee=<span class="keyword">new</span> Employee(<span class="keyword">new</span> Boss());    <span class="comment">//传递一个实现接口的类的对象</span></span><br><span class="line">        <span class="comment">//启动控制器对象运行</span></span><br><span class="line">        employee.doWork();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在本例中，如果员工的工作结果可能不止向一类人传递，比如还会给经理、测试等人传递结果。这时我们可以将接收结果这个方法看做一种公共需求，接收到结果后后续处理操作也不一样，我们可以将这个方法定义到接口中，再在具体的类中进行实现。</p><h3 id="例二：（安卓中的实例）"><a href="#例二：（安卓中的实例）" class="headerlink" title="例二：（安卓中的实例）"></a>例二：（安卓中的实例）</h3><p>在android中回调机制被大量的使用。比如，在Activity中定义了很多生命周期的不同状态要调用的方法，这些方法都是空实现，系统框架要调用，用户也要调用来实现。</p><p>　　举个简单的例子就是Button的点击响应事件实现机制</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.view.View;  </span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;  </span><br><span class="line"><span class="keyword">import</span> android.widget.Button;  </span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 这个就相当于Class A </span></span><br><span class="line"><span class="comment"> * 实现了 OnClickListener接口</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>{  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Class A 包含Class B(View)的引用</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> Button button;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        button = findViewById(R.id.button1);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 b </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用户点击Button时调用的回调函数，你可以做你要做的事  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{  </span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"OnClick"</span>, Toast.LENGTH_LONG).show();  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="例三：（还是安卓实例）"><a href="#例三：（还是安卓实例）" class="headerlink" title="例三：（还是安卓实例）"></a>例三：（还是安卓实例）</h3><p> 点击文本框弹出对话框，将输入的文字显示在文本框中。</p><p><a href="https://github.com/liuyuxin-cloud/Android/tree/main/callbackdemo">https://github.com/liuyuxin-cloud/Android/tree/main/callbackdemo</a></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p><p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p><p><strong>反射机制使java具有动态特性</strong></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><img src="https://ftp.bmp.ovh/imgs/2021/06/d693bb0688d7f75d.png" style="zoom:33%;"><p>关于java.lang.Class 类的理解</p><p>​    将类编译生成字节码文件(.class)再用(java.exe)命令对每个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。</p><p>加载到内存中的类称为运行时类，它们是Class类的实例。</p><p>（java万物皆对象  我们的自定义类是Class类的对象）</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1、反编译：.class–&gt;.java</p><p>2、通过反射机制访问java对象的属性，方法，构造方法等</p><p>3、当我们在使用IDE,比如Ecplise，IntelliJ IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p><p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p><p>例子：</p><img src="https://ftp.bmp.ovh/imgs/2021/06/af8de99466562b90.png" style="zoom:33%;"><p>反射前对于自定义类的操作：</p><p>1.通过构造器实例化对象</p><p>2.通过对象调用内部属性、方法</p><p>3.在类外部不可以通过对象调用内部私有(private)结构（封装性的限制）</p><p>反射后：</p><p>1.通过反射创建类的对象</p><p>2.通过反射调用对象指定的属性、方法</p><p>3.通过反射可调用类的私有结构</p><p>什么时候使用反射？</p><p>1.具有动态性时</p><p>2.编译时不确定造哪个对象时</p><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>Java.lang.Class;</p><p>Java.lang.reflect.Constructor;</p><p>Java.lang.reflect.Field;</p><p>Java.lang.reflect.Method;</p><p>Java.lang.reflect.Modifier;</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>1、获得Class：主要有三种方法：</strong></p><p>（1）Object–&gt;getClass</p><p>（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性</p><p>（3）通过class类的静态方法：forName(String className)（最常用）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">Class stuClass2 = Student.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式获取Class对象</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">Class stuClass3 = Class.forName(<span class="string">"fanshe.Student"</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">} <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2、判断是否为某个类的示例：</strong></p><p>一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>3、创建实例：通过反射来生成对象主要有两种方法：</strong></p><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;Object str = c.newInstance();</span><br></pre></td></tr></tbody></table></figure><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String的Class对象</span></span><br><span class="line">Class&lt;?&gt; str = String.class;<span class="comment">//通过Class对象获取指定的Constructor构造器对象</span></span><br><span class="line">Constructor constructor=c.getConstructor(String.class);<span class="comment">//通过参数判断指定的构造器</span></span><br><span class="line"><span class="comment">//根据构造器创建实例：</span></span><br><span class="line">Object obj = constructor.newInstance(“hello reflection”);</span><br></pre></td></tr></tbody></table></figure><p><strong>4、通过反射获取构造方法并使用：</strong></p><p>（1）批量获取的方法：<br>public Constructor[] getConstructors()：所有”公有的”构造方法<br>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p><p>（2）单个获取的方法，并调用：<br>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：<br>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p><p><a href="https://blog.csdn.net/a745233700/article/details/82893076">https://blog.csdn.net/a745233700/article/details/82893076</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python笔记</title>
      <link href="/2021/05/21/Python%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/21/Python%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="变量和简单数据类型"><a href="#变量和简单数据类型" class="headerlink" title="变量和简单数据类型"></a>变量和简单数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>引号括起来的都是字符串</strong></p><p><strong>修改大小写</strong></p><p>.title()                每个单词首字母大写</p><p>.upper()            全大写</p><p>.lower()             全小写</p><p><strong>在字符串中使用变量</strong></p><p>在字符串中插入变量的值，在前引号前加上f（format）在字符串内将插入的变量用{}括起。</p><p><strong>删除空白</strong></p><p>python能找出字符串开头和结尾多余的空白。</p><p>.rstrip()            删除结尾的空白（暂时）永久删除需关联到变量</p><p>.lstrip()                    开头</p><p>.strip()                     开头和结尾</p><h3 id="数"><a href="#数" class="headerlink" title="数"></a>数</h3><p><strong>整数</strong></p><p>**表示乘方运算</p><p><strong>浮点数</strong></p><p>结果包含的小数位数可能是不确定的</p><p>任意两个数相除时，结果总是浮点数。</p><p><strong>下划线</strong></p><p>可使用下划线将数字分组不会打印下划线</p><p><strong>赋值</strong></p><p>可同时给多个变量赋值</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y,z = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p><strong>常量</strong></p><p>python没有内置的常量类型，通常使用全大写来指出将某个变量视为常量。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>python用#注释一行</p><h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a>列表简介</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>用[]表示列表，用逗号分隔其中元素。</p><p>打印列表时会将[]一同打印。</p><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><p>添加索引     打印时不打印[]</p><p>索引从0开始</p><p>当索引为负数时，python将从列表最后一个元素开始访问。</p><h3 id="元素的增删改"><a href="#元素的增删改" class="headerlink" title="元素的增删改"></a>元素的增删改</h3><p>创建的列表大多是动态的。</p><p><strong>改</strong>        拿出索引，指定新值。</p><p><strong>增</strong>        1. 末尾（附加）         .append(‘ ‘)</p><p>​            2. 插入                        .insert(  <em>int</em> ,’ ‘)         指定新元素索引，将后方元素后移</p><p><strong>删</strong>        1. del语句                    del  <em>name</em>[<em>int</em>]        删除指定索引元素，后方元素前移</p><p>​            2. pop()方法                .pop()                      删除列表中元素并可继续使用。</p><p>​                                                                                  弹出列表末尾的元素。</p><p>​                                                 .pop(<em>int</em>)                  弹出任意位置的元素</p><p>​            3. remove()方法         .remove(‘ ‘)             根据值删除元素(也可继续使用这个值)</p><h3 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h3><p><strong>永久排序</strong>                    .sort()                                    按字母顺序</p><p>​                                   .sort(reverse=True)             按反字母顺序</p><p><strong>临时排序</strong>                    sorted(<em>name</em>)                       可临时按顺序或反顺序</p><p><strong>反转排列顺序</strong>            .reverse()                              永久性修改</p><p><strong>确定列表长度</strong>            len(<em>name</em>)                            </p><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><p><strong>for循环</strong>        for item in list_of_items:</p><p>​                            to do …</p><p>将对每个元素执行相同的操作，知道列表中的元素遍历结束。</p><h3 id="数字列表"><a href="#数字列表" class="headerlink" title="数字列表"></a>数字列表</h3><p><strong>函数range()</strong>                                    轻松生成一系列数：range(<em>int1</em>,<em>int2</em>)    # int1 ~ int2 - 1</p><p>​                                                                                            range(<em>int</em>)             #  0 ~ int - 1</p><p>​                                                         可指定生成数的步长：range(<em>int1</em>,<em>int2</em>,<em>int3</em>)        # 从int1开始每次增加int3直至大于等于int2</p><p><strong>使用range()创建数字列表</strong>            使用list()将range()结果转化为列表：<em>name</em> = list(range(<em>int</em>))</p><p><strong>进行简单计算</strong>                                  <em>numbers</em> = [<em>int1</em>,…,<em>intn</em>]            min(<em>number</em>)        #最小值</p><p>​                                                                                                             max(<em>number</em>)       #最大值</p><p>​                                                                                                             sum(<em>number</em>)       #求和</p><p><strong>列表解析</strong>                                        </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;[1,4,9,16,25,36,49,64,81,100]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用列表的一部分"><a href="#使用列表的一部分" class="headerlink" title="使用列表的一部分"></a>使用列表的一部分</h3><p><strong>切片</strong>                                            <em>name</em>[<em>int1</em> : <em>int2</em>]                    #索引由int1开始到int2-1结束</p><p>​                                                                                                    #省略int1时从头开始，省略int2时到末尾结束。可为负数。</p><p>​                                                                                                    #可使用for循环遍历</p><p><strong>复制列表</strong>                                    <em>new_list</em> = <em>name</em>[ : ]                #复制，将副本赋值给new_list</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>定义一系列不可修改的元素</p><p><strong>定义</strong>                                            <em>name</em> = (item1,…,itemn)    #使用（）定义元组  <strong>只有一个元素时要在后面加上逗号</strong></p><p><strong>遍历</strong>                                            使用for循环</p><p><strong>修改</strong>                                            重新定义整个元组</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><strong>基本格式</strong>                                        </p><p>​                                                                          if   <em>something</em> :</p><p>​                                                                                <em>to do…</em></p><p>​                                                                           elif  <em>something</em>:</p><p>​                                                                                <em>to do…</em></p><p>​                                                                           else :</p><p>​                                                                                <em>to do…</em></p><p><strong>检查多个条件</strong>                                                    使用and/or关键字</p><p><strong>检查特定值是否包含/不包含在列表中</strong>            ‘<em>item</em>‘ in <em>list_name</em> </p><p>​                                                                            ‘<em>item</em>‘ not in <em>list_name</em></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p><strong>简介</strong>                在python中，<strong>字典</strong>是一系列<strong>键值对</strong>。与<strong>键</strong>关联的<strong>值</strong>可以是数、字符串、列表乃至字典。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = {<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p><strong>访问字典中的值</strong>                    依次指定字典名和放在方括号内的键。                #<em>name</em>[‘<em>item</em>‘]</p><p><strong>添加键值对</strong>                            依次指定字典名和放在方括号内的键及赋值。    #<em>name</em>[‘<em>item</em>‘] = ‘<em>value</em>‘</p><p><strong>改</strong>                                           依次指定字典名和放在方括号内的键及修改值。#<em>name</em>[‘item’] = ‘<em>new value</em>‘</p><p><strong>删</strong>                                            del语句 依次指定字典名和放在方括号内的键。#del <em>name</em>[‘<em>item</em>‘]     </p><p><strong>由类似对象组成的字典</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = {</span><br><span class="line"><span class="string">'jen'</span>:<span class="string">'python'</span>,</span><br><span class="line"><span class="string">'sarah'</span>:<span class="string">'java'</span>,</span><br><span class="line"><span class="string">'edward'</span>:<span class="string">'c'</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>使用get()来访问值</strong>               当指定的键不存在时会出错，但在使用get()方法时会返回一个默认值。</p><p>​                                                #<em>name</em>.get(‘<em>item</em>‘,<em>default value</em>)默认值可不指定，将返回none</p><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p><strong>遍历所有键值对</strong>                    for循环                    #for key,value in <em>name</em>.items():</p><p>​                                                                                #key,value可以使用任意名称</p><p><strong>遍历所有键</strong>                            for循环                    #for key in <em>name</em>.keys():</p><p>​                                                                                #实际上返回一个列表，包含字典中所有键</p><p><strong>按特定顺序遍历所有键</strong>        for循环                    #可使用sorted()函数对keys进行排序</p><p><strong>遍历所有值</strong>                           for循环                    #for value in <em>name</em>.values():</p><p>​                                                                               #需要考虑剔除重复项时可使用set()方法  结果是一个不                                                                                    重复的列表</p><p>​                                                                               #可直接用{}创建集合，集合中元素不会重复。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p><strong>字典列表</strong>                                先创建几个字典，后将字典存储到列表中</p><p><strong>在字典中存储列表</strong>                将列表作为字典里的值；可使用二重循环遍历字典中的列表</p><p><strong>在字典中存储字典</strong>                嵌套在字典里的字典尽可能具有相同结构</p><h2 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h2><h3 id="函数input（）的工作原理"><a href="#函数input（）的工作原理" class="headerlink" title="函数input（）的工作原理"></a>函数input（）的工作原理</h3><p><strong>input(<em>string</em>)</strong>                        接收一个参数用来向用户显示的提示或说明。接收用户输入的字符串</p><p><strong>int()</strong>                                        将接收到的字符串类型的数字转化为int类型</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>设置退出条件</strong>                        while   <em>option</em></p><p><strong>使用标志</strong>                                while   <em>flag</em>    当要求很多条件满足时才继续运行时，可定义一个变量，用于判断整个程序是否处于活动状态。</p><p>​                                                #active = True 当有条件使active = False时退出循环。</p><p><strong>使用break、continue</strong></p><h3 id="使用while循环处理列表和字典"><a href="#使用while循环处理列表和字典" class="headerlink" title="使用while循环处理列表和字典"></a>使用while循环处理列表和字典</h3><p>for循环是一种遍历列表的有效方式，但<strong>不应在for循环中修改列表</strong>，在<strong>遍历列表同时修改</strong>时，使用while循环。</p><p><strong>在列表之间移动元素</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先，创建一个待验证的用户列表</span></span><br><span class="line"><span class="comment">#  和一个用于存储的已验证用户的空列表。</span></span><br><span class="line">unconfirmed_users = [<span class="string">'alice'</span>,<span class="string">'brain'</span>,<span class="string">'candace'</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证每一个用户，直到没有未验证的用户为止。</span></span><br><span class="line"><span class="comment">#  将每个经过验证的用户都移到已验证用户列表中</span></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = uncomfirmed_users.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Verifying user:<span class="subst">{current_user.title()}</span>"</span>)</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#显示所有已验证的用户</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n The following users have been confirmed:"</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    <span class="built_in">print</span>(confirmed_user.title())</span><br></pre></td></tr></tbody></table></figure><p><strong>删除为特定值的所有列表元素</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">'cat'</span>,<span class="string">'dog'</span>,<span class="string">'fish'</span>,<span class="string">'cat'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">pets.remove(<span class="string">'cat'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>def  <em>f_name</em>():                            def关键字定义函数</p><p>“””对函数作用的解释”””            文档字符串的注释</p><h3 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h3><p><strong>位置实参</strong>                                    根据函数中的形参位置对应实参</p><p><strong>关键字实参</strong>                                即用  <em>形参名= ‘实参 ‘</em>  指定</p><p><strong>返回值</strong>                                        直接  <em>return</em></p><p><strong>默认值</strong>                                        定义时可为参数设置默认值  <em>形参 = ‘ …’</em></p><p><strong>参数可选</strong>                                    当有参数可以不必传入时，将该参数定义在最后并用空串设为默认值</p><p><strong>返回字典</strong>                                    在方法中定义字典，return字典名</p><p><strong>传递列表</strong>                                    可将列表名作为参数传给函数</p><p><strong>禁止函数修改列表</strong>                    将列表的副本传给函数            <em>function_name(list_name[:])</em>    #切片表示法[:]创建列表的副本。</p><p><strong>传递任意数量的实参</strong>                只有一个形参 形参前加上星号*    <em>def  f_name(*params)</em>        #*代表让python创建一个名为params的空元                                                   组，并将所有接收到的值都封装进这个元组中</p><p><strong>使用任意数量关键字实参</strong>        在关键字形参前加上两个星号，代表让python创建一个空字典。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span>(<span class="params">first,last,**user_info</span>):</span></span><br><span class="line"><span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">user_info[<span class="string">'first_name'</span>] = first</span><br><span class="line">user_info[<span class="string">'last_name'</span>] = last</span><br><span class="line"><span class="keyword">return</span> user_info</span><br><span class="line"></span><br><span class="line">user_profile = bulid_profile(<span class="string">'albert'</span>,<span class="string">'einstein'</span>,</span><br><span class="line"> location = <span class="string">'princeton'</span></span><br><span class="line"> field = <span class="string">'physics'</span>)</span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">'location'</span> : <span class="string">'princeton'</span>, <span class="string">'field'</span> : <span class="string">'physics'</span>,<span class="string">'first_name'</span> : <span class="string">'albert'</span>,<span class="string">'last_name'</span> : <span class="string">'einstein'</span>}</span><br></pre></td></tr></tbody></table></figure><h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h3><p>import语句允许在当前运行的程序中使用模块中的代码。</p><p><strong>导入整个模块</strong>                            模块是扩展名为.py 的文件，import+<em>module_name</em> 即可导入模块并使用其中的函数</p><p>​                                                    #<em>module_name.fuction_name</em></p><p><strong>导入特定函数</strong>                            from  <em>module_name</em>  import  <em>function_0,function_1,function_2</em></p><p><strong>使用as给函数指定别名</strong>            要导入的函数的名称可能与程序中现有的名称冲突，或者因为函数名称太长，可指定独一无二的别名。</p><p>​                                                   #  <em>from module_name import function_name as nike_name</em></p><p><strong>给模块指定别名</strong>                        #  <em>import module_name as nike_name</em></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>#类名首字母大写</span></span><br><span class="line"><span class="class">"""创建类"""</span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">__init__</span>(<span class="params">self,*name,age*</span>)#相当于构造器 初始化属性 <span class="title">self</span>形参必须有且位于最前 每次创建实例时<span class="title">python</span>自动运行</span></span><br><span class="line">self.name = name        </span><br><span class="line">self.age = age            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name0</span>    #...        #...    </span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">function_name1</span>    #...        #...        </span></span><br></pre></td></tr></tbody></table></figure><h3 id="根据类创建实例"><a href="#根据类创建实例" class="headerlink" title="根据类创建实例"></a>根据类创建实例</h3><p>跟java类似                        instanse1 = class_name(params)</p><p>待编辑……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习第三次</title>
      <link href="/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E6%AC%A1/"/>
      <url>/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%89%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java复习第三次"><a href="#java复习第三次" class="headerlink" title="java复习第三次"></a>java复习第三次</h1><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>lambda表达式是一个<strong>可传递的代码块</strong>，可在以后执行一次或多次。lambda表示参数。</p><p>Lambda 允许把<strong>函数</strong>作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h3><p><strong>-&gt;</strong>    操作符将lambda表达式分为两个部分            左侧：lambda表达式的参数列表            右侧：lambda表达式所执行的功能即lambda体</p><p><strong>1.无参数，无返回值</strong></p><p>无参数仍要提供空括号，就像无方法参数一样。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>2.一个参数，无返回值</strong></p><p>当参数类型可推导得出时小括号可以省略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br><span class="line">x -&gt; System.out.println(x);</span><br></pre></td></tr></tbody></table></figure><p><strong>3.多个参数，有返回值</strong></p><p>当参数类型可推导得出时参数类型可省略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x – y ;</span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y ;  </span><br></pre></td></tr></tbody></table></figure><p><strong>4.只有一条语句</strong></p><p>大括号和return都可以省略</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x – y ;</span><br></pre></td></tr></tbody></table></figure><p><strong>5.有多条语句</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x,y) -&gt; {</span><br><span class="line">System.out.println(<span class="string">"函数式接口"</span>);</span><br><span class="line"><span class="keyword">return</span> x - y ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口。</p><p><strong>是lambda表达式使用的前提</strong></p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p><strong>只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用</strong></p><p> <strong>对象::实例方法</strong>    objectName::instanceMethod                     将lambda的参数当做方法的参数使用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; sc = System.out::println;</span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line">Consumer&lt;String&gt; sc2 = (x) -&gt; System.out.println(x);</span><br><span class="line">sc.accept(<span class="string">"618, 狂欢happy"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>类::静态方法</strong>        ClassName::staticMethod                             将lambda的参数当做方法的参数使用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; sf = String::valueOf;</span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line">Function&lt;Integer, String&gt; sf2 = (x) -&gt; String.valueOf(x);</span><br><span class="line">String apply1 = sf.apply(<span class="number">61888</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>类::实例方法</strong>       ClassName::instanceMethod                        将lambda的第一个参数当做方法的调用者，其他的参数作为方法的参数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; sbp = String::equals;</span><br><span class="line"><span class="comment">//等效</span></span><br><span class="line">BiPredicate&lt;String, String&gt; sbp2 = (x, y) -&gt; x.equals(y);</span><br><span class="line"><span class="keyword">boolean</span> test = sbp.test(<span class="string">"a"</span>, <span class="string">"A"</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>与方法引用类似，不过方法名为new</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] :: <span class="keyword">new</span><span class="comment">//等价x -&gt; new int[x]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>内部类：</strong> 所谓内部类就是在一个类内部进行其他类结构的嵌套操作。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。</p><p><strong>为什么使用？</strong></p><p>在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，<strong>间接解决类无法多继承引起的一系列问题</strong>。</p><p>例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> String str =<span class="string">"外部类中的字符串"</span>;</span><br><span class="line">    <span class="comment">//************************** </span></span><br><span class="line">    <span class="comment">//定义一个内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line">        <span class="keyword">private</span> String inStr= <span class="string">"内部类中的字符串"</span>;</span><br><span class="line">        <span class="comment">//定义一个普通方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="comment">//调用外部类的str属性</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************** </span></span><br><span class="line">    <span class="comment">//在外部类中定义一个方法，该方法负责产生内部类对象并调用print()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//内部类对象</span></span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="comment">//内部类对象提供的print</span></span><br><span class="line">        in.print();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//创建外部类对象</span></span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//外部类方法</span></span><br><span class="line">        out.fun();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li><p>内部类与外部类可以方便的访问彼此的私有域（包括私有方法、私有属性）。</p></li><li><p>内部类是另外一种封装，对外部的其他类隐藏。</p></li><li><p>内部类可以实现java的单继承局限。</p></li><li><p>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</p></li><li><p>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</p></li><li><p>创建内部类对象的时刻并不依赖于外围类对象的创建。</p></li><li><pre><code class="java">class A {    private String name = "A类的私有域";    public String getName() {        return name;    }}class B {    private int age = 20;    public int getAge() {        return age;    }}class Outter {    private class InnerClassA extends A {        public String name() {            return super.getName();    }}    private class InnerClassB extends B {        public int age() {            return super.getAge();    }}    public String name() {        return new InnerClassA().name();    }    public int age() {        return new InnerClassB().age();    }}public class Test2 {        public static void main(String[] args) {            Outter outter = new Outter();            System.out.println(outter.name());            System.out.println(outter.age());        }}</code></pre></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://blog.csdn.net/weixin_42762133/article/details/82890555">https://blog.csdn.net/weixin_42762133/article/details/82890555</a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>待编辑……..</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习第二次</title>
      <link href="/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1/"/>
      <url>/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java复习第二次"><a href="#java复习第二次" class="headerlink" title="java复习第二次"></a>java复习第二次</h1><h2 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h2><p>表明正在构造的新类派生于一个已存在的类。称为超类、基类或父类，新类称为子类。</p><p>应将最一般的方法放在超类中，更一般的方法放在子类中。</p><h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>在子类中，可以增加字段、方法或覆盖超类的方法，但继承不会删除任何字段或方法。</p><p>调用超类方法/构造器使用关键字super。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>指对象变量是多态的，指超类的任何对象的任何地方都可以使用子类对象替换。（子类对象具有子类和超类的性质，但超类对象不一定具有子类的性质）</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>1.编译器查看对象的类型声明和方法名。会列举所有同名方法。</p><p>2.确定方法调用的参数进行匹配。</p><p>3.如果方法被private、final、static修饰，则编译器能准确调用（静态绑定）。</p><p>4.采用动态绑定调用方法时，虚拟机会调用与所引用对象实际类型对应的方法。优先调用子类的，若子类未定义，则调用超类方法。</p><h3 id="阻止继承（final）"><a href="#阻止继承（final）" class="headerlink" title="阻止继承（final）"></a>阻止继承（final）</h3><p>阻止继承类：将类声明为final</p><p>阻止子类覆盖方法：将方法声明为final</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将子类对象赋值给超类是可以的，但将超类对象赋值给子类必须进行强转。<strong>在进行强转前需使用instanceof操作符判断是否能成功强转。</strong></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>位于上层的类更具有一般性，更抽象。可使用abstract关键字将类声明为抽象。</p><p><strong>包含一个或多个抽象方法的类本身必须声明为抽象。</strong></p><p>抽象方法没有方法体。</p><p>抽象类可包含具体方法。（不建议这样做）</p><p>抽象类不能实例化，但可以定义一个抽象类的对象变量，但这个变量只能引用非抽象子类的实例。</p><h3 id="object类（所有类的超类）"><a href="#object类（所有类的超类）" class="headerlink" title="object类（所有类的超类）"></a>object类（所有类的超类）</h3><p>java中的每个类都继承object类。</p><p>可以用object类型的变量引用任何类型的对象。</p><h4 id="equals方法（boolean）"><a href="#equals方法（boolean）" class="headerlink" title="equals方法（boolean）"></a>equals方法（boolean）</h4><p>object类中的equals方法用于检测一个对象是否等于另一个对象。（确定是否引用相等）</p><p>如果检测两个对象是否拥有相等的状态，则需重写equals方法。（若在子类中则需先调用超类的方法）</p><p>性质：自反、对称、传递、一致</p><h4 id="hashCode（散列码）方法（int）"><a href="#hashCode（散列码）方法（int）" class="headerlink" title="hashCode（散列码）方法（int）"></a>hashCode（散列码）方法（int）</h4><p>是由对象导出的一个整型值。无规律。两个不同的对象散列码基本不同。</p><p>此方法定义在object类中，因此每个对象都有默认的散列码，其值由对象的存储地址得出。</p><p>字符串的散列码是由内容导出的，而字符串构建器由存储地址导出。</p><h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>object类中定义，返回对象的类名和散列码。</p><p>可在类中重写打印对象状态。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>**接口不是类，而是对希望符合这个接口类的一组需求 **</p><p>所有方法自动为public</p><p>**绝对不会有实例字段 **</p><p>可以定义方法（无方法体）可以定义常量。</p><p>不能构造接口的对象，却能声明接口的变量，必须引用实现了这个接口的类的对象。</p><p>可使用extends扩展接口。</p><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>一个类只能继承一个父类，但可以实现多个接口。</p><p>待编辑……</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习第一次</title>
      <link href="/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
      <url>/2021/05/21/java%E5%A4%8D%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java-复习第一次"><a href="#java-复习第一次" class="headerlink" title="java  复习第一次"></a>java  复习第一次</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h4><h6 id="·-依赖"><a href="#·-依赖" class="headerlink" title="· 依赖"></a>· 依赖</h6><p>即使用一个类时需要访问另一个类的对象</p><p>e.g.  订单类需要访问账户对象查看信用状态</p><h6 id="·-聚合"><a href="#·-聚合" class="headerlink" title="· 聚合"></a>· 聚合</h6><p>类A的对象包含一些类B的对象</p><h6 id="·-继承"><a href="#·-继承" class="headerlink" title="· 继承"></a>· 继承</h6><p>子类继承父类</p><h4 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h4><h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><p>​    · final实例字段 </p><p>​        这样的字段必须在构造对象时初始化并不能再修改。</p><p>​        此修饰符对于类型为基本类型或不可变类的字段尤其有用。</p><p>​    · 静态字段 </p><p>​            将一个字段定义为static，则每个类只有一个这样的字段，即使没有对象，静态字段也存在。（属于类而不属于单个对象）而对于        非静态的实例字段，每个对象都有自己的一个副本。</p><p>​        （所有类的对象的这个字段都是一个/类的每个对象都有各自的）</p><p>​    · 初始化数据字段的方法</p><p>​        · 在构造器中设置值</p><p>​        · 在声明中赋值</p><p>​        · 初始化块: 一个类的声明中可以包含任意多个代码块。只要构造类的对象，这些块就会被执行。</p><h6 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h6><p>​    · 与类同名</p><p>​    · 一个类可以有多个构造器（参数不同）（重载）</p><p>​    · 构造器可以没有参数或有多个参数</p><p>​    · 没有返回值</p><p>​    · 常与new操作符一起调用</p><p>​    · 无参数的构造器：创建对象时，对象状态会设置为适当的默认值。</p><p>​    · 使用this关键字调用同类的另一个构造器</p><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><p>​    · 显式参数和隐式参数</p><p>​        在方法名后的括号中声明的是显式参数</p><p>​        在方法中使用的对象的属性（方法调用的目标或接收者）是隐式参数。关键字this指示隐式参数。</p><p>​    · 静态方法</p><p>​        · 调用时并不使用任何类的对象，</p><p>​        · 没有隐式参数，</p><p>​        · 不能访问对象的实例字段，不能在对象上执行操作。</p><p>​        · 可访问静态字段</p><p>​        · 用类直接调用</p><p>​        · 静态方法和静态数据成员会随着类的定义而被分配和装载入内存中</p><p>​    · 普通方法</p><p>​        · 既可以访问静态数据成员 又可以访问非静态数据成员</p><p>​        · 只有在类的对象创建时在对象的内存中才有这个方法的代码段</p><p>​        · 只能用构造的类的对象调用方法</p><p>​    · 工厂方法</p><p>​        · 使用静态工厂方法构造对象</p><p>​        · 无法命名构造器（构造器的名字必须与类名相同，但希望有两个不同的名字时）</p><p>​        · 使用构造器时无法改变构造对象的类型</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>想要使用对象，必须通过构造器构造对象并指定初始状态，再对对象应用方法。</p><p>可用var关键字声明局部变量，无需指定类型。</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h6 id="·-静态字段"><a href="#·-静态字段" class="headerlink" title="· 静态字段"></a>· 静态字段</h6><p>​            将一个字段定义为static，则每个类只有一个这样的字段，即使没有对象，静态字段也存在。（属于类而不属于单个对象）而对于        非静态的实例字段，每个对象都有自己的一个副本。</p><p>​        （所有类的对象的这个字段都是一个/类的每个对象都有各自的）</p><h6 id="·-静态常量"><a href="#·-静态常量" class="headerlink" title="· 静态常量"></a>· 静态常量</h6><p>​        在类中定义一个静态常量后，可直接用类来调用这个常量。</p><h6 id="·-静态方法"><a href="#·-静态方法" class="headerlink" title="· 静态方法"></a>· 静态方法</h6><p>​        · 调用时并不使用任何类的对象，</p><p>​        · 没有隐式参数，</p><p>​        · 不能访问对象的实例字段，不能在对象上执行操作。</p><p>​        · 可访问静态字段</p><p>​        · 用类直接调用</p><h2 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h2><p>· 使用静态工厂方法构造对象。</p><p>​    LocalDate.now()；构造这个对象时的日期</p><p>​    LocalDate.of(YYYY,MM,DD)；指定日期</p><p>对于已构造的对象可使用getYear，getMonthValue，getDayOfMonth方法得到年月日</p><p>使用plusDay（int）方法计算距离当前日期的新日期</p><p>只访问对象不更改的成为访问器方法</p><p>修改对象的称为修改器方法</p><h2 id="java中各种访问器修饰符"><a href="#java中各种访问器修饰符" class="headerlink" title="java中各种访问器修饰符"></a>java中各种访问器修饰符</h2><h3 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h3><p>​        修饰的类，类属性变量及方法，包内及包外的任何类（包括子类和普通类）都可以访问。</p><h3 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h3><p>​        修饰的类，类属性变量及方法，只有本类可以访问，而在包内包外的任何类都不能访问。</p><h3 id="Protect"><a href="#Protect" class="headerlink" title="Protect"></a>Protect</h3><p>​        修饰的类，类属性变量及方法，包内的任何类及包外那些继承了该类的子类才能访问，重点突出继承。</p><h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p>​        如果一个类，类属性变量及方法没有用任何的修饰符，则其为默认的访问权限Default，默认的访问权限的类，类属性变量及方法，包内的任何类（包括继承了此类的子类）都可以访问他，而对于包外的任何类都不能访问他（包括包外继承了此类的子类），重点突出包。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​        Protected修饰符修饰的成员变量和方法也称为受保护的成员变量和方法，受保护的成员变量和方法可以再本类或者同一个包中的其他类（包括子类）中通过类的实例进行访问，也可以被同一个包中的类或不同包中的类继承，但是不能再不同包中的其他类（包括子    类）中通过类的实例进行访问。Protected属于子类限制修饰符。</p><p>​        Public修饰符修饰的类，那么该类的类名必须与他所在的源文件同名，一个.Java源文件中有且只有一个Public类，顶层类只能用Public和默认修饰符（无修饰符）修饰。</p><p>​        Protected修饰符修饰的类属性成员变量和方法，只可以被子类访问，而不管子类是不是和父类位于同一个包中。</p><p>​        Default修饰符修饰的类属性成员变量和方法，只可以被同一个包中的其他类访问，不管其他类是不是该类的子类。Default属于包限制修饰符。</p><p><img src="D:\博客\image-20210416205358673.png" alt="image-20210416205358673"></p><h2 id="Java中static方法和普通方法的区别"><a href="#Java中static方法和普通方法的区别" class="headerlink" title="Java中static方法和普通方法的区别"></a>Java中static方法和普通方法的区别</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>是使用static关键字修饰的方法，又叫类方法。属于类的，不属于对象，在实例化对象之前就可以通过类名.方法名调用静态方法。（静态属性，静态方法都是属于类的，可以直接通过类名调用）。</p><p>A.在静态方法中，可以调用静态方法。<br>B.在静态方法中，不能调用非静态方法。<br>C.在静态方法中，可以引用类变量（即，static修饰的变量）。<br>D.在静态方法中，不能引用成员变量（即，没有static修饰的变量）。<br>E.在静态方法中，不能使用super和this关键字</p><p>F.静态方法可以直接调用，类名调用和对象调用。（类名.方法名 / 对象名.方法名）</p><p>G.静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。（也就是静态方法属于类）静态方法会随着类的定义而被分配和装载入内存中，编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然可能有多个实例，但这些实例共享该内存，特别值得注意的是，任何一个对象对静态数据成员的修改，都会影响其它对象。</p><h3 id="非静态方法"><a href="#非静态方法" class="headerlink" title="非静态方法"></a>非静态方法</h3><p>是不含有static关键字修饰的普通方法，又称为实例方法，成员方法。属于对象的，不属于类的。（成员属性，成员方法是属于对象的，必须通过new关键字创建对象后，再通过对象调用）。</p><p>A.在普通方法中，可以调用普通方法。<br>B.在普通方法中，可以调用静态方法<br>C.在普通方法中，可以引用类变量和成员变量<br>D.在普通方法中，可以使用super和this关键字</p><p>E.非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。（也就是非静态方法属于对象）。静态不能引用非静态这一特性，是由于静态的会随着类的定义而被分配和装载入内存中这一关键点决定的；如果静态引用了非静态的，根本无法从内存中找到非静态的代码段，势必会出错，这种做法是Java虚拟机决不允许的</p><p>F.但是非静态方法只能通过对象调用。（对象名.方法名）</p><h4 id="总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用"><a href="#总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用" class="headerlink" title="总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用"></a>总结：类方法可以直接通过类名调用，实例方法必需先实例化类，再初始化对象，然后通过类的实例对象才能调用</h4><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><ul><li>链接博客：<a href="https://www.cnblogs.com/zhangyinhua/p/7689974.html">https://www.cnblogs.com/zhangyinhua/p/7689974.html</a></li></ul><h3 id="一、String简介"><a href="#一、String简介" class="headerlink" title="一、String简介"></a>一、String简介</h3><h4 id="1-1、String（字符串常量）概述"><a href="#1-1、String（字符串常量）概述" class="headerlink" title="1.1、String（字符串常量）概述"></a>1.1、String（字符串常量）概述</h4><p>　　在API中是这样描述：</p><p>　　　　String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>　　　　字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p><p>　　java.lang.String：</p><p>　　　　<img src="https://i.bmp.ovh/imgs/2021/06/b2e0a2fe6e82f27f.png"></p><h4 id="1-2、分析String源码"><a href="#1-2、分析String源码" class="headerlink" title="1.2、分析String源码"></a>1.2、分析String源码</h4><h5 id="1）String的成员变量"><a href="#1）String的成员变量" class="headerlink" title="1）String的成员变量"></a>1）String的成员变量</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">　<span class="comment">/** String的属性值 */</span>  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line"> <span class="comment">/**数组被使用的开始位置**/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"> <span class="comment">/**String中元素的个数**/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="comment">/**String类型的hash值**/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Class String is special cased within the Serialization Stream         Protocol.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">  * &lt;a href="{<span class="doctag">@docRoot</span>}/../platform/serialization/spec/output.html"&gt;</span></span><br><span class="line"><span class="comment">  * Object Serialization Specification, Section 6.2, "Stream Elements"&lt;/a&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">     <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></tbody></table></figure><p>　　　　从源码看出String底层使用一个字符数组来维护的。</p><p>　　　　成员变量可以知道String类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的String类型对象，存储String数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始。</p><h5 id="2）String的构造方法"><a href="#2）String的构造方法" class="headerlink" title="2）String的构造方法"></a>2）String的构造方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String() </span><br><span class="line">          初始化一个新创建的 String 对象，使其表示一个空字符序列。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes) </span><br><span class="line">          通过使用平台的默认字符集解码指定的 <span class="keyword">byte</span> 数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, Charset charset) </span><br><span class="line">          通过使用指定的 charset 解码指定的 <span class="keyword">byte</span> 数组，构造一个新的 String。  </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length) </span><br><span class="line">          通过使用平台的默认字符集解码指定的 <span class="keyword">byte</span> 子数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset) </span><br><span class="line">          通过使用指定的 charset 解码指定的 <span class="keyword">byte</span> 子数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName) </span><br><span class="line">          通过使用指定的字符集解码指定的 <span class="keyword">byte</span> 子数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName) </span><br><span class="line">          通过使用指定的 charset 解码指定的 <span class="keyword">byte</span> 数组，构造一个新的 String。 </span><br><span class="line">String(<span class="keyword">char</span>[] value) </span><br><span class="line">          分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。 </span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> offset, <span class="keyword">int</span> count) </span><br><span class="line">          分配一个新的 String，它包含取自字符数组参数一个子数组的字符。 </span><br><span class="line">String(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count) </span><br><span class="line">          分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。 </span><br><span class="line">String(String original) </span><br><span class="line">          初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。 </span><br><span class="line">String(StringBuffer buffer) </span><br><span class="line">          分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。 </span><br><span class="line">String(StringBuilder builder) </span><br><span class="line">          分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。 </span><br></pre></td></tr></tbody></table></figure><h3 id="二、创建字符串对象两种方式的区别"><a href="#二、创建字符串对象两种方式的区别" class="headerlink" title="二、创建字符串对象两种方式的区别"></a>二、创建字符串对象两种方式的区别</h3><h4 id="2-1、直接赋值方式创建对象"><a href="#2-1、直接赋值方式创建对象" class="headerlink" title="2.1、直接赋值方式创建对象"></a>2.1、直接赋值方式创建对象</h4><p>　　直接赋值方式创建对象是在方法区的常量池</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"hello"</span>;<span class="comment">//直接赋值的方式</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-2、通过构造方法创建字符串对象"><a href="#2-2、通过构造方法创建字符串对象" class="headerlink" title="2.2、通过构造方法创建字符串对象"></a>2.2、通过构造方法创建字符串对象</h4><p>　　通过构造方法创建字符串对象是在堆内存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"hello"</span>);<span class="comment">//实例化的方式</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-3、两种实例化方式的比较"><a href="#2-3、两种实例化方式的比较" class="headerlink" title="2.3、两种实例化方式的比较"></a>2.3、两种实例化方式的比较</h4><h5 id="1）编写代码比较"><a href="#1）编写代码比较" class="headerlink" title="1）编写代码比较"></a>1）编写代码比较</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String str1 = <span class="string">"Lance"</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"Lance"</span>);</span><br><span class="line">        String str3 = str2; <span class="comment">//引用传递，str3直接指向st2的堆内存地址</span></span><br><span class="line">        String str4 = <span class="string">"Lance"</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  ==:</span></span><br><span class="line"><span class="comment">         * 基本数据类型：比较的是基本数据类型的值是否相同</span></span><br><span class="line"><span class="comment">         * 引用数据类型：比较的是引用数据类型的地址值是否相同</span></span><br><span class="line"><span class="comment">         * 所以在这里的话：String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">         System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2）内存图分析"><a href="#2）内存图分析" class="headerlink" title="2）内存图分析"></a>2）内存图分析</h5><p><img src="https://i.bmp.ovh/imgs/2021/06/681a849a91ac6fc9.png"></p><p>可能这里还是不够明显，构造方法实例化方式的内存图：String str = new String(“Hello”);</p><p>首先：</p><p>​                              <img src="https://i.bmp.ovh/imgs/2021/06/78d97ef8ef8590e2.png"> 　　　　</p><p>当我们再一次的new一个String对象时：</p><p>　　　　　　<img src="https://i.bmp.ovh/imgs/2021/06/409ef81452f665b1.png"></p><h5 id="3）字符串常量池"><a href="#3）字符串常量池" class="headerlink" title="3）字符串常量池"></a>3）字符串常量池</h5><p>　　　　　　在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象，</p><p>　　　　　　这样，所有直接赋值的String对象，如果利用相同的“Lance”，则String对象==返回true；</p><p>　　　　　　比如：对象手工入池</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">     String str =<span class="keyword">new</span> String(<span class="string">"Lance"</span>).intern();<span class="comment">//对匿名对象"hello"进行手工入池操作</span></span><br><span class="line">     String str1=<span class="string">"Lance"</span>;</span><br><span class="line">     System.out.println(str==str1);<span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="4）总结：两种实例化方式的区别"><a href="#4）总结：两种实例化方式的区别" class="headerlink" title="4）总结：两种实例化方式的区别"></a>4）总结：两种实例化方式的区别</h5><p>　　　　　　1）直接赋值（String str = “hello”）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p>　　　　　　2）构造方法（String str=  new String(“hello”);）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。</p><p>　　　　　　　　在开发的过程中不会采用构造方法进行字符串的实例化。</p><p>　　　　5）避免空指向</p><p>　　　　　　首先了解： == 和public boolean equals()比较字符串的区别</p><p>　　　　　　==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向。</p><p>　　　　　　举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　String str = <span class="keyword">null</span>;</span><br><span class="line">　　　　　　<span class="keyword">if</span>(str.equals(<span class="string">"hello"</span>)){<span class="comment">//此时会出现空指向异常</span></span><br><span class="line">　　　　　　　　...</span><br><span class="line">　　　　　　}</span><br><span class="line">　　　　　　<span class="keyword">if</span>(<span class="string">"hello"</span>.equals(str)){<span class="comment">//此时equals会处理null值，可以避免空指向异常</span></span><br><span class="line">　　　　　　　　　...</span><br><span class="line">　　　　　　}</span><br></pre></td></tr></tbody></table></figure><p>　　　6）String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾</p><p> 　　　　　<img src="https://i.bmp.ovh/imgs/2021/06/661f67370a5cd175.png" style="zoom:50%;"></p><h3 id="三、String常用的方法"><a href="#三、String常用的方法" class="headerlink" title="三、String常用的方法"></a>三、String常用的方法</h3><p>　　<img src="https://i.bmp.ovh/imgs/2021/06/b4ccb91e286f6ba2.png" style="zoom:67%;"></p><h4 id="3-1、String的判断功能"><a href="#3-1、String的判断功能" class="headerlink" title="3.1、String的判断功能"></a>3.1、String的判断功能</h4><h5 id="1）常用方法"><a href="#1）常用方法" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>： 比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span>： 判断字符串对象是否以指定的str开头</span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span>： 判断字符串对象是否以指定的str结尾</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）代码测试"><a href="#2）代码测试" class="headerlink" title="2）代码测试"></a>2）代码测试</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">           <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"hello"</span>;</span><br><span class="line">        String s3 = <span class="string">"Hello"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2));</span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// boolean startsWith(String str):判断字符串对象是否以指定的str开头</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">"he"</span>));</span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">"ll"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">------------</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">------------</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2、String类的获取功能"><a href="#3-2、String类的获取功能" class="headerlink" title="3.2、String类的获取功能"></a>3.2、String类的获取功能</h4><h5 id="1）常用方法-1"><a href="#1）常用方法-1" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:获取字符串的长度，其实也就是字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>:获取指定索引处的字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>:获取str在字符串对象中第一次出现的索引</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>:从start开始截取字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:从start开始，到end结束截取字符串。包括start，不包括end</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）代码测试-1"><a href="#2）代码测试-1" class="headerlink" title="2）代码测试"></a>2）代码测试</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">          <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"helloworld"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"l"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"owo"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"ak"</span>));</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String substring(int start):从start开始截取字符串</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String substring(int start,int end):从start开始，到end结束截取字符串</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">        System.out.println(s.substring(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">----</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">----</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">----</span><br><span class="line">helloworld</span><br><span class="line">world</span><br><span class="line">----</span><br><span class="line">helloworld</span><br><span class="line">lowor</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3、String的转换功能"><a href="#3-3、String的转换功能" class="headerlink" title="3.3、String的转换功能"></a>3.3、String的转换功能</h4><h5 id="1）常用方法-2"><a href="#1）常用方法-2" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">char</span>[] toCharArray()：把字符串转换为字符数组</span><br><span class="line">　　<span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：把字符串转换为小写字符串</span></span><br><span class="line"><span class="function">　　String <span class="title">toUpperCase</span><span class="params">()</span>：把字符串转换为大写字符串</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）核心代码"><a href="#2）核心代码" class="headerlink" title="2）核心代码"></a>2）核心代码</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">         <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"abcde"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) {</span><br><span class="line">            System.out.println(chs[x]);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String toLowerCase():把字符串转换为小写字符串</span></span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>.toLowerCase());</span><br><span class="line">        <span class="comment">// String toUpperCase():把字符串转换为大写字符串</span></span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>.toUpperCase());</span><br><span class="line">        </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-----</span><br><span class="line">helloworld</span><br><span class="line">HELLOWORLD</span><br></pre></td></tr></tbody></table></figure><p>　　注意：　　</p><p>　　　　字符串的遍历有两种方式：一是ength()加上charAt()。二是把字符串转换为字符数组，然后遍历数组。</p><h4 id="3-4、其他常用方法"><a href="#3-4、其他常用方法" class="headerlink" title="3.4、其他常用方法"></a>3.4、其他常用方法</h4><h5 id="1）常用方法-3"><a href="#1）常用方法-3" class="headerlink" title="1）常用方法"></a>1）常用方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　去除字符串两端空格：<span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　按照指定符号分割字符串：String[] <span class="title">split</span><span class="params">(String str)</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="2）核心代码-1"><a href="#2）核心代码-1" class="headerlink" title="2）核心代码"></a>2）核心代码</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">          <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">"helloworld"</span>;</span><br><span class="line">        String s2 = <span class="string">" helloworld "</span>;</span><br><span class="line">        String s3 = <span class="string">" hello world "</span>;</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s1 + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s1.trim() + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s2 + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s2.trim() + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s3 + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---"</span> + s3.trim() + <span class="string">"---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// String[] split(String str)</span></span><br><span class="line">        <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s4 = <span class="string">"aa,bb,cc"</span>;</span><br><span class="line">        String[] strArray = s4.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) {</span><br><span class="line">            System.out.println(strArray[x]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---helloworld---</span><br><span class="line">---helloworld---</span><br><span class="line">--- helloworld ---</span><br><span class="line">---helloworld---</span><br><span class="line">--- hello world ---</span><br><span class="line">---hello world---   </span><br><span class="line">--------------------</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br></pre></td></tr></tbody></table></figure><h3 id="四、String的不可变性"><a href="#四、String的不可变性" class="headerlink" title="四、String的不可变性"></a>四、String的不可变性</h3><p>当我们去阅读源代码的时候，会发现有这样的一句话：</p><p><img src="https://i.bmp.ovh/imgs/2021/06/77ba33db8221bf91.png"></p><p>意思就是说：String是个常量，从一出生就注定不可变。</p><p>我想大家应该就知道为什么String不可变了，String类被final修饰，官方注释说明创建后不能被改变，但是为什么String要使用final修饰呢？　</p><h4 id="4-1、前言"><a href="#4-1、前言" class="headerlink" title="4.1、前言"></a>4.1、前言</h4><p>　　了解一个经典的面试题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(a==b);  <span class="comment">//true</span></span><br><span class="line">        System.out.println(a.equals(b));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(a==c);  <span class="comment">//false</span></span><br><span class="line">        System.out.println(a.equals(c));  <span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　内存图：</p><p>　　　　<img src="https://i.bmp.ovh/imgs/2021/06/bd29ee48dfea9c6a.png" style="zoom:80%;"></p><h4 id="4-2、分析"><a href="#4-2、分析" class="headerlink" title="4.2、分析"></a>4.2、分析</h4><p>　　因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，</p><p>　　就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。　　</p><p>　　需要说明一点的是，在object中，equals()是用来比较内存地址的，但是String重写了equals()方法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。</p><h4 id="4-3、String不可变的好处"><a href="#4-3、String不可变的好处" class="headerlink" title="4.3、String不可变的好处"></a>4.3、String不可变的好处</h4><p>　　可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</p><p>　　我们的程序中大量使用了String字符串，有可能是出于安全性考虑。</p><p>　　大家都知道HashMap中key为String类型，如果可变将变的多么可怕。</p><p>　　当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。</p><h3 id="五、字符串常量池"><a href="#五、字符串常量池" class="headerlink" title="五、字符串常量池"></a>五、字符串常量池</h3><h4 id="5-1、字符串常量池概述"><a href="#5-1、字符串常量池概述" class="headerlink" title="5.1、字符串常量池概述"></a>5.1、字符串常量池概述</h4><h5 id="1）常量池表（Constant-Pool-table）"><a href="#1）常量池表（Constant-Pool-table）" class="headerlink" title="1）常量池表（Constant_Pool table）"></a>1）常量池表（Constant_Pool table）</h5><p>　　　　Class文件中存储所有常量（包括字符串）的table。<br>　　　　这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。</p><h5 id="2）运行时常量池（Runtime-Constant-Pool）"><a href="#2）运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="2）运行时常量池（Runtime Constant Pool）"></a>2）运行时常量池（Runtime Constant Pool）</h5><p>　　　　JVM内存中方法区的一部分，这是运行时的内容<br>　　　　这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池<br>　　　　上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容</p><h5 id="3）字符串常量池（String-Pool）"><a href="#3）字符串常量池（String-Pool）" class="headerlink" title="3）字符串常量池（String Pool）"></a>3）字符串常量池（String Pool）</h5><p>　　　　这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个<br>　　　　JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</p><h4 id="5-2、享元模式"><a href="#5-2、享元模式" class="headerlink" title="5.2、享元模式"></a>5.2、享元模式</h4><p>　　其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式<br>　　也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素<br>　　Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p><h4 id="5-3、详细分析"><a href="#5-3、详细分析" class="headerlink" title="5.3、详细分析"></a>5.3、详细分析</h4><p>　　举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x  = <span class="number">10</span>;</span><br><span class="line">String y = <span class="string">"hello"</span>;</span><br></pre></td></tr></tbody></table></figure><p>　　1)首先，<code>10</code>和<code>"hello"</code>会在经过javac（或者其他编译器）编译过后变为Class文件中<code>constant_pool table</code>的内容</p><p>　　2)当我们的程序运行时，也就是说JVM运行时，每个Class<code>constant_pool table</code>中的内容会被加载到JVM内存中的方法区中各自Class的<code>Runtime Constant Pool。</code></p><p>　　3)一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是”hello”）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下：　　　</p><p>　　　　一是：在Java Heap中根据”hello”字面量create一个字符串对象<br>　　　　二是：将字面量”hello”与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：”hello” = 对象的引用地址。</p><p>　　　另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？</p><p>　　策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，如上3</p><p>　　如此，就实现了享元模式，提高的内存利用效率。</p><p>　　举例：</p><p>　　　　　　使用String s = new String(“hello”);会创建几个对象</p><p>　　　　　　会创建2个对象</p><p>　　　　　　首先，出现了字面量”hello”，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量”hello”首先创建1个String对象。</p><p>　　　　　　接着，new String(“hello”)，关键字new又在Java Heap中创建了1个对象，然后调用接收String参数的构造器进行了初始化。最终s的引用是这个String对象.</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/04/24/hello-world/"/>
      <url>/2021/04/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
